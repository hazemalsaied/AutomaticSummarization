<PAPER>
	<ABSTRACT>
		<S sid="1" ssid="1">A formal treatment of typed feature structures ( TFSs ) is developed to augment TFSs , so that negative descriptions of them can be treated . </S>
		<S sid="2" ssid="2">Negative descriptions of TFSs can make linguistic descriptions compact and thus easy to understand . </S>
		<S sid="3" ssid="3">Negative descriptions can be classified into three primitive negative descriptions : ( 1 ) negations of type symbols , ( 2 ) negations of feature existences , and ( 3 ) negations of feature-address value agreements . </S>
		<S sid="4" ssid="4">The formalization in this paper is based on AitKaci &amp; capos s complex terms . </S>
		<S sid="5" ssid="5">The first description is treated by extending type symbol lattices to include complement type symbols . </S>
		<S sid="6" ssid="6">The second and third are treated by augmenting terns structures with structures representation negations . </S>
		<S sid="7" ssid="7">Algorithms for augmented-WS unification have been developed using graph unification , and programs using these algorithms have been written in Common Lisp . </S>
	</ABSTRACT>
	<SECTION number="1" title="Introduction">
			<S sid="8" ssid="8">In unification-based or information-based linguistic the most important objects are structures called &amp; capos feature structures &amp; capos ( FSs ) , which are used to describe linguistic objects and phenomena . </S>
			<S sid="9" ssid="9">A fea true structure is either atomic or complex : an atomic FS is denoted by an atomic symbol ; a complex FS consists of a set of feature-value pairs each of which describes an aspect of an object . </S>
			<S sid="10" ssid="10">Partial information on an object is merged by applying the unification operation to FSs . </S>
			<S sid="11" ssid="11">Research on unification-based linguistic theories has been accompanied by research on FSs themselves . </S>
			<S sid="12" ssid="12">Several extensions on FSs or on feature descriptions and formal treatments of the extensions have been proposed . </S>
			<S sid="13" ssid="13">Disjunctive and negative descriptions on FSs help make the linguistic descriptions simple , compact , and thus easy to understand . </S>
			<S sid="14" ssid="14">For disjunctive feature descriptions , Kay [ 14 ] introduces them into FUG ( Functional Unification Grammar ) and gives the procedural semantics . </S>
			<S sid="15" ssid="15">Karoline 111 also proposes procedural treatments of disjunctions in conjunction with relatively simple negations . </S>
			<S sid="16" ssid="16">Rounds and Kasper [ 19 , 13 ] propose a logic-based formalization uses automate to model FSs and can treat disjunctive feature descriptions , and they obtain important results . </S>
			<S sid="17" ssid="17">For negative descriptions of FSs , one of the fundamental properties of FSs , the partiality of in formation they carry , makes its insufficient to adopt relatively simple treatments . </S>
			<S sid="18" ssid="18">Classical interpretation of negation , for example , does not allow evaluation of negations to be freely interleaved with unification . </S>
			<S sid="19" ssid="19">Mo shier and Rounds [ 171 propose a formal framework which treats negative feature descriptions on the basis of intuitionist logic . </S>
			<S sid="20" ssid="20">However , their formalism has trouble treating double negations . </S>
			<S sid="21" ssid="21">Dewar 5 ] proposes a formal treatment based on three-valued logic . </S>
			<S sid="22" ssid="22">In order to treat feature domains of complex FSsand to treat taxonomic hierarchies of symbolic feature values , type ( or sort ) hierarchies have been in introduce allowing definition of typed ( or sorted ) feature-structures ( Ms ) . </S>
			<S sid="23" ssid="23">A TI &amp; capos S consists of a type symbol from a lattice and a set of feature-value pairs . </S>
			<S sid="24" ssid="24">A TFS can be seen as a generalized concept of both atomic and complex FSs . </S>
			<S sid="25" ssid="25">Pollard and Sag [ I8 ) intro duce sorts into II PSG ( Head-driven Phrase Structtire Grammar ) and use sorted P.is to describe linguistic objects . </S>
			<S sid="26" ssid="26">AH-Kaci [ ll proposes an algebraic framework using the and c-types , one of promising formalizations of 1TSs , based on lattice theory . </S>
			<S sid="27" ssid="27">This formalization was originally aimed at formalizing and in integrating various kinds of knowledge representation frameworks in Al . In this approach , types are defined as equivalence classes of complex term structures . </S>
			<S sid="28" ssid="28">Assumption relation is defined on these term structures . </S>
			<S sid="29" ssid="29">The join and meet operations on them correspond to the generalization and an opera sons on TFSs , respectively . </S>
			<S sid="30" ssid="30">This approach essentially adopts &amp; capos type-as-set &amp; capos semantics . </S>
			<S sid="31" ssid="31">Subtype relationships on type correspond to consumption relationships on denotations of types . </S>
			<S sid="32" ssid="32">Based on this Frau a &amp; capos work , an extension to Prolog , , LOGIN ( 2 ] , has been developed . </S>
			<S sid="33" ssid="33">Smock 20 ] proposes a feature logic with subsoils.In this approach , negative descriptions can be deco in posed into three kinds of primitive negations , namely , negations of sorts or complement sorts which denote the complements of sets that positive counterparts de note , negations of feature existences , and negations of agreement or feature-address dis agreement . </S>
			<S sid="34" ssid="34">Smock extends feature descriptions but interpretation of an extended de description does not include negative in fort nation and corresponds to a simple TI &amp; capos S.Some WS-based natural language processing systems have been developed [ 7 , 24 , 12 , 15 , 8 , 22 ] . </S>
			<S sid="35" ssid="35">Car enter and Pollard [ 4 ] propose an interface to build type lattices . </S>
			<S sid="36" ssid="36">Formalizations of extended FSs and of extended feature-descriptions , described above , are classified into two classes : ( 1 ) extensions of FSs themselves , and ( 2 ) extensions not of Pis themselves hut of feature-descriptions . </S>
			<S sid="37" ssid="37">Previous attempts to introduce hierarchies fall into the former class while previous treatments of disjunctive and negative descriptions mainly fall into the latter . </S>
			<S sid="38" ssid="38">Acres us COLINGt92 , NANTES , 2328 Am-Yr 1992 380 PROC . </S>
			<S sid="39" ssid="39">OF COLING92 , NANTES , AuG , 2328 , 1992 This paper proposes an extension to Aithaci &amp; capos sV &amp; capos type that incorporates three kinds of the primitive negative descriptions described below into the 0-type . </S>
			<S sid="40" ssid="40">AitKaci &amp; capos s 0-type formalization uses ter in structures . </S>
			<S sid="41" ssid="41">In this paper , both these type structures and the type symbol lattice on which term structures are define extended to treat negative descriptions . </S>
			<S sid="42" ssid="42">Negations of type symbols are treated by extending type symbol lattices , and negations of feature existence disagreements are treated by ex tending term structures . </S>
			<S sid="43" ssid="43">This extension can be seen as intuitionist . </S>
			<S sid="44" ssid="44">The extension is classified into class ( 1 ) above.Based on this paper 's formalization , unification al algorithms have been developed using graph unification techniques 23 , 16 ] . </S>
			<S sid="45" ssid="45">Programs based on these algorithm have been implemented in Common Lisp . </S>
			<S sid="46" ssid="46">&lt; /bodyText &gt; &lt; sectionHeader confidence 0.650502 '' genericHeader= '' method '' &gt; </S>
	</SECTION>
	<SECTION number="2" title="Requirements of Negative. ">
			<S sid="47" ssid="1">&lt; /sectionHeader &gt; &lt; subsectionHeader confidence 0.434954 '' &gt; Descriptions of TFSs &lt; /subsectionHeader &gt; &lt; bodyText confidence 0.971192533333333 '' &gt; In describing linguistic information using ( typed ) feature structures , negative descriptions make the description compact , intuitive , and hence easy to understand . </S>
			<S sid="48" ssid="2">For example , we want to describe the grammatical agreement for an English verb , say &amp; amp ; quot ; eat &amp; amp ; quot ; , nat rally as follows . </S>
			<S sid="49" ssid="3">syn [ ( agreement igr { t ; number s person 3rd -\ This description specifies compactly and directly that it is not the case that the person attribute is third and that the number attribute is singular . </S>
			<S sid="50" ssid="4">If we could not use such complex negative descriptions , would write it using disjunctive descriptions with sim ple complement types as follows . </S>
			<S sid="51" ssid="5">&lt; /bodyText &gt; &lt; equation confidence 0.674182333333333 '' &gt; syn agreement up { person -- , 3rd 1 syn ( agreement up { number I ] Or &lt; equation &lt; bodyText confidence 0.998926764705882 '' &gt; { syn 1 agreement apt person 1st ] ] syn ( agreement nut person 2nd ] ] syn ( agreement awl number pil ] In this case , ( 1 ) is easier to understand than ( 2 ) or ( 3 ) .In the above case , we can describe the information because the complex negative descriptions can be transformed into the disjunction of simple negative descriptions with an almost , same intended mean ing ) and because both person and number features take their values from { 1st , 2nd , 3rd ) and Isg , p1 ) .However , it is not always the case that such transformations are possible and that feature takes its value from a finite set.Let us consider more complicated cases using dif reference lists expressed using feature structures. 1 The empty list of categories is represented as follows . </S>
			<S sid="52" ssid="6">&lt; /bodyText &gt; &lt; equation confidence 0.976748 '' &gt; ( Hist { in X1 : list ] OW X1 ( 4 ) &lt; equation &lt; bodyText confidence 0.999914857142857 '' &gt; In the above example , the tag symbol , X1 shows that features in and out must take the same value . </S>
			<S sid="53" ssid="7">&amp; capos In 11PSG and JPSG ( Japanese Phrase StructureGrammar ) , a difference fist is very convenient for express ing sub cat and stash feature values . </S>
			<S sid="54" ssid="8">How can only non-emptiness be expressed &amp; capos ? </S>
			<S sid="55" ssid="9">Iii sis impossible using complement , type symbols or dis junctions because we Call consider the set of all finite length lists whose elements cant be taken from infinite sets . </S>
			<S sid="56" ssid="10">Direct or indirect extension of feature structures is required.So far , we have discussed the require of negative descriptions of type symbols and of feature-valueagreements front the viewpoint cif capability of describing linguistic information . </S>
			<S sid="57" ssid="11">There are other ad vantages of allowing negative descriptions . </S>
			<S sid="58" ssid="12">Consider , for example , debugging processes of grammatical descriptions by parsing sample sentences . </S>
			<S sid="59" ssid="13">We may ob tin unexpected results such as a TES with an it type symbol , a &amp; capos IFS with an unexpected fea true value agreement and so on . </S>
			<S sid="60" ssid="14">In such situations , negative descriptions can be useful tools for detecting their reasons . </S>
			<S sid="61" ssid="15">&amp; capos lb make linguistic descriptions compact and thus easy to understand , to treat natural language efficiently , and to detect error reasons rapidly , it is necessary to develop formalizations and methods of treat . </S>
			<S sid="62" ssid="16">Mg negative descriptions . </S>
	</SECTION>
	<SECTION number="3" title="Formal Treatment of Negative. ">
			<S sid="63" ssid="1">Descriptions of TFSs As stated earlier , a typed feature structure ( TI &amp; capos S ) consists of a type symbol and a set of feature-value pairs . </S>
			<S sid="64" ssid="2">l &amp; capos hus , descriptions of TF , Ss are classified into descriptions of TFSs having : ( I ) a certain type symbol ( or having a subtype sym bol of it certain type symbol ) , ( 2 ) a feature , and ( 3 ) two feature-address values that agree . </S>
			<S sid="65" ssid="3">A TFS can be described by using conjunctions disjunctive of such kinds of descriptions . </S>
			<S sid="66" ssid="4">A conjunctive and disjunctive TFS can be formalized as Alt aci &amp; capos s 0-type and e-type , respectively . </S>
			<S sid="67" ssid="5">&amp; capos that is , a 0-type , which has a complex term structure called a 0-term as its syntax , represents a conjunction of such kinds of descriptions or a conjunctive typed feature structure , and an n-type is a maximal set of 0-types representing the disjunction of them . </S>
			<S sid="68" ssid="6">Negative counterparts of these descriptions are classified into descriptions of TFSs : ( 1 &amp; capos ) not having a certain type symbol ( or having a type symbol which is not subsumed by a certain type symbol ) , ( 2 &amp; capos ) not having it certain feature , and ( 3 &amp; capos ) having two feature-address values that do not agree.Ily incorporating structures representing such neg native descriptions into a 0-term , a &amp; capos [ &amp; capos F &amp; capos S with the neg.. </S>
			<S sid="69" ssid="7">native descriptions can be formalized . </S>
			<S sid="70" ssid="8">Such it term called an augmented therm and a type with an aug meted as its syntax is called an augmented0-type . </S>
			<S sid="71" ssid="9">From augmented 0-terms , an augmented ( term can be constructed in the same manner that an e- term is constructed from 0-terms . </S>
			<S sid="72" ssid="10">Next , augmented 0 , -terms and 0-types are defined . </S>
			<S sid="73" ssid="11">&amp; capos Fenn structures are first augmented with structures representing in features and disagreement of feature address values . </S>
			<S sid="74" ssid="12">Then , type symbol lattices are extended to include complement type symbols as suggested in [ 1 ] . </S>
			<S sid="75" ssid="13">( 1 ) Acres DE COLING92 , NAnn ES , 2328 min &amp; capos 1992 3 8 1 Pxoc . </S>
			<S sid="76" ssid="14">OF COLING92 , NANTES , AUG. 2328 , 1992 3.1 Typed Feature Structures as . </S>
			<S sid="77" ssid="15">Augmented g &amp; capos TypesIn order to define complex term structures , a signature is used to specify their vocabulary . </S>
			<S sid="78" ssid="16">It serves as the interface between their syntax and semantics . </S>
			<S sid="79" ssid="17">A signature is formally defined as follows , Definition 1 A signature is a quadruple ( 7 , &amp; lt ; 7 V ) consisting of : 1 . </S>
			<S sid="80" ssid="18">a set T of type symbols containing T and 2 . </S>
			<S sid="81" ssid="19">a partial order &amp; lt ; 7 on T such that ( a ) I. is the least and T is the greatest element , and ( b ) every pair of type symbols a , b E 7 have a least upper bound or join , which is denoted by a VT b and a greatest lower bound or meet , which is denoted by a AT b , 3 . </S>
			<S sid="82" ssid="20">a set T of feature symbols , and 4 . </S>
			<S sid="83" ssid="21">a set V of tag symbols where T , F and V are pairwise disjoint . </S>
			<S sid="84" ssid="22">A simple &amp; capos type-as-set &amp; capos semantics is adopted for these objects , That is , a type symbol in T denotes a set of objects in an interpretation , Here , T and .1 denote the sets called the universe , written as U , and the empty set 0 , respectively . </S>
			<S sid="85" ssid="23">Another element a denotes a nonempty subset of U , written as [ a ] .The partial order &amp; lt ; T denotes the consumption son between these sets ; for any type symbols a , b , and c , 1 . </S>
			<S sid="86" ssid="24">a &amp; lt ; 7 b if and only if [ a C [ b ] , 2 . </S>
			<S sid="87" ssid="25">a VT b = c if and only if [ a ] U [ b ] = [ cil , and 3 . </S>
			<S sid="88" ssid="26">a AT b = c if and only if lain 114 = A feature symbol denotes a function from a subset of U to U . A feature path is a finite string of feature symbols and denotes the function obtained by the composition of the functions that the feature symbols denote . </S>
			<S sid="89" ssid="27">A term is defined from a signature . </S>
			<S sid="90" ssid="28">First , a term domain is defined as a skeleton built from feature symbols . </S>
			<S sid="91" ssid="29">Definition 2 A term domain A on T is a set of finite strings of feature symbols in ( including the empty string e ) such that 1 . </S>
			<S sid="92" ssid="30">A is prefix-closed : Vp , q E I &amp; capos , if p &#226;&#128;&#162; g E A , then p E A ; and 2 . </S>
			<S sid="93" ssid="31">A is finitely branching : if p E A , then If E E A } is finite where is the string concatenation operator . </S>
			<S sid="94" ssid="32">An element of a term domain is called a feature address or a feature path . </S>
			<S sid="95" ssid="33">By definition , the empty string c must belong to all term domains and is called the root address . </S>
			<S sid="96" ssid="34">A term domain is represented by a rooted directed graph within which each arc has a feature symbol as its label . </S>
			<S sid="97" ssid="35">A sub domain of a term domain , corresponding to a subgraph , is defined as follows , Definition 3 Given a term domain A and a feature address p E A , the sub domain of A at p is defined to be the term domain A/p : = { P &amp; capos I P &#226;&#128;&#162; P &amp; capos E A } . </S>
			<S sid="98" ssid="36">The set of all domains of A is denoted by Subdom ( A ) .Next , flesh is put on the term structure &amp; capos s skeleton ton as defined as a term domain by assigning several kinds of objects to each feature address . </S>
			<S sid="99" ssid="37">AltKaci &amp; capos s term structure , the basis of the tit-type , is defined by assigning a type symbol and a tag symbol to each feature address as follows . </S>
			<S sid="100" ssid="38">Definition 4 A term is a triple ( Ar , v ) where A is a term domain on .F , r is a type symbol function from .7 to T such that r ( T* &#226;&#128;&#148; A ) = IT ) , and v is a tag symbol function from A to V. Given a tag symbol function v , Addl.. , denotes the function from a tag symbol to the set of addresses : Addr , ( X ) : = Al v ( p ) = X } . </S>
			<S sid="101" ssid="39">( 5 ) In order to treat negations of feature existences andfeature-address value disagreement , the term structure defined above is augmented by assigning additional objects , a set of inhibited features and a set of disagreement tag symbols , to each feature address . </S>
			<S sid="102" ssid="40">Definition 5 An augmented term is a quintuple ( A , r , v , rn , x ) where A is a term domain on r is a type symbol function from , F* to T such that r ( T* &#226;&#128;&#148; A ) _-= { T ) , v is a tag symbol function from A to V , tO is an inhibited feature function front , T* to 2Y such that 0 ( p ) is finite for any p E A and ( b ( TI* &#226;&#128;&#148; A ) = 10 ) , and x is a disagreement tag sym bol function from .T* to 2v such that x ( p ) is finite for any p E A and x ( T* &#226;&#128;&#148; A ) =The inhibited feature function specifies which fea lures can not exist at a given address . </S>
			<S sid="103" ssid="41">There is thus inconsistency if there is an address p in A such that tb ( P ) n { f E.FIP&#226;&#128;&#162;f EA } 0 . </S>
			<S sid="104" ssid="42">( 6 ) The disagreement tag symbol function x specifies , for a given address , substructures with which its ar argument disagrees . </S>
			<S sid="105" ssid="43">There is thus inconsistency if there is an address p in A such that v ( P ) E X ( P ) . </S>
			<S sid="106" ssid="44">( 7 ) The disagreement address function Disagr5 from A to 2F. , based on v and x , takes an address as its argument , and gives the set of addresses with which argument address must disagree , called the dis agreement address set and defined as : Disagr&#226;&#128;&#158; , x ( p ) U Addr&#226;&#128;&#158; ( X ) . </S>
			<S sid="107" ssid="45">( 8 ) XEx ( p ) Augmented terms are hereafter referred to simply as terms unless stated otherwise . </S>
			<S sid="108" ssid="46">Definition 6 Given a term = ( A , r , v , rP , x ) and a feature address p in A , the subtenant of t at the address p is the term tip = ( A/ p , r/p , v/p , ( pip , x/p ) where r/p : T* v/p : A/p V , 5b/p 2 , and &#226;&#128;&#148; 2v are defined by ( r/p ) ( g ) : = r ( p &#226;&#128;&#162; q ) , ( 9a ) ( v/P ) ( q ) v ( P 4 ) , ( 9b ) ( 44P ) ( q ) : = 56 ( p &#226;&#128;&#162; 9 ) , ( Sc ) ( WOW : = X ( P &#226;&#128;&#162; 9 ) . </S>
			<S sid="109" ssid="47">( 9d ) For a term t = ( A , r , 0 , X ) , a type symbol a ( sim similarly a tag symbol or a term V ) is said to occur in t if there is a feature address p in A such that r ( p ) = a ( similarly , v ( p ) = X or X C x ( p ) , or th = I &amp; capos ) . </S>
			<S sid="110" ssid="48">A term I = ( A , r , v , x ) is said to be regular if the set of all subterfuges of t , Subterm ( t ) : = { Ur I p E A ) , is finite . </S>
			<S sid="111" ssid="49">Hereafter , we will consider only regular terms . </S>
			<S sid="112" ssid="50">In a regular term , only finite numbers of type symbols and tag symbols occur . </S>
			<S sid="113" ssid="51">&amp; capos For any set S , 2s denotes the set of subsets of S. ACIE.S DE COLING92 , NAMES , 2328 Aoirr 1992 382 PROC . </S>
			<S sid="114" ssid="52">OF COLING92 , NArrres , Ann . </S>
			<S sid="115" ssid="53">2328 , 1992 tempted Xi : { } list in X2 : { first } { } : T { out X2 nonempty X3 : ( ) : { } : list X4 : { } : { X6 } : list In [ first X5 : { ) : { ) out X6 : { ) : { X4 } : list Figure I : Examples of Augmented Terms in Matrix Notation Gmtall nonempty : { ) : { ) : list X3 : { } : { ) : list in out X4:1 ) : ( X6 ) X2 : { first ) : ( I list . first Est X5:1 ) : { } Figure 2 : Examples of Augmented Terms in Directed Graph Notation In a term , any two feature addresses bearing the same symbol are said to co refer . </S>
			<S sid="116" ssid="54">Thus , the co refer relation a of a term is a relation defined on A as the kernel of the tag function v ; i.e. , a : = Ker ( v ) =00 . </S>
			<S sid="117" ssid="55">here , a is an equivalence relation and a a class is called a co reference class . </S>
			<S sid="118" ssid="56">Definition 7 A term t is referentially consistent if the same sub term occurs at all feature addresses in a co reference a term is referentially consistent , then by definition , for any pi , P2 E A , if v ( pi ) = v ( p2 ) then , for all p such that pi &#226;&#128;&#162; p E A , it follows that p2 &#226;&#128;&#162; p E A and pi &#226;&#128;&#162; p ) = v ( p2 &#226;&#128;&#162; p ) . </S>
			<S sid="119" ssid="57">Therefore , if a term is referentially consistent , a is a right-invariant equivalence or right-congruence on A . That is , for any pi , P2 E A , if pocp 2 then ( pi p ) tc ( P2 p ) for any p such that PI P C A . Definition 8 A well-formed term ( wft . ) </S>
			<S sid="120" ssid="58">is a referentially-consistent regular term . </S>
			<S sid="121" ssid="59">The set of all well-formed terms is denoted by W.TT.A term can be represented in matrix notation . </S>
			<S sid="122" ssid="60">Ex ample of terms are shown in Figure 1 . </S>
			<S sid="123" ssid="61">In this figure , T , list and list are type symbols , in , oat and first feature symbols , and Xl , X2 , ... are tag sym boils . </S>
			<S sid="124" ssid="62">A matrix represents a set of feature-value preceded by a tag symbol , followed by a set of inhibited features and followed by a set of disagreement tag symbols . </S>
			<S sid="125" ssid="63">In the term 4&#226;&#128;&#158; , , ty , its sub terms at in and tout while i , ,o&#226;&#128;&#158; &#226;&#128;&#158; , p iy is a term in which its sub terms at in and at out should not co refer . </S>
			<S sid="126" ssid="64">The term lUnpmy should not have the feature address in &#226;&#128;&#162; first while tnoflsmpCy has that address . </S>
			<S sid="127" ssid="65">A term can also be represented by directed graphs ( DGs ) . </S>
			<S sid="128" ssid="66"> 1mjiy and 1 , , , &#226;&#128;&#158; , &#226;&#128;&#158; , pi y in Figure I are shown as DGs in Figure 2 . </S>
			<S sid="129" ssid="67">The set 14./Y7 &amp; capos of well-formed terms includes many terms that have the same type symbol function , the same co reference relations , the same inhibited feature function and the same disagreement address function but different tag symbol functions . </S>
			<S sid="130" ssid="68">These terms have the same information and can describe the same linguistic object or the same linguistic phenomena.These terms construct equivalence classes by Renard tag symbols in a certain manner . </S>
			<S sid="131" ssid="69">Definition 9 Two terms ti = , 01A , xi ) and 12 = ( A2 , r2 , v2,02 X2 ) are alphabetical variants of each other if and only if 1 . </S>
			<S sid="132" ssid="70">Al = A2 , . </S>
			<S sid="133" ssid="71">2 . </S>
			<S sid="134" ssid="72">Ker ( m ) = Ker ( v2 ) , . </S>
			<S sid="135" ssid="73">3 . </S>
			<S sid="136" ssid="74">r = r2r 5 . </S>
			<S sid="137" ssid="75">Disarrange x , . </S>
			<S sid="138" ssid="76">This is written as ti 012 . </S>
			<S sid="139" ssid="77">According to &amp; capos type-as-set &amp; capos semantics , the symbols T and _1 denote , respectively , the least informative type- -the whole universe U and the overrefined or inconsistency typewriter empty set ( 6 . </S>
			<S sid="140" ssid="78">Therefore , term containing A_ should be interpreted as inconsistent . </S>
			<S sid="141" ssid="79">Such an inconsistency is called a type inconsistency . </S>
			<S sid="142" ssid="80">To treat , such inconsistency , a relation 41 on 311.1.TY is defined as follows . </S>
			<S sid="143" ssid="81">Definition 10 For any two terms ( 1 , 12 G W_TT , ti1,11 12 if and only if I occurs in both ti and 12 . </S>
			<S sid="144" ssid="82">There are other kinds of inconsistency as mentioned earlier . </S>
			<S sid="145" ssid="83">If a term contains an address p such that tjt ( p ) D { J. p f E it is inconsistent because it [ mans that there are features that should not exist at the address . </S>
			<S sid="146" ssid="84">Such an inconsistency is called a feature inconsistency . </S>
			<S sid="147" ssid="85">In addition , if a term contains an address p such that v ( p ) E x ( p ) , it is inconsistent because it means that the sub term at p does not agree with itself . </S>
			<S sid="148" ssid="86">Such an inconsistency is called a tag inconsistency . </S>
			<S sid="149" ssid="87">lien cc , the three kinds of inconsistency are premeditatedly by a relation ff on W.FT defined as fol lows . </S>
			<S sid="150" ssid="88">Definition 11 For any two terms 1i , 12 E WTT , 11 1,1 12 if and only if each of them contains at least one address p such that 1 . </S>
			<S sid="151" ssid="89">TOO . </S>
			<S sid="152" ssid="90">2 . </S>
			<S sid="153" ssid="91">0 ( p ) ( 1 { , / eYlpICA ) ( 4 , or 3 . </S>
			<S sid="154" ssid="92">1- ) ( P ) C X ( 1 ) ) . </S>
			<S sid="155" ssid="93">Clearly , if I occurs in a term , it also occurs in all terms in its a-class . </S>
			<S sid="156" ssid="94">This is also true for feature inconsistency and tag inconsistency . </S>
			<S sid="157" ssid="95">Hence , the relations and 1,1 are such that their [ &amp; capos Mon becomes an equiv valence relation . </S>
			<S sid="158" ssid="96">Thus , we can defined the augmented 0-types as follows . </S>
			<S sid="159" ssid="97">Definition 12 An augmented tp-type ( or 1 , G-type for short ) [ 1 ] is an element of the quotient set sit : = 34 ) 4iritaicTiC structures of augmented 8/-types will called augmented 0-terms . </S>
			<S sid="160" ssid="98">An augmented typed feature-structure can be formalized as an augmented 1Pt3Te&#226;&#128;&#162;The set of type symbols T lots the partial order &#226;&#128;&#162; ( 7 which denotes a subsection relation between the set denoted by type symbols . </S>
			<S sid="161" ssid="99">The partial ordering on 7- can be extended to augmented 0-terms and types . </S>
			<S sid="162" ssid="100">The consumption orders on W.TT and on sP are defined as follows . </S>
			<S sid="163" ssid="101">T ] out &#226;&#128;&#148; &#226;&#128;&#148; &#226;&#128;&#148; X6:0:1X41 fist ACTES DE COLING92 , NiorrEs , 2328 Aoirr 1992 383 PRoc . </S>
			<S sid="164" ssid="102">OF COLING92 , NastrEs , AUG. 2328 , 1992 Definition 13 Let tt = ( AI , rt , v1,01 xi ) and 12 = ( A2,12 , v2,562 X2 ) be WFTs . </S>
			<S sid="165" ssid="103">ti is said to be sub sued by t2 , written tt &amp; lt ; 12 , if and only if either ti 1 or 1 . </S>
			<S sid="166" ssid="104">A2 C At , 2 . </S>
			<S sid="167" ssid="105">Ker ( u2 ) C Ker ( vi ) , . </S>
			<S sid="168" ssid="106">3 . </S>
			<S sid="169" ssid="107">Vp E P TI ( P ) r2 ( P ) , . </S>
	</SECTION>
	<SECTION number="4" title="Vp E P462(P) C Ot(P), and. ">
			<S sid="170" ssid="1">The consumption order on IP are defined by [ Ii ] &amp; lt ; [ 12 ] if ti &amp; lt ; 12 is well-defined.Lattice operations on P can be defined to be com compatible with the above consumption order relation as follows . </S>
			<S sid="171" ssid="2">Theorem 1 If ( 7 ; &amp; lt ; r ) is a lattice , then so is IP.Proof . </S>
			<S sid="172" ssid="3">This theorem can be proved in a very similar manner to the counterpart for AltKaci &amp; capos s 0-terms . </S>
			<S sid="173" ssid="4">Therefore , instead of providing the proof in detail , only the definitions of the least upper bounds or jointedness greatest lower bounds provided below . </S>
			<S sid="174" ssid="5">Let ti = ( A1 , T1,4u,01 , X1 ) and 12 - ( 412 , 1 &amp; capos 29 2,21 021 X2 ) be WFTs . </S>
			<S sid="175" ssid="6">First , the join of ti and 12 , 13 = ti V l2 is defined as follows : A3 = n A2 03 : A30 V such that Ker ( v3 ) = n and Vp Er3 ( p ) = OAP ) = X3 ( P ) = 4 ( p ) ( q ) 1 prize i = 1,21 , ( 11d ) and X4 ( P ) = Uly4 ( 9 )  r ( Disagr&#226;&#128;&#158; , &#226;&#128;&#158; ( p ) UDisagr , , ( p ) ) ) ( 11e ) V 1 , ,0&#226;&#128;&#158;&#226;&#128;&#158; &#226;&#128;&#158;&#226;&#128;&#152;&#226;&#128;&#158; : : { } : list in X8 : { } : ( ) : list 1 out X9 { } : ( ) : list J A X10 : : 1 ) : list X11 : ( first ) : ( X11 ) list = [ 151 [ first X12 : { ) : { ) : T ] out X11 Figure 3 : Examples of Join and Meet of Augmented 0-Terms &#194;&#176; 41 &amp; amp ; quot ; V &amp; amp ; quot ; , for is = 0 , K141 = u { ( Pi P , P2 &#226;&#128;&#162; P ) I Pi On-111121 , for n &amp; gt ; 1 and a : f &amp; amp ; quot ; u&#194;&#176; &amp; capos is the reflexive extension of Ki from A ; to Ai U A2 for i = 1 , 2.The conditions ( 11a11e define a meet , that col lapses to _L whenever conditions ( 11cTle ) produce some address p such that type inconsistency , feature inconsistency , or tag inconsistency occurs at p. The V is a join operation and A is a meet operation are compatible with the consumption order de fined in Definition 13.Examples of join and meet operations on aug meted are shown in Figure 3 . </S>
			<S sid="176" ssid="7">The join and meet operations on augmented 0-types correspond to the generalization and unification operations on TFSs.Nit-Kaci defines an c-type as a maximal set of  0types . </S>
			<S sid="177" ssid="8">It is also possible to &amp; lt ; lave an augmented ( type as a maximal set of augmented 1P-types in the same manlier , making disjunctive and negative de descriptions possible . </S>
			<S sid="178" ssid="9">3.2 Type Symbol Lattice Extension to . </S>
			<S sid="179" ssid="10">Include Complement Type SymbolsTreating a negative description of a given type sym bol , say a , requires a type symbol b such that b ha , sonly information that unification of it with is yields in consistency , or such that a VT h = T and aAr b = I . Such a symbol is called a complement type symbol of a and written as a &amp; capos . </S>
			<S sid="180" ssid="11">If a given type symbol lattice ( T ; &amp; lt ; r ) is a Boolean lattice , that is , a complemented 3 distributive lattice , we do not need to do anything . </S>
			<S sid="181" ssid="12">Otherwise , we must extend the lattice to include the complements of the type symbols contained in the given lattice . </S>
			<S sid="182" ssid="13">For a finite type symbol lattice T , for example , a Boolean lattice 7 &amp; capos can be constructed as follows . </S>
			<S sid="183" ssid="14">Let A : fat , , aN1 be the set of atoms of 7 , that is , type symbols which cover 1.4 If there arenon-atomic type symbols which cover only one sym bol , for each such symbol a , a new atom is added &amp; capos A lattice is called complemented if its all elements have complements . [ 3 ] &amp; capos a is said to cover 13 if b &amp; lt ; 7 a and b &amp; lt ; 7 c &amp; lt ; -r a implies c = b. r1 ( p ) VT T2 ( P ) , ( 10c ) 01 ( P ) n 02 ( 0 , and ( 10d ) - { u3 ( q ) I q E ( Disagr&#226;&#128;&#158; , , , ( p ) ( Oil . </S>
			<S sid="184" ssid="15">( 10e ) Next , the meet of ti and 13 , 14= A 12 = ( A4,14 , V4 /59 , X4 ) , is defined as follows : P4 = At*1 &amp; capos ( 11a ) : V such that Ker ( v4 ) = kit ( 11b ) and Vp 74 ( p ) = Vrfri ( q ) I  i = 1,21 , ( 11c ) U At &amp; amp ; quot ; 1 &amp; capos nc -- 0 / Li A2 for = 0 , co ,14 ) = U &amp; capos 1 &amp; amp ; quot ; 1 &amp; capos n=0 where U IP E I ptcHq q E for n &amp; gt ; 1 , Acne DE COLING92 , NANTES , 2328 main . </S>
			<S sid="185" ssid="16">1992 384 PROC . </S>
			<S sid="186" ssid="17">or COLING92 , NANres , Auo . </S>
			<S sid="187" ssid="18">2328 , 1992 node structure 111=111111110M11= rinIMINI/a set o arc structures 11=121111111= 011=1111111111=12=11M011&#226;&#150; 1 MIIIIIIIIIMIEMIE 1/4=11&#226;&#128;&#162;1111ELIMMTIM 111121MIMICIIMEDIEED Figure 4 : Data Structures Function Unify ( node nodc 2 begin node ] : = Dereference ( node ; riode 2 -= Dereference ( ruxle 2 ; if node ] = node then return ( node 1 ) ; node forward : = node 2 node 2.tsymbol = node ] turnbuckle AT node 2.tsymbol if node 2.tsymbol _I_ then return ( i ) node 2.ileatures node ] features U node 2 ilea lures if node 2.ifeaturesn arc . feature I arc E node ] arcs U node narcs 0 then returned 1 . ) ; node 2.dnodes = node ! </S>
			<S sid="188" ssid="19">nodes U node 2.dnodes if { node node 2 fl node 2.dnodes then retiring ..t. ; arc pairs = Shared _Arc_Pairs ( node node 2 ; for ( arc ] , arc 2 in &#194;&#176;repairs do begin value : = Unify ( oral value , arc 2.value ; if value -= then return ( &#194;&#177; ) ; end ; arcs : = Coroplement_Ares ( node I , node ! ] ) ; node ! ] </S>
			<S sid="189" ssid="20">arcs := arcs U node . arcs ; overturn node 2 ; end Figure 5 : A Destructive Graph Unification Functionso that a covers an additional type symbol . </S>
			<S sid="190" ssid="21">The ex tended lattice T &amp; capos is the set of subsets of A with set inclusion ordering . </S>
			<S sid="191" ssid="22">An element failiE/ E T &amp; capos denotes U,51Ea1 . </S>
			<S sid="192" ssid="23">The join and meet operations on are the and set-intersection operations , respectively . </S>
			<S sid="193" ssid="24">The complement of an element fading iii T &amp; capos is the set-complement of it with respect to A , that is , EAla tailback &#226;&#128;&#162; 4 Implementation of Augmented TFS . </S>
			<S sid="194" ssid="25">Unification The unification operation for augmented tk-terms or augmented TFSs has been implemented using graph unification techniques . </S>
			<S sid="195" ssid="26">A term structure is represented as a directed graph by assigning a graph node each K-class as in Figure 2 . </S>
			<S sid="196" ssid="27">The unification operation for such DGs corresponds to a graph merging operation . </S>
			<S sid="197" ssid="28">This takes two DGs and merges hi-classes of the same feature-address into a K-class . </S>
			<S sid="198" ssid="29">In a destructive graph unification method , winch is very simple , such a graph is represented by the data structures in Figure 4 . </S>
			<S sid="199" ssid="30">A node structure consists of five fields : symbol for a type symbol , arcs for a set of feature-value pairs , gestures for a set of inhibited features nodes for a set of disagreement nodes- i.e. , disagreement K-classes , and forward . </S>
			<S sid="200" ssid="31">The field forward is used for the Union-Find algorithm [ 9 ] to calculate unions of K-classes in the same manner as Duct &amp; capos s algorithm [ 10 ] . </S>
			<S sid="201" ssid="32">By traversing two DGs &amp; capos nodes with the same feature-address simultaneously , calculating the union of their K-classes , and copying arcs , their unification can be calculated as in Figure 5 . </S>
			<S sid="202" ssid="33">The function Unify takes two input nodes and puts them in a K.-class by letting one input be the forward field values . </S>
			<S sid="203" ssid="34">The function then examines three kinds of inconsistency ; namely , type inconsistency , feature inconsistency , and tag inconsistency . </S>
			<S sid="204" ssid="35">The function finally treats arcs in order to make the result graph right-congruent . </S>
			<S sid="205" ssid="36">For treating arcs , the function Unify assumes two functions , Shared_Arc_Pairs and Comylemeni_Arcs . </S>
			<S sid="206" ssid="37">The function Shared_Arc_Pairs takes two nodes as its inputs and gives a set of arc pairs each consisting of both inputs &amp; capos arcs wide a shared feature . </S>
			<S sid="207" ssid="38">The function Complemenl_A re S also takes two nodes and gives a set of arcs whose features exist in the first node but not in the second . </S>
			<S sid="208" ssid="39">An inhibited feature function is implemented using the gestures field of nodes . </S>
			<S sid="209" ssid="40">When unification of two nodes results in a node with an arc with a feature in features it yields I because of feature inconsistency . </S>
			<S sid="210" ssid="41">A disagreement tag symbol function is implemented using nodes . </S>
			<S sid="211" ssid="42">Unification of two nodes which have each other in their nodes yields 1 because of tag inconsistency . </S>
			<S sid="212" ssid="43">These computations require negligible additional computation . </S>
			<S sid="213" ssid="44">To simplify the explanation , the destructive version of graph unification is used above . </S>
			<S sid="214" ssid="45">Other versions based on more efficient graph unification methods such as Wroblewski 's and Kogure 's method [ 23 , 16 ) have also been developed . </S>
			<S sid="215" ssid="46">Furthermore , it is easy to modify other graph unification methods 21 , 61 to allow augmented 1TSs . </S>
	</SECTION>
	<SECTION number="5" title="Conclusion. ">
			<S sid="216" ssid="1">This paper has proposed an augmentation of feature structures ( FSs ) which introduces negative in formation into FSs in unification-based formalisms.Unification-based linguistic formalisms use lbs to describe linguistic objects and phenomena . </S>
			<S sid="217" ssid="2">Because lin linguistic information can be described compactly using disjunctive and negative descriptions , l &amp; capos Ss and feature descriptions are required to treat such descriptions . </S>
			<S sid="218" ssid="3">In this paper , FSs have been augmented , using a promising method of for AltKaci &amp; capos s type , to allow three kinds of negative descriptions of them to be treated.In a formalization of typed feature structures , neg native descriptions can be decomposed into three kinds of negations : negations of type symbols , negations of feature existences , and negations of feature-address value agreements . </S>
			<S sid="219" ssid="4">It is shown that the second and third kinds can be treated by augmenting term structures to include structures representing such kinds of descriptions . </S>
			<S sid="220" ssid="5">Consumption relations on augmented terms are defined . </S>
			<S sid="221" ssid="6">It is also shown that the first kind can be treated by extending type symbol lattices to include complement type symbols. &amp; capos Die proposed formalization can provide efficient al AcrEs 05 COLING92 , NANTES , 2328 &#194;&#176;art 1992 3 8 5 PROC . </S>
			<S sid="222" ssid="7">OF COLING92 , NANTES , AuG. 2328 , 1992 algorithms for generalization and unification operation well as treat primitive negations . </S>
			<S sid="223" ssid="8">The formalization can be integrated with logic-based framework as [ 20 ] which can treat wider ranges of descriptions but which do not have such efficient algorithms for these operations . </S>
			<S sid="224" ssid="9">Logic-based frameworks can be used to obtain the data structures for this paper &amp; capos s formalization.Unification algorithms for augmented terms or augmented TFSs have been developed using graph uni fiction techniques . </S>
			<S sid="225" ssid="10">Unification programs based on these algorithms have been developed in Common Lisp.The augmentation of TFSs makes linguistic de descriptions compact and easy to understand , In an HPSG-based grammar , for example , non-emptinessof a sub cat or slash feature value can be easily de scribed by using feature-address value disagreement.Moreover , negative descriptions make debugging pro cresses of grammatical descriptions easier . </S>
	</SECTION>
	<SECTION title="Acknowledgments">
			<S sid="226" ssid="11">This research was performed in the VCAT project of the Takeuchi Research Group in NTT Basic Research Laboratories . </S>
			<S sid="227" ssid="12">The author would like to thank Ikuo Takeuchi , Akira Shimazu , Shozo Naito , Masahito Kawamori , Mikio Nakano , and other colleagues of the group for their encouragement and thought-provoking discussions . </S>
	</SECTION>
</PAPER>