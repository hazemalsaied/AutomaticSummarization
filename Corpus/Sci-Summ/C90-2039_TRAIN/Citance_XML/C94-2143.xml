<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">The revised graph unification algorithms presented here are more efficient because they reduce the amount of copying that was necessary because of the assumption that data-structure sharing in inputs occurs only when feature-structure sharing occurs.</S>
	</ABSTRACT>
	<SECTION title="INTRODUCTION" number = "1">
			<S sid ="2" ssid = "2">Constraint-based linguistic frameworks use logical systems called feature logics (Kasper &amp; Rounds, 1986; Shieber, 1989; Srnolka, 1988), which describe linguistic objects by using logical formulas called feature descriptions that have as their models feature structures or typed feature structures.</S>
			<S sid ="3" ssid = "3">Shieber (1989) argued that if the canonical models of finite formulas of a feature logic were themselves finite, we could use them to compute over instead of theorem-proving over the for- nmlas themselves.</S>
			<S sid ="4" ssid = "4">This would be advantageous if we had efficient algorithms for manipulating the canonical models.</S>
			<S sid ="5" ssid = "5">The most important operation on models- feature structures or typed feature structures is combining the information two models contain.</S>
			<S sid ="6" ssid = "6">This operation is traditionally called unification, although recently it has come to be more suitably called informational union.</S>
			<S sid ="7" ssid = "7">This unification operation is significant not only theoretically but also practically because the efficiency of systems based on constraint-based formalisms depends on the (typed) feature structure unification and/or feature description unification algorithms they use.</S>
			<S sid ="8" ssid = "8">1 This dependency is especially crucial for monostratal formalisms -that is, formalisms which use only (typed) feature structures such as HPSG (Pollard &amp; Sag, 1987) and JPSG (Gunji, 1987)?</S>
			<S sid ="9" ssid = "9">The efficiency of (typed) feature structure unification has been improved by developing algorithms that take as their inputs two directed graphs representing (typed) feature structures, copy all or part of them, and give a directed graph representing the unification result.</S>
			<S sid ="10" ssid = "10">These algorithms are thus called graph unification.</S>
			<S sid ="11" ssid = "11">Previous researeh has identified graph copying as a significant overhead and has attempted to reduce this overhead by lazy copying and structure sharing.</S>
			<S sid ="12" ssid = "12">Unification algorithms developed so far, however, including those allowing structure sharing seem to 1For example, the TASL1NK natural language system uses 80% of the processing time for feature structure unification and other computations required by unification, i.e., feature structure pre-copying (Godden, 1990).</S>
			<S sid ="13" ssid = "13">2For example, a spoken-style .Japanese sentence analysis system based on HPSG (Kogure, 1989) uses 90%-98% of the processing time for feature structure unification.</S>
			<S sid ="14" ssid = "14">syn | Fig.</S>
			<S sid ="15" ssid = "15">1: Matrix notation for a typed feature structure.</S>
			<S sid ="16" ssid = "16">contradict structure sharing because they assmne the two input graphs never share their parts with each other.</S>
			<S sid ="17" ssid = "17">This &quot;structure sharing&quot; assumption prevents the initial data structures fl&apos;om sharing structures for representing linguistic principles and lexical information even though many lexical items share common information and such initial data structure sharing could significantly reduce the amount of data structures required, thus making natural language systems much more efficient.</S>
			<S sid ="18" ssid = "18">Furthermore, even if the structure sharing assumption holds initially, unification algorithms allowing structure sharing can yield situations that violate the assumption.</S>
			<S sid ="19" ssid = "19">The ways in which such unification algorithms are used are therefore restricted and this restriction reduces their efficiency.</S>
			<S sid ="20" ssid = "20">This paper proposes a solution to this &quot;structure sharing problem&quot; and provides three algorithms.</S>
			<S sid ="21" ssid = "21">Section 2 briefly explains typed feature structures, Section 3 defines the structure sharing problem, and Section 4 presents key ideas used in solving this problem and provides three graph unification algorithms that increase the efficiency of feature structure unification in constraint-based natural language processing.</S>
	</SECTION>
	<SECTION title="TYPED FEATURE STRUCTURES. " number = "2">
			<S sid ="22" ssid = "1">The concept of typed feature structures attgments the concept of feature structures.</S>
			<S sid ="23" ssid = "2">A typed feature structure consists of a set of feature-value pairs in which each value is a typed feature structure.</S>
			<S sid ="24" ssid = "3">The set of type symbols is partially ordered by subsumption ordering _&lt;7 and constitutes a lattice in which the greatest element T corresponds to &apos;no information&apos; and the least element J_ corresponds to &apos;over-defined&apos; or &apos;inconsistency.&apos;</S>
			<S sid ="25" ssid = "4">For any two type symbols a, b in this lattice, their least npper bound and greatest lower bound are respectively denoted a VT b and a AT- It).</S>
			<S sid ="26" ssid = "5">Typed feature strnctures are represented in matrix notation as shown in Fig.</S>
			<S sid ="27" ssid = "6">1, where syn, agr, sg, and 3rd are type symbols; agree, hum, per, and subj are feature symbols; and X is a tag symbol.</S>
			<S sid ="28" ssid = "7">A feature- address that is, a finite (possibly empty) string of feature symbols is used to specify a feature value of an embedded structure.</S>
			<S sid ="29" ssid = "8">In Fig.</S>
			<S sid ="30" ssid = "9">1, for example, the structure at the feature-address agree . uum, where &apos;.&apos; is the concatenation operator, is said to have sg as its type symbol.</S>
			<S sid ="31" ssid = "10">The root feature-address is de- l \\su bj agrec li ~.syn a/agr~ fl re c ++ N sg 3rd Fig.</S>
			<S sid ="32" ssid = "11">2: Graph representation of a typed feature struc- l, ure.</S>
			<S sid ="33" ssid = "12">noted by &apos;(.&apos;</S>
			<S sid ="34" ssid = "13">To specify token-identity in matrix notation, a tag symbol is used: feature-address values with the same tag symbol arc token-identical, and those featm&apos;e-addresses with the token-identical value are said to corefer.</S>
			<S sid ="35" ssid = "14">/n Fig.</S>
			<S sid ="36" ssid = "15">1, the feature-addresses agree and subj • agree corefer.</S>
			<S sid ="37" ssid = "16">A typed feature, structure is also represented by a rooted, connected, directed graph within which each node corresponds to a typed feature structure and is labeled with a type symbol (and, optionally, a tag symbol) and each arc corresponds to a feature.-value pair and is labeled with a ti&apos;~ature symbol.</S>
			<S sid ="38" ssid = "17">Fig.</S>
			<S sid ="39" ssid = "18">2 illustrates the graph representation of the typed feature structure whose matrix notation is shown in Fig.</S>
			<S sid ="40" ssid = "19">1.</S>
			<S sid ="41" ssid = "20">In a graph representation, the values at corefcrent Ihatureaddresscs that is, token-identical values are represented by the same node.</S>
			<S sid ="42" ssid = "21">&apos;[&apos;he set of typed featm:e structures is also partially ordered by a subsumption ordering that is an exten--siou of the subsnmptiol, ordering on the set of type symbols.</S>
			<S sid ="43" ssid = "22">A typed feature structure tl is less than or equal to tu (written as tl &lt;, in) if and only if tt is iuconsistent (that is, if it includes the type symbol ]_) or (i) t~ &apos;s type symbol al is less than or equal to t~&apos;s type symbol a2 (a~ _&lt;7 ap.); (ii) each h&apos;.atur(~ f of 12 exists in ll and has a value 12, f such that its counter= part ttj is less than or equal to t2,j&apos;; m&apos;/] (iii) each coreference relation holding in 12 also holds in 11.</S>
			<S sid ="44" ssid = "23">&apos;.l&apos;his subsumpl, ion ordering serves its the basis for (Mining two lattice operations: generalization (the least upper bound or join) and unitlcation (the greatest lower bound or meet).</S>
			<S sid ="45" ssid = "24">Typed feature structures have been formalized in several ways, such as by using .I/%types (MtKaci, 198~).</S>
	</SECTION>
	<SECTION title="THE STRUCTURE SHARING PROI1LEM. " number = "3">
			<S sid ="46" ssid = "1">3.1 Graph Unification Algorithms.</S>
			<S sid ="47" ssid = "2">The destructive unitlcation algorithnl presenled by Aitq(aci is the starting point in increasing the efliciency of graph unification.</S>
			<S sid ="48" ssid = "3">It is a node-merging process that uses the Unio&gt;Find algorithm, which wits originally devek)t)ed for testing tinite automata equivalence (llopcroft &amp; Karp, 1971), in a manner w.&apos;ry similar to that of the unification algorithm for rational terms (llnet, 197(i).</S>
			<S sid ="49" ssid = "4">(&apos;,iveu two root nodes of graphs representing (typed) feature structures, this algorithm simultaneously traverses a pair of input nodes with the same feature-address, putting them node structure tsymbol {a type symbol) a7c8 (a set of arc structures} generation {an integer) forward NIL I {a node st,&apos;ucturc) NIL I {~ node structure} copy I (a copydcp structure) arc structure label (~ feature symbol} vahw {a node structure) copydep structure generation | {an integer} deps [ (a set of node and arc p~irs) Fig.</S>
			<S sid ="50" ssid = "5">3: I)ata structures for nondestructive unification an&lt;l LING unification.</S>
			<S sid ="51" ssid = "6">into a new and larger coreference class, and then returns the lnerged graph, Since the destructive unification process modifies its input graphs, they must first be copied if their contents are to bc preserved.</S>
			<S sid ="52" ssid = "7">Nondeterminism in parsing, for example, requires the preservation of graph structures not only for initial graphs representing lcxical entries and phrase structure rules but also for those representing well-formed intermediate structures.</S>
			<S sid ="53" ssid = "8">Although the overhead for this copying is significant, it is impossible to represent a resul.-taut unitied graph without creating any new strut tures.</S>
			<S sid ="54" ssid = "9">Unnecessary copying, though, must be identified and minimized.</S>
			<S sid ="55" ssid = "10">Wroblewski (1987) delined two kinds of unnecessary copying- over-copying (copying structures not needed to represent resultant graphs) and early-copying (copying structures even though unitication fails) -but this account is flawed because the resultant graph is assumed to consist only of newly created structures even if parts of the inputs that are not changed during mtitication could be shared with the resultant graph.</S>
			<S sid ="56" ssid = "11">A more eNcient unification algorithm would avoid this redundant copying (copying structures that can be shared by the input and resultant graphs) (Kogure, 1990).</S>
			<S sid ="57" ssid = "12">To distinguish structure sharing at the implementation level fl&apos;om that at the logical lew&apos;l (that is, coreference relations between feature-addresses), the lbrmer is called data-structure sharing and the latter is called feature-structure sharing (Tomabechi, 1992).</S>
			<S sid ="58" ssid = "13">&apos;[&apos;he key approaches to reducing the amount of structures copied are lazy copying and data-structure sharing.</S>
			<S sid ="59" ssid = "14">For lazy copying, Karttnnen (1986) proposed a reversible unification that saves the original contents of the.</S>
			<S sid ="60" ssid = "15">inputs into prealloeated areas immediately before destructive modification, copies the resultant graph if necessary, and then restores the original contents by undoing all the changes made during mlitication.</S>
			<S sid ="61" ssid = "16">Wroblewski (1987), on the other hand, proposed a uondestructiw~ unitication with incremental copying.</S>
			<S sid ="62" ssid = "17">Given two graphs, Wroblewski&apos;s algorithm simultaneously traverses each pair of input nodes with the same feature-address and creates a (:ommon copy of the input nodes.</S>
			<S sid ="63" ssid = "18">The nondestructive unification algorithm for typed feature structures uses the data structures shown in Fig.</S>
			<S sid ="64" ssid = "19">3.</S>
			<S sid ="65" ssid = "20">a The algorithm connects an input node and its copy node with a copy link that is, it sets the copy node as the input&apos;s copy field value.</S>
			<S sid ="66" ssid = "21">The link is meaningflfl during only one unification process and thus enables nondestructive modification.</S>
			<S sid ="67" ssid = "22">4 Using an idea similar to Karttunen&apos;s, Tomabechi (1991) proposed a quasi-destructive unification that uses node structures with fields for keeping update information that survives only during the unification process.</S>
			<S sid ="68" ssid = "23">5 Unification algorithms allowing data-structure sharing (DSS unification algorithms) are based on two approaches: the Boyer and Moore approach, which was originally developed for term unification in theorem-proving (Boyer &amp; Moore, 1972) and was adopted by Pereira (1985); and the lazy copying suggested by Karttnnen ~nd Kay (1985).</S>
			<S sid ="69" ssid = "24">Recent lazy copying unification algorithms are based on Wroblewski&apos;s or Tomabeehi&apos;s schema: Godden (1990) proposed a unification algorithm that uses active data structures, Kogure (1990) proposed a lazy incremental copy graph (LING) unification that uses dependency-directed eol)yiug, and Emeie (1991) proposed a lazy-incremental copying (LIC) unification that uses chronological dereference.</S>
			<S sid ="70" ssid = "25">These algorithms are b0,sed on Wroblewski&apos;s algorithm, and Tomabechi (1992) has proposed a data-structure-sharing version of his quasi-destructive unification.</S>
			<S sid ="71" ssid = "26">3.2 The Structure Sharing Problem.</S>
			<S sid ="72" ssid = "27">The graph unification algorithms mentioned so far-- perhaps all those developed so far--assume that data- structure sharing between two input structures occurs only when feature-structure sharing occurs between feature-addresses they represent.</S>
			<S sid ="73" ssid = "28">This &quot;structure sharing&quot; assumption prevents data-structure sharing between initial data structures for representing linguistic principles and lexical information even though many lexical items share common information.</S>
			<S sid ="74" ssid = "29">For example, many lexical items in a traditional syntactic categories such as noun, intransitive verb, transitive verb, and so on share most of their syntactic information and differ in their semantic aspects such as semantic sortal restriction.</S>
			<S sid ="75" ssid = "30">Such initial data-structure sharing could significantly reduce the amount of data structures required and could therefore reduce page- swapping and garbage-collection and make natural language processing systems much more efficient.</S>
			<S sid ="76" ssid = "31">Furthermore, even if the structure sharing assumption holds initially, applying a DSS unification algorithm in natural language processing such as parsing and generation can give rise to situations that violate the assumption.</S>
			<S sid ="77" ssid = "32">Consider, for example, JPSGaFor the nondestructive unification algorithm, the node structure takes as its copy field value either NJ L or a node structure only.</S>
			<S sid ="78" ssid = "33">4In this algorithm each unification process has an integer as its process identifier and each node created in a process has the identifier as its generation field vMue.</S>
			<S sid ="79" ssid = "34">A copy link is meaningful only if its destination node has the current process identifier.</S>
			<S sid ="80" ssid = "35">Such a node is called ~current.&apos;</S>
			<S sid ="81" ssid = "36">~The technique used to control the lifetime of update data is the same as that of Wroblewski&apos;s algorithm.</S>
			<S sid ="82" ssid = "37">based parsing.</S>
			<S sid ="83" ssid = "38">There are only a few phrase structure rules in this fl&apos;amework and the Complement-Head Construction rule of the form &apos;M --+ C It&apos; is applied very frequently.</S>
			<S sid ="84" ssid = "39">For instance, consider constructing a structure of the form [vP~ NP2 [vP, NP1 VII.</S>
			<S sid ="85" ssid = "40">When the rule is applied, the typed feature structure for the rule is unified with the structure resulting from embedding the typed feature structure for NPl at the feature-address for the complement daughter in the rule (e.g., dtrs.</S>
			<S sid ="86" ssid = "41">cdtr), and the unification result is then unified with the structure resulting from embedding the typed feature structure for V at the feature-address for the head daughter.</S>
			<S sid ="87" ssid = "42">Because not every substructure of the structure for the rule always changed during such a unification process, there may be some substructures shared by the strneture for the rule and the structure for VP1.</S>
			<S sid ="88" ssid = "43">Thus, when constructing VP2 there may be unexpected and unde- sired data-structure sharing between the structures.</S>
			<S sid ="89" ssid = "44">Let me illustrate what happens in such eases by using a simple example.</S>
			<S sid ="90" ssid = "45">Suppose that we use the non-destructive unification algorithm or one of its data- structure sharing versions, the LING or I,IC algorithm.</S>
			<S sid ="91" ssid = "46">The nondestructive and LING unification algorithms use the data structures shown in Fig.</S>
			<S sid ="92" ssid = "47">3, and the LIC algorithm uses the same data structures except that its ~zode structure has no forward field.</S>
			<S sid ="93" ssid = "48">Consider unification of the typed feature structures tl and t2 shown in Fig.</S>
			<S sid ="94" ssid = "49">4(a).</S>
			<S sid ="95" ssid = "50">Suppose that t, and t2 are respectively represented by the directed graphs in Fig.</S>
			<S sid ="96" ssid = "51">4(b) whose root nodes are labeled by tag symbols X0 and X4.</S>
			<S sid ="97" ssid = "52">That is, tj&apos;s substructure at feature-address f2 and t2&apos;S substructure at ]&apos;1 are represented by the same data structure while feature- structure sharing does not hold between them, and tl&apos;s substructure at ]3 and t2&apos;s substructure at; f4 are represented by the same data structure while feature- structure sharing does not hold between them.</S>
			<S sid ="98" ssid = "53">Each of the algorithms simultaneously traverses a pair of input nodes with the same feature-address both of the inputs have Dora the root feature-address to leaf feature-addresses, makes a common copy of them to represent the unification result of that feature-address, and connects the input and ontput nodes with copy links.</S>
			<S sid ="99" ssid = "54">For any feature-address that only one of the inputs has, the nondestructive unification algorithm copies the subgraph whose root is the node for that feature-address and adds the copied subgraph to the output structure, whereas the LING and LIC algorithms make the node shared by the input and outpnt structures.</S>
			<S sid ="100" ssid = "55">In the case shown in Fig.</S>
			<S sid ="101" ssid = "56">4(b) the root nodes of the inputs nodes with the tag symbols Xo and X4 are first treated by creating a common copy of them (i.e., the output node with Yo), connecting the input and output nodes with copy links, and setting bo = ao A:r a4 as the copy&apos;s lsymbol wdue.</S>
			<S sid ="102" ssid = "57">Then the input nodes&apos; arc structures are treated.</S>
			<S sid ="103" ssid = "58">Snt&gt; pose that the pair off1 arcs is treated first.</S>
			<S sid ="104" ssid = "59">After the input nodes at feature-address fl are treated in the same manner as the root nodes, the pair of fie arcs is treated.</S>
			<S sid ="105" ssid = "60">In this case, tl&apos;s node at f2 (labeled X2) already has a copy link because the node is also used as t2&apos;s node at ]&apos;1 so that the destination node of the link is used as this featnre-address&apos;s output node.</S>
			<S sid ="106" ssid = "61">Af k *~* tt : a0 f2 II2 , I ] Lfa aa t2 : a4 la a~ , (a) Input typed feature structures.</S>
			<S sid ="107" ssid = "62">input tl Int)ut t2 X0:a0 Xva¢ :,/ &quot;:..-:: :,/&quot; ,\:, x:, / &quot;, &apos;, /;()utl)ut la &quot;,,,\\/,: \, .....</S>
			<S sid ="108" ssid = "63">Yo:bo i ~&apos;\ / ] , i k, ,,,\ s,/ s,,, ,.</S>
			<S sid ="109" ssid = "64">Yl:bl ~ copy lin k (b) Snapshot of incremental graph ratification allowing data-structure sharing, ta : t)o Xa:aa &apos; LA: t)a II.</S>
			<S sid ="110" ssid = "65">At t2 : t)o aa LA: aa where, ])0 =: a 0 A,] &quot;14~ bl --alA7 a2Av a~, ID2 ~ at A&apos;I a:~, |)3 = a2 A7 aE,.</S>
			<S sid ="111" ssid = "66">(c) Wrong graph unili(:ation outl)ut (ta) and the cot-- rect unifi(-ation of the inputs (t~ At Zp,,).</S>
			<S sid ="112" ssid = "67">l&quot;ig.</S>
			<S sid ="113" ssid = "68">4: An examph; of incorrect graph unitication.</S>
			<S sid ="114" ssid = "69">ter the common label arcs are treated, unique label arcs are treated.</S>
			<S sid ="115" ssid = "70">The nondestructive, unitication algorithm copies tl&apos;s Ca and t~&apos;s f4 arcs and adds them go the output root node, whercas the LING and tIC a.1gorithms make the input and output structures share their destination nodes, t:&apos;inally, the I,ING and MC algorithms obtain gr~l)h t: n represented in matrix notation ill Fig.</S>
			<S sid ="116" ssid = "71">4((&apos;i)just over the correct result.</S>
			<S sid ="117" ssid = "72">The nondestructive unification algorithni obtains the same typed feature structure.</S>
			<S sid ="118" ssid = "73">The reversible and the quasi-destructiw&apos;, unification algoril, hms are also ,mable to obtain the correct result for this example becatlS(; these Mgorithms cmmot represent two update nodes by using a single node.</S>
			<S sid ="119" ssid = "74">Thus, none of tile ctiicient unification algorithms developed re, ce, ntly obtains the correct results R)r such a case.</S>
			<S sid ="120" ssid = "75">Avoiding such wrong unification results requires undesirable copying.</S>
			<S sid ="121" ssid = "76">We can, for example, avoid getting the wrong result by interleaving tile application of any non-DSS unilication algorithm between N)plications of a I)SS unitication algorithm, but such bypassing requires two unilication programs and reduces the efficiency gain of I)SS unification.</S>
			<S sid ="122" ssid = "77">This prechlsion of useful data-structure sharing is referred to here as the &apos;structur~ sharing&quot; problem.</S>
			<S sid ="123" ssid = "78">It has been shown that all the/)SS mfiticat.ion nlgo rithins lncntioned above are subject to tMs problem even if the structure sharing assumption holds initially.</S>
			<S sid ="124" ssid = "79">Non-I)SS unification Mgorithms are also subject to the problem because their inputs are created 1)y applying not only the unitication operation but also operations such as embedding and extraction, in most implelnentations of which data-structure shar.</S>
			<S sid ="125" ssid = "80">hag occurs t)etween their input and output structures.</S>
			<S sid ="126" ssid = "81">1!3ven non-l)SS unification algorithms must there, fore take such inputs into act(mat, and this requires undesirable copying.</S>
	</SECTION>
	<SECTION title="A SOLUTION &apos;1&apos;O THE STRUCTURE SHARING PROBLEM " number = "4">
			<S sid ="127" ssid = "1">4.1 Key Ideas.</S>
			<S sid ="128" ssid = "2">The example ill Section 3 suggests that the structlu&apos;e sharing l)roblem has two sources, which concern not only the increnmntal Col)ying al)proach but also other al)proaches.</S>
			<S sid ="129" ssid = "3">The tirst source is the way of rec, ording ul)date inibrmation.</S>
			<S sid ="130" ssid = "4">In the incremental Col)ying at)- proach, this corresponds to the way of copying structures.</S>
			<S sid ="131" ssid = "5">That is, while calculating t l A t t, 2 the incr(:men tal copying process does not (lisl, inguish between the copies cremated tuq tim sul&gt;strucl;ures of the left input l t and the copies created as tile substructures of the right input t2.</S>
			<S sid ="132" ssid = "6">As a result, a copy node oft1 &apos;s node at f~ature-address p can be used as a copy node of t~&apos;s nod(&apos;, at a feature-address, and vice versa.</S>
			<S sid ="133" ssid = "7">In Fig.</S>
			<S sid ="134" ssid = "8">4(10, fbr example, tile copy of t2&apos;s node al; f2 is wrongly used as the copy of tl&apos;s node at fl.</S>
			<S sid ="135" ssid = "9">This causes unexpected and wrong data-structure sharing in the r(~sultant graph and this in turn catlses unexpect(~d and wrong feature-structure sharing in the resultant (typed) fc~t, ure s&apos;[,rllcttlro.</S>
			<S sid ="136" ssid = "10">Ill other apl)roachcs , such as the quasi-destructiw~ apl/roach , the source of the structure sharing prol)lem is that each node structure has tMds for keeping information on only two typed feature structures one for the original and one R)r tilt: result wheretm fields for keeping information on three typed feature structures are needed one for tl&gt; original and one for each of the two results, One way to solve this problem is therel&apos;ore to nlake each node keep information on thre, c typed fe, ttturc structures: in the increnrental COl)ying apl)roach ca(;h nod(: must have two copy tields, and in the quasi-do, structive ;t[)t)roach each llode l)lUSt have two sets of llelds for updates.</S>
			<S sid ="137" ssid = "11">&apos;Fhe second source of the structure sharing prob lem is the method of data-stru(:ture sharing between input and output structures.</S>
			<S sid ="138" ssid = "12">Unexpected and wrong data-structure sh~ring may result if a node shared by the leg and right inputs is used as part of the left input, intended to be shared between the left input and output, at the same time it is used as part of the right input, intended to be shared between the right input Fig.</S>
			<S sid ="139" ssid = "13">5: The node structure lbr the revised nondestructive unitication.</S>
			<S sid ="140" ssid = "14">node structure tsymbol (a type symbol} arcs (a set of arc structures) generation {an integer) forward NIL [(a ,,ode structure) lcopy NIL [ (a node structure) rcopy NIL[ {a node structure) and output.</S>
			<S sid ="141" ssid = "15">In Fig.</S>
			<S sid ="142" ssid = "16">4(b), for example, tl&apos;s node at feature-address f~ is shared as t3&apos;s node at the same feature-address, and the same node as t2&apos;s node at f4 is shared as ta&apos;s node at the same feature-address.</S>
			<S sid ="143" ssid = "17">This problem can be solved easily by keeping information on data-structure sharing status; that is, by adding to the node structure a new field for this purpose and using it thus: when a unification algorithm makes a node shared (for example, between the left inpnt and output), it records this information on the node; later when tilt algorithm attempts to make the node shared, it does this only if this data-structure sharing is between the left input and output.</S>
			<S sid ="144" ssid = "18">4.2 Algorithms.</S>
			<S sid ="145" ssid = "19">This section first describes a non-DSS unification algorithm that discards the structure sharing assumption and thus permits initial data-structure sharing, and then it describes two DSS unification algorithms.</S>
			<S sid ="146" ssid = "20">Revised Nondestructive Unifi(:ation This Mgorithm uses, instead of the node structure shown in Fig.</S>
			<S sid ="147" ssid = "21">3, the node structure in Fig.</S>
			<S sid ="148" ssid = "22">5.</S>
			<S sid ="149" ssid = "23">That is, the algorithm uses two kinds of copy links: Icopy for the left input and rcopy for the right input.</S>
			<S sid ="150" ssid = "24">Tilt revised nondestructive unification procedure for typed feature structures is shown in Figs.</S>
			<S sid ="151" ssid = "25">6 and 7.</S>
			<S sid ="152" ssid = "26">Given two root nodes of directed graphs, the top-level procedure Unify assigns a new unification process identifier, generation, and invokes Unify_Aux.</S>
			<S sid ="153" ssid = "27">This procedure first dereferences both input nodes.</S>
			<S sid ="154" ssid = "28">This dereference process differs from the original one in that it follows up fortvard and lcopy links for the left input node and forward and rcopy links for the right input node.</S>
			<S sid ="155" ssid = "29">This revised dereference process eliminates the first source of the structure-sharing problena.</S>
			<S sid ="156" ssid = "30">Then Unify_A*tx calculates the meet of the type symbol.</S>
			<S sid ="157" ssid = "31">If the meet is ±, which means inconsistency, it finishes by returning _L Otherwise Unify_Auz obtains tilt output node and sets the meet as its tsymbol value.</S>
			<S sid ="158" ssid = "32">The output node is created only when neither input nodt is current; otherwise the output node is a current input node.</S>
			<S sid ="159" ssid = "33">Then Un*fy_Aux treats arcs.</S>
			<S sid ="160" ssid = "34">This procedure assmnes the existence of two procedures: Share&amp;Arc_Pair,s and Complement_Arcs.</S>
			<S sid ="161" ssid = "35">The former gives two lists of arcs each of which contains ares whose labels exist in both input nodes with the same are label order; the latter gives one list of arcs whose labels are unique to the first input node.</S>
			<S sid ="162" ssid = "36">For each arc pair obtained by Shared_A re_Pairs, Unify_A ux applies itself recursively to the value pair.</S>
			<S sid ="163" ssid = "37">And for each arc obtained by Complement_Ares, it copies its value.</S>
			<S sid ="164" ssid = "38">Let us compare the newly introduced cost and the PROCEDURE Unify(nodcl, node2) generation *-- generation + 1 ; return( Un@_A ux( node l , node2)) ENDPROCEDURE PROCEDURE I/n(fy_Aux(nodel, node2) node1 +-- Dereference_L(nodel); node2 +-- Dereference_R( node2 ) ; IF node1 = node2 AND Currcnt_p(nodel) THEN return(node l) ENDIF newtsymbol ~-nodel.tsymbol A7 node2.tsymbol; IF newtsymbol = ± THEN return(±) ENDIF; newnode ~-- Get_Out_Node(node1, node2, newtaymbol); ( sares l , ,,&apos;cs2} ~ ,~&apos;hared_A rc_Pai,&apos;s( node l , node2); caresl ~ Complement_Arcs(nodel, node2); cares2 *-Complement_Arcs(node2, node1); FOR (sarel,sarc2) IN (saresl,sarcs2} DO newvaluc ~-Unifg_Aux(sarcl, value, sarc2,value); IF ncwvalue-k THEN return(±) ELSE new~)al~te *-- Add_Arc(newnode, sarcl.label, newvalue); IF newvalue = ± THEN return(A_) ENDIF ENDIF ENDFOR; IF newnode # node l THEN FOR care IN carcst DO newvalue *-Copy_Node_L( carc.vah~e ); newnode ~-Add_Arc( ncwnodc, care.label, newvaluc) ENDFOR ELSE IF ncwnode ¢ node2 THEN FOR carc IN carcs2 DO newvahte +-- Copy_Nodc_l~(care.value); newnode Add_Arc( newnode, care.label, newvalue) ENDFOR ENDIF; rcturn(ncwnodc) ENDPROCEDURE PROCEDURE Dereference_L( node) IF Node_p(node.forward) THEN return(1)ereference_L( node.forward) ) ELSE IF Curret_Nade_p(node.lcopv ) &quot;/[&apos;HEN return( Dereferenec_L( node.lcopy) ) ELSE return(node) ENDIF ENDPROCEDURE Fig.</S>
			<S sid ="165" ssid = "39">6: The revised nondestructive unification procedure (1).</S>
			<S sid ="166" ssid = "40">effect of this revision.</S>
			<S sid ="167" ssid = "41">This revised version differs from the original in thai, it uses two dereference procedures that are tile same as tim original dereference procedure except that they use different fields.</S>
			<S sid ="168" ssid = "42">Thus, on the one hand, the overhead introduced to this revision is only the use of one additional field of the node structure.</S>
			<S sid ="169" ssid = "43">On the other hand, although this revised version does not introduce new data-structure sharing, it can safely&apos; treat data-structure sharing in ini- PROCEDURE (;ct_Out_Node( node l , node&amp; tsymbol) IF Current_p(nodel)AND Current_p(node2) THEN nodc2.forward +-- nodel; nodel.tsyrnbol ~-tsymbol; return( nodc [ ) ELSE IF Current_p(nodel) THEN node2.rcopy ~ nodeI ; node l, tsymbol ~-tsymbol; return( node l ) ELSE IF Current_p(node2) THEN nodel.h:opy ~-nodc2; node2.tsymbol ~-- tsymbol; return(node2) ELSE newnode ~-Creutc_NodeO; nodel.lcopy ~-newnode; nodel.rcopy ~ newnnde; newnode.tsymbol ~-tsgmbol; return( newnode ) ENDIF ENDPROCEDUR.E Fig.</S>
			<S sid ="170" ssid = "44">7: The revised nondestructiw&apos;, unification procedure (2), tial data structures.</S>
			<S sid ="171" ssid = "45">This can significantly reduce the amount of initial data structures required for linguistic descriptions, especiMly for lexical descriptions, and thus reduce garbage-collection and page-sw~q)ping.</S>
			<S sid ="172" ssid = "46">Revised LING Unification L[N(I uniliet~tion is based on nondestructive unification and uses copy-dependency information to implement data-structure sharing.</S>
			<S sid ="173" ssid = "47">For a unique label arc, instead of its vMue being copied, the value itself is used as the output vMuc and copy-dependency relations are recorded to provide R)r later modification of shared structures.</S>
			<S sid ="174" ssid = "48">This algorithm uses a revised Copy~Node procedure that takes as its input two node structures (nodel and node2) and one arc structure, arc 1 where node.l is the node to be COl)ied.</S>
			<S sid ="175" ssid = "49">The structure arel is an arc to node J, and node t is an ancestor node of node.l -that is, the node fi&apos;om which arel departs and the revised procedure is as follows: (i) if nodel&apos; (the dereference result of node.t) is current, then Copy_Node returns nodel&apos; to indicate that l, he ancestor node2 must be copied imme-.</S>
			<S sid ="176" ssid = "50">diately; otherwise, (ii) Copy_Arcs is applied to node l&apos; and if it returns several arc copies, Copy_Node creates a new copy node and then adds to the new node the arc copies and arcs of node[&apos; that are not copied, and returns the ne.w node to indicate the an-eestor node having to be coiffed immediately; otherwise, (iii) Copy_Node registors the copy-dependency between the nodel&apos; and the ancestor node node2 that is, it adds the pair consisting of the ancestor node node2 a.nd the arc arc I into the copy field of node 1 &apos;- and returns Nil, to indicate that the ancestor must not be copied immediatelyfi When a new copy of a node is needed later, this algorithm will copy struceIn tile ],IN(-; unlfica.iton Mgorithm, ~t node structure&apos;s copy field is used to keep either copy iuform~ttion or copy- dependency inform~ttion.</S>
			<S sid ="177" ssid = "51">When tile&apos;, field keeps copy- dependency inform;ttion, its v~hle is a copydep structure consisting of an integer generation field- and a set of PROCEDURE Copy_Node_L(node, arc, ancestor) node ~-Derference_L( node); IF Current_p(node) THEN return( node); ELSE IF node.reuse: -&quot; rused THEN return( Simple_ Copy_Node_L( nodc ) ) ENDIF newarcs ~-Copy_A rcs_L( node); IF newarcs 5£ 0 THEN newnodc ~-Create_No&amp;O; uewnode.tsymbol ~ node.tsymbol; node.lcopy ~-- newnode; FOIl.</S>
			<S sid ="178" ssid = "52">arc IN nodc.arcs DO newarc *-- Find_Are( arc.labcl, newarcs); IF Arc_p(newarc) THEN newvalne ~-A dd_A rc( newnodc, arc.label, n eware, vahte ) ELSE newv(thte ~-A dd_Arc( ncwnode, arc.lab(l, are.value) ENDIF ENDFOR; return( newnode) ELSE IF Copydep_p(node.leopy)AND node.lcopy.generation = generation THEN n ode.</S>
			<S sid ="179" ssid = "53">Icopy.</S>
			<S sid ="180" ssid = "54">deps ~-nod~2eopv.deps u {((,neestor, .r4}; node,rettsc ~--ltlsed; return(NIL) ELSE copydcp ~ Create_CopydePO; copydcp.gcneration ~ gcneration; ,&apos;.opydep.d,,ps ,-- ((rLncesto,&apos;, are)}; node.leopy ,-.</S>
			<S sid ="181" ssid = "55">eopydep; node.</S>
			<S sid ="182" ssid = "56">reuse ~-lused; return(NIL) ENDIF ENDPROCEDUI1,E PROCEDURE Copy_Ares_L(node) newarcs ~-0; FOR arc IN node.arcs DO newnode ~-Copg_Nodc( arc. v(due, are, node); IF Nodc_p(newnode) THEN newarc ~ Create_Are(arc.label, newnode ); newarcs +-- newarcs U {newarc} ENDIF ENDFOR; ENDPROCEDUR,E Fig.</S>
			<S sid ="183" ssid = "57">8: The new revised Copy_Node procedure.</S>
			<S sid ="184" ssid = "58">tures by using the copy-depe,ldency information in its copy field (in the revised Get_Out_Node procedure for the 13NG unification).</S>
			<S sid ="185" ssid = "59">It substitutes arcs with newly copied nodes for existing arcs.</S>
			<S sid ="186" ssid = "60">Thus the antecedent nodes are also copied.</S>
			<S sid ="187" ssid = "61">The revised L[NCI unification is based on the revised nondestructive unification and uses a node structure consisting of the fields in the node structure shown in Fig.</S>
			<S sid ="188" ssid = "62">5 and a new field reuse [br indicat node and arc pMrsdeps field (see Fig.</S>
			<S sid ="189" ssid = "63">3).</S>
			<S sid ="190" ssid = "64">The technique used to control tile lifetime of copy-dependency information is tile same as tha.t of copy information.</S>
			<S sid ="191" ssid = "65">That is, the deps field value is meaningN1 only when the generation vadne is equM to the unification process identifier.</S>
			<S sid ="192" ssid = "66">ing data-structure sharing status.</S>
			<S sid ="193" ssid = "67">When the top-level unification procedure is invoked, it sets two new symbols to the two variables lused and fused.</S>
			<S sid ="194" ssid = "68">That a node structure has as its reuse field value the lused value means that it is used as part of the left input, and that it has as its reuse value the rused value means that it is used as part of the right input,.</S>
			<S sid ="195" ssid = "69">The revised LING unification uses two new revised Copy_Node procedures, Copy_Node_L (shown in Fig.</S>
			<S sid ="196" ssid = "70">8) and the analogons preocedure Copy_Node_It These procedures are respectively used to treat the left and right inputs and they differ from the corresponding original procedure in two places.</S>
			<S sid ="197" ssid = "71">First, instead of step (i) above, if ~odel&apos; (the dereference result of no&amp;l) is current, Cop?l_Node_l, (or Copy_Node_R) returns 7~ode l&apos; to indicate that tire ancestor, node2, must be copied immediately.</S>
			<S sid ="198" ssid = "72">But if node1&apos; has as its reuse field value the fused (or lused) value, it creates a copy of the whole subgraph whose root is nodel&apos;and returns the eopied structure also to indica~,c that the ancestor node must be copied immediately.</S>
			<S sid ="199" ssid = "73">Second, in step (iii), they register data-structure sharing status that is, they set the lused (or fused) value to the reuse field of node l&quot; as well as register copy-dependency information.</S>
			<S sid ="200" ssid = "74">This revised LING unification ensures safety in data-structure sharing.</S>
			<S sid ="201" ssid = "75">Again let us compare the newly introduced conrputational costs and the effect of l, his revision.</S>
			<S sid ="202" ssid = "76">The newly introduced costs are the additional cost of the revised dereference procedures (which is the same as in the previous one) and the cost of checking reuse status.</S>
			<S sid ="203" ssid = "77">The former cost is small, as shown in the discussion of the previous algorithm, ~nd the latter cost is also small.</S>
			<S sid ="204" ssid = "78">These costs are thus not significant relative to the efficiency gain obtained by this revision.</S>
			<S sid ="205" ssid = "79">Revised Quasi-Destructive Unification The strncturesharillg version of quasi-destructive unification keeps update information in the field meaningful only during l, he unification.</S>
			<S sid ="206" ssid = "80">After a suceessful unification is obtained, this algorithm copies the unification result and attempts data-structure sharing.</S>
			<S sid ="207" ssid = "81">This algorithm can be revised to ensure safety in dal, a-structurc sharing hy using a node structure including two sets of fields for update information and one reuse field and by checking node reuse status while eopying.</S>
			<S sid ="208" ssid = "82">CONCLUSION The graph unification algorithms described ira this paper increase the efIiciency of feature structure unification by discarding tile assumption that data-structure sharing between two input structures nccurs only when the t~ature-structure sharing occurs lyetween the feature-addresses they represent.</S>
			<S sid ="209" ssid = "83">All graph unification algorithms proposed so far make this assumption and are therefore required to copy all or part of their input strucl, ures when there is a possibility of violating it.</S>
			<S sid ="210" ssid = "84">&apos;[&apos;his copying reduces their etIiciency.</S>
			<S sid ="211" ssid = "85">This pape.r analyzed this problem and points out key ideas for solving it.</S>
			<S sid ="212" ssid = "86">Revised procedures tbr nondestructive unification, LING unification, and quasi-destructive unification have been developed.</S>
			<S sid ="213" ssid = "87">These algorithms make the use of feature structures in constraint-based natural language processing mnch more elficient.</S>
			<S sid ="214" ssid = "88">The key ideas in this paper can also be used to make the incremental graph generalization algorithm (Kogure, 1993) more efficient,</S>
	</SECTION>
	<SECTION title="ACKNOWLEDGMENTS">
			<S sid ="215" ssid = "89">1 thank Akira Shimazu, Mikio Nakmto, and other colleagues in the Dialogue Understanding Group at the NTT Basic Research Laboratories for their encouragement and thought-prow)king discussions.</S>
	</SECTION>
</PAPER>
