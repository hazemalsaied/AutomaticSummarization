<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">This article presents a pragmatic approach to Chinese word segmentation.</S>
		<S sid ="2" ssid = "2">It differs from most previous approaches mainly in three respects.</S>
		<S sid ="3" ssid = "3">First, while theoretical linguists have defined Chinese words using various linguistic criteria, Chinese words in this study are defined pragmatically as segmentation units whose definition depends on how they are used and processed in realistic computer applications.</S>
		<S sid ="4" ssid = "4">Second, we propose a pragmatic mathematical framework in which segmenting known words and detecting unknown words of different types (i.e., morpho- logically derived words, factoids, named entities, and other unlisted words) can be performed simultaneously in a unified way.</S>
		<S sid ="5" ssid = "5">These tasks are usually conducted separately in other systems.</S>
		<S sid ="6" ssid = "6">Finally, we do not assume the existence of a universal word segmentation standard that is application-independent.</S>
		<S sid ="7" ssid = "7">Instead, we argue for the necessity of multiple segmentation standards due to the pragmatic fact that different natural language processing applications might require different granularities of Chinese words.</S>
		<S sid ="8" ssid = "8">These pragmatic approaches have been implemented in an adaptive Chinese word segmenter, called MSRSeg, which will be described in detail.</S>
		<S sid ="9" ssid = "9">It consists of two components: (1) a generic segmenter that is based on the framework of linear mixture models and provides a unified approach to the five fundamental features of word-level Chinese language processing: lexicon word processing, morphological analysis, factoid detection, named entity recognition, and new word identification; and (2) a set of output adaptors for adapting the output of (1) to different application-specific standards.</S>
		<S sid ="10" ssid = "10">Evaluation on five test sets with different standards shows that the adaptive system achieves state-of-the-art performance on all the test sets.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="11" ssid = "11">This article is intended to address, with a unified and pragmatic approach, two fundamental questions in Chinese natural language processing (NLP): What is a ‘word’ in Chinese?, and How does a computer identify Chinese words automatically?</S>
			<S sid ="12" ssid = "12">Our approach is distinguished from most previous approaches by the following three unique ∗ Natural Language Computing Group, Microsoft Research Asia, 5F, Sigma Center, No. 49, Zhichun Road, Beijing, 100080, China.</S>
			<S sid ="13" ssid = "13">Email: jfgao@microsoft.com, muli@microsoft.com, cnhuang@msrchina.research.</S>
			<S sid ="14" ssid = "14">microsoft.com.</S>
			<S sid ="15" ssid = "15">+ The work reported in this article was done while the author was at Microsoft Research.</S>
			<S sid ="16" ssid = "16">His current email address is andi.wu@grapecity.com.</S>
			<S sid ="17" ssid = "17">Submission received: 22 November 2004; revised submission received: 20 April 2005; accepted for publication: 17 June 2005.</S>
			<S sid ="18" ssid = "18">© 2006 Association for Computational Linguistics components that are integrated into a single model: a taxonomy of Chinese words, a unified approach to word breaking and unknown word detection, and a customizable display of word segmentation.1 We will describe each of these in turn.</S>
			<S sid ="19" ssid = "19">Chinese word segmentation is challenging because it is often difficult to define what constitutes a word in Chinese.</S>
			<S sid ="20" ssid = "20">Theoretical linguists have tried to define Chinese words using various linguistic criteria (e.g., Packard 2000).</S>
			<S sid ="21" ssid = "21">While each of those criteria provides valuable insights into “word-hood” in Chinese, they do not consistently lead us to the same conclusions.</S>
			<S sid ="22" ssid = "22">Fortunately, this may not be a serious issue in computational linguistics, where the definition of words can vary and can depend to a large degree upon how one uses and processes these words in computer applications (Sproat and Shih 2002).</S>
			<S sid ="23" ssid = "23">In this article, we define the concept of Chinese words from the viewpoint of computational linguistics.</S>
			<S sid ="24" ssid = "24">We develop a taxonomy in which Chinese words can be categorized into one of the following five types: lexicon words, morphologically derived words, factoids, named entities, and new words.2 These five types of words have different computational properties and are processed in different ways in our system, as will be described in detail in Section 3.</S>
			<S sid ="25" ssid = "25">Two of these five types, factoids and named entities, are not important to theoretical linguists but are significant in NLP.</S>
			<S sid ="26" ssid = "26">Chinese word segmentation involves mainly two research issues: word boundary disambiguation and unknown word identification.</S>
			<S sid ="27" ssid = "27">In most of the current systems, these are considered to be two separate tasks and are dealt with using different components in a cascaded or consecutive manner.</S>
			<S sid ="28" ssid = "28">However, we believe that these two issues are not separate in nature and are better approached simultaneously.</S>
			<S sid ="29" ssid = "29">In this article, we present a unified approach to the five fundamental features of word-level Chinese NLP (corresponding to the five types of words described earlier): (1) word breaking, (2) morphological analysis, (3) factoid detection, (4) named entity recognition (NER), and (5) new word identification (NWI).</S>
			<S sid ="30" ssid = "30">This approach is based on a mathematical framework of linear mixture models in which component models are inspired by the source–channel models of Chinese sentence generation.</S>
			<S sid ="31" ssid = "31">There are basically two types of component models: a source model and a set of channel models.</S>
			<S sid ="32" ssid = "32">The source model is used to estimate the generative probability of a word sequence in which each word belongs to one word type.</S>
			<S sid ="33" ssid = "33">For each of the word types, a channel model is used to estimate the likelihood of a character string, given the word type.</S>
			<S sid ="34" ssid = "34">We shall show that this framework is flexible enough to incorporate a wide variety of linguistic knowledge and statistical models in a unified way.</S>
			<S sid ="35" ssid = "35">In computer applications, we are more concerned with segmentation units than words.</S>
			<S sid ="36" ssid = "36">While words are supposed to be unambiguous and static linguistic entities, segmentation units are expected to vary from application to application.</S>
			<S sid ="37" ssid = "37">In fact, different Chinese NLP-enabled applications may have different requirements that request different granularities of word segmentation.</S>
			<S sid ="38" ssid = "38">For example, automatic speech recognition (ASR) systems prefer longer “words” to achieve higher accuracy, whereas in 1 In this article, we differentiate the terms word breaking and word segmentation.</S>
			<S sid ="39" ssid = "39">Word breaking refers.</S>
			<S sid ="40" ssid = "40">to the process of segmenting known words that are predefined in a lexicon.</S>
			<S sid ="41" ssid = "41">Word segmentation refers to the process of both lexicon word segmentation and unknown word detection.</S>
			<S sid ="42" ssid = "42">2 New words in this article refer to out-of-vocabulary words that are neither recognized as named entities.</S>
			<S sid ="43" ssid = "43">or factoids nor derived by morphological rules.</S>
			<S sid ="44" ssid = "44">These words are mostly domain-specific and/or time-sensitive (see Section 5.5 for details).</S>
			<S sid ="45" ssid = "45">532 formation retrieval (IR) systems prefer shorter “words” to obtain higher recall rates (Wu 2003).</S>
			<S sid ="46" ssid = "46">Therefore, we do not assume that an application-independent universal word segmentation standard exists.</S>
			<S sid ="47" ssid = "47">We argue instead for the existence of multiple segmentation standards, each for a specific application.</S>
			<S sid ="48" ssid = "48">It is undesirable to develop a set of application-specific segmenters.</S>
			<S sid ="49" ssid = "49">A better solution would be to develop a generic segmenter with customizable output that is able to provide alternative segmentation units according to the specification that is either predefined or implied in the application data.</S>
			<S sid ="50" ssid = "50">To achieve this, we present a transformation-based learning (TBL; Brill 1995) method, to be described in Section 6.</S>
			<S sid ="51" ssid = "51">We implement the pragmatic approach to Chinese word segmentation in an adaptive Chinese word segmenter called MSRSeg.</S>
			<S sid ="52" ssid = "52">It consists of two components: (1) a generic segmenter that is based on the linear mixture model framework of word breaking and unknown word detection and that can adapt to domain-specific vocabularies, and (2) a set of output adaptors for adapting the output of (1) to different application-specific standards.</S>
			<S sid ="53" ssid = "53">Evaluation on five test sets with different standards shows that the adaptive system achieves state-of-the-art performance on all the test sets.</S>
			<S sid ="54" ssid = "54">It thus demonstrates the possibility of a single adaptive Chinese word segmenter that is capable of supporting multiple applications.</S>
			<S sid ="55" ssid = "55">The remainder of this article is organized as follows.</S>
			<S sid ="56" ssid = "56">Section 2 presents previous work in this field.</S>
			<S sid ="57" ssid = "57">Section 3 introduces the taxonomy of Chinese words and describes the corpora we used in our study.</S>
			<S sid ="58" ssid = "58">Section 4 presents some of the theoretical background on which our unified approach is based.</S>
			<S sid ="59" ssid = "59">Section 5 outlines the general architecture of the Chinese word segmenter, MSRSeg, and describes each of the components in detail, presenting a separate evaluation of each component where appropriate.</S>
			<S sid ="60" ssid = "60">Section 6 presents the TBL method of standards adaptation.</S>
			<S sid ="61" ssid = "61">While in Section 5 we presume the existence of an annotated training corpus, we focus in Section 7 on the methods of creating training data in a (semi-)automatic manner, with minimal or no human annotation.</S>
			<S sid ="62" ssid = "62">We thus demonstrate the possibilities of unsupervised learning of Chinese words.</S>
			<S sid ="63" ssid = "63">Section 8 presents several evaluations of the system on the different corpora, each corresponding to a different segmentation standard, in comparison with other state-of-the-art systems.</S>
			<S sid ="64" ssid = "64">Finally, we conclude the article in Section 9.</S>
	</SECTION>
	<SECTION title="Previous  Work. " number = "2">
			<S sid ="65" ssid = "1">2.1 Approaches to Word Segmentation.</S>
			<S sid ="66" ssid = "2">Many methods of Chinese word segmentation have been proposed: reviews include Wu and Tseng (1993); Sproat and Shih (2002); and Sun and Tsou (2001).</S>
			<S sid ="67" ssid = "3">These methods can be roughly classified as either dictionary-based or statistically-based methods, while many state-of-the-art systems use hybrid approaches.</S>
			<S sid ="68" ssid = "4">In dictionary-based methods, given an input character string, only words that are stored in the dictionary can be identified.</S>
			<S sid ="69" ssid = "5">One of the most popular methods is maximum matching (MM), usually augmented with heuristics to deal with ambiguities in segmentation.</S>
			<S sid ="70" ssid = "6">Studies that use this method or minor variants include Chen et al.</S>
			<S sid ="71" ssid = "7">(1999) and Nie, Jin, and Hannan (1994).</S>
			<S sid ="72" ssid = "8">The performance of these methods thus depends to a large degree upon the coverage of the dictionary, which unfortunately may never be complete because new words appear constantly.</S>
			<S sid ="73" ssid = "9">Therefore, in addition to the dictionary, many systems also contain special components for unknown word identification.</S>
			<S sid ="74" ssid = "10">533 In particular, statistical methods have been widely applied because they use a probabilistic or cost-based scoring mechanism rather than a dictionary to segment the text.</S>
			<S sid ="75" ssid = "11">These methods have three drawbacks.</S>
			<S sid ="76" ssid = "12">First, some of these methods (e.g., Lin et al. 1993; Chang and Su 1997) identify OOV (out-of-vocabulary) words without identifying their types.</S>
			<S sid ="77" ssid = "13">For instance, one might identify a string as a unit but fail to identify that it is a person name.</S>
			<S sid ="78" ssid = "14">Second, many current statistical methods do not incorporate linguistic knowledge effectively into segmentation.</S>
			<S sid ="79" ssid = "15">For example, Teahan et al.</S>
			<S sid ="80" ssid = "16">(2000) and Dai et al.</S>
			<S sid ="81" ssid = "17">(1999) do not use any linguistic knowledge.</S>
			<S sid ="82" ssid = "18">Thus, the identified OOV words are likely to be linguistically implausible, and consequently, additional manual checking is needed for some subsequent tasks such as parsing.</S>
			<S sid ="83" ssid = "19">Third, in many current segmenters, OOV identification is considered a separate process from segmentation (e.g., Chen 2003; Wu and Jiang 2000; Chen and Bai 1998).</S>
			<S sid ="84" ssid = "20">For instance, Chen (2003) assumes that OOV words are usually two or more characters long and are often segmented into single characters.</S>
			<S sid ="85" ssid = "21">He then uses different components to detect OOV words of different types in a cascaded manner after the basic word segmentation.</S>
			<S sid ="86" ssid = "22">We believe that the identification of OOV words should not be treated as a problem separate from word segmentation.</S>
			<S sid ="87" ssid = "23">We propose a unified approach that solves both problems simultaneously.</S>
			<S sid ="88" ssid = "24">A previous work along this line is Sproat et al.</S>
			<S sid ="89" ssid = "25">(1996), which is based on weighted finite-state transducers (FSTs).</S>
			<S sid ="90" ssid = "26">Our approach is similarly motivated but is based on a different mechanism: linear mixture models.</S>
			<S sid ="91" ssid = "27">As we shall see, the models provide a more flexible framework for incorporating various kinds of lexical and statistical information.</S>
			<S sid ="92" ssid = "28">Many types of OOV words that are not covered in Sproat’s system can be dealt with in our system.</S>
			<S sid ="93" ssid = "29">The linear models we used are originally derived from linear discriminant functions widely used for pattern classification (Duda, Hart, and Stork 2001) and have been recently introduced into NLP tasks by Collins and Duffy (2001).</S>
			<S sid ="94" ssid = "30">Other frameworks of Chinese word segmentation, which are similar to the linear models, include maximum entropy models (Xue 2003) and conditional random fields (Peng, Feng, and McCallum 2004).</S>
			<S sid ="95" ssid = "31">They also use a unified approach to word breaking and OOV identification.</S>
			<S sid ="96" ssid = "32">2.2 More on New Word Identification.</S>
			<S sid ="97" ssid = "33">In this article, we use the term “new words” to refer to OOV words other than named entities, factoids, and morphologically derived words.</S>
			<S sid ="98" ssid = "34">“New words” are mostly domain- specific terms (e.g., * � J:t ‘cellular ’) and time-sensitive political, social, or cultural terms (e.g., .i1 ‘Three Links’; FJ,I ‘SARS’).</S>
			<S sid ="99" ssid = "35">There have been two general approaches to NWI.</S>
			<S sid ="100" ssid = "36">The first is to acquire new words from large corpora off-line and put them into a dictionary before word segmentation starts (e.g., Fung and Wu 1994; Nie, Jin and Hannan 1994; Chien 1997; Gao et al. 2002).</S>
			<S sid ="101" ssid = "37">The other is to detect new words online, i.e., to spot new words in a sentence on the fly during the process of word segmentation (e.g., Chen 2003; Wu and Jiang 2000).</S>
			<S sid ="102" ssid = "38">These two approaches complement one another, and we use both of them in our system.</S>
			<S sid ="103" ssid = "39">There have been quite a few methods proposed for the off-line approach in which the basic assumption is that a Chinese word should appear as a stable sequence in the corpus.</S>
			<S sid ="104" ssid = "40">These methods use metrics that are based on statistical features such as mutual information, term frequency, and their variants.</S>
			<S sid ="105" ssid = "41">They require a reasonably large training corpus.</S>
			<S sid ="106" ssid = "42">The new words detected are mostly proper nouns and other relatively frequent words.</S>
			<S sid ="107" ssid = "43">Unfortunately, new words, under our definition of the term, may not be detected.</S>
			<S sid ="108" ssid = "44">534 Fewer methods have been proposed for an online approach, and that is the focus of this article.</S>
			<S sid ="109" ssid = "45">Some recent advances in online NWI explore the use of machine learning approaches.</S>
			<S sid ="110" ssid = "46">For example, Li et al.</S>
			<S sid ="111" ssid = "47">(2003) define NWI as a binary classification problem and use support vector machines (SVM) to combine various linguistically motivated features to determine whether a Chinese character sequence is a word.</S>
			<S sid ="112" ssid = "48">Our method is an extension of that of Li et al. in that NWI is not a stand-alone process in our system but an integral part of word segmentation.</S>
			<S sid ="113" ssid = "49">We shall show experimentally the benefit of the integration in Section 5.5.</S>
			<S sid ="114" ssid = "50">2.3 Standards Adaptation.</S>
			<S sid ="115" ssid = "51">As described earlier, while Chinese words are supposed to be well-defined, unambiguous, and static linguistic entities, we are more concerned with segmentation units that are expected to vary among different computer applications.</S>
			<S sid ="116" ssid = "52">This inspires the development of an adaptive Chinese word segmenter.</S>
			<S sid ="117" ssid = "53">However, most of the previous segmenters have been developed according to a standard that assumes a single correct segmentation.</S>
			<S sid ="118" ssid = "54">The only adaptive system, to the best of our knowledge, is the customizable segmenter described in Wu (2003), in which the display of the segmentation output can be customized by users.3 The adaptation method we will describe in Section 6 can be viewed as an improved version in that the adaptation rules (or transformations) are acquired automatically from application data via the TBL method (Gao et al. 2004).</S>
			<S sid ="119" ssid = "55">Though the use of TBL for Chinese word segmentation is not new (see Palmer [1997]; Hockenmaier and Brew [1998]), none of the previous work is aimed at standards adaptation.</S>
			<S sid ="120" ssid = "56">2.4 Evaluation.</S>
			<S sid ="121" ssid = "57">The performance of Chinese word segmenters is generally reported in terms of precision and recall.</S>
			<S sid ="122" ssid = "58">However, a comparison across systems could be very difficult for two reasons.</S>
			<S sid ="123" ssid = "59">First, the “correct” segmentation is not clearly defined.</S>
			<S sid ="124" ssid = "60">It is common that for a given sentence there are multiple plausible word segmentations.</S>
			<S sid ="125" ssid = "61">As shown in Sproat et al.</S>
			<S sid ="126" ssid = "62">(1996), the rate of agreement between two human judges is less than 80%.</S>
			<S sid ="127" ssid = "63">To deal with this problem, Fung and Wu (1994) suggest a procedure called nk-blind that uses n blind judges’ standards.</S>
			<S sid ="128" ssid = "64">If we set k = 1, it is sufficient for a segmentation to be considered correct if it agrees with at least one of the n judges.</S>
			<S sid ="129" ssid = "65">If k = n, all judges must agree.</S>
			<S sid ="130" ssid = "66">Therefore, nk-blind gives a more representative performance measure by taking into account multiple judges.</S>
			<S sid ="131" ssid = "67">Similarly, Sproat et al.</S>
			<S sid ="132" ssid = "68">(1996) also uses multiple human judges.</S>
			<S sid ="133" ssid = "69">In Section 8.2, we will present our method for cross-system comparison.</S>
			<S sid ="134" ssid = "70">We do not use multiple human judges.</S>
			<S sid ="135" ssid = "71">Instead, we only consider a set of measures that are lexicon-independent and less ambiguous among different human judges and systems.</S>
			<S sid ="136" ssid = "72">The second reason that cross-system comparisons are difficult concerns the use of different test sets and ground rules by many research papers.</S>
			<S sid ="137" ssid = "73">For example, some papers report precision and recall rates of 98% or 99%.</S>
			<S sid ="138" ssid = "74">But they either count only the words that are stored in the dictionary or use unrealistically simple data with a very low OOV rate.</S>
			<S sid ="139" ssid = "75">Recently, the ACLSIGHAN–sponsored First International Chinese Word Segmentation 535 Bakeoff alleviated the situation to some degree (Sproat and Emerson 2003).</S>
			<S sid ="140" ssid = "76">The Bakeoff released four data sets, each corresponding to a different standard, and consistent train–test splits.</S>
			<S sid ="141" ssid = "77">We evaluate our segmenter using those four data sets in Sections 6.2 and 8.3.</S>
	</SECTION>
	<SECTION title="Chinese Words. " number = "3">
			<S sid ="142" ssid = "1">This section defines Chinese words at three levels.</S>
			<S sid ="143" ssid = "2">We begin with a taxonomy by which Chinese words are categorized into five main types according to the way they are processed and used in realistic systems.</S>
			<S sid ="144" ssid = "3">Second, we develop the MSR standard, which is a set of specific rules to guide human annotators in segmenting Chinese sentences.</S>
			<S sid ="145" ssid = "4">Finally, we describe the development of a gold test set and how we evaluate Chinese word segmenters.</S>
			<S sid ="146" ssid = "5">Here, we use the term “gold test set” to refer to the manually annotated corpus, according to the MSR standard, on top of the “test corpus” that is the raw text corpus.</S>
			<S sid ="147" ssid = "6">3.1 Taxonomy.</S>
			<S sid ="148" ssid = "7">The taxonomy of Chinese words is summarized in Table 1, where Chinese words are categorized into the five types: entries in a lexicon (or lexicon words, LWs), morphologically derived words (MDWs), factoids (FTs), named entities (NEs), and new words Table 1 Taxonomy of Chinese words used in developing MSRSeg.</S>
			<S sid ="149" ssid = "8">MDW (see Figure 1 for details) Morphologically Derived Word MP *, MS * Affixation (Prefix, Suffix) MR * Reduplication ML * Splitting MM * Merging MHP * Head+ Particle FT Factoid word , Dat Date 10 11 Dur Duration 20 Tim Time Per Percent and fraction Mon Money 25000 :::7C NUMBER Frequency, integer, decimal, JA., T, 12.2 l, §t; T ordinal, rate, etc. MEASURE Age, weight, length, area, 78 9, 700 0JT,2 0m, 1.8 l capacity, speed, temperature, 0 , 78 l l , 2.89 , angle, etc. 9 ,5 NE Named Entity P Person name , L Location name , 0 O Organization name , NW New Word , 536 (NWs).</S>
			<S sid ="150" ssid = "9">These five types of words have different functions in Chinese NLP and are processed in different ways in our system.</S>
			<S sid ="151" ssid = "10">For example, a plausible word segmentation for the sentence in Figure 1(a) is shown in the same figure.</S>
			<S sid ="152" ssid = "11">Figure 1(b) is the output of our system, where words of different types are processed in different ways: • For LWs, word boundaries are detected, such as �� ‘professor ’.</S>
			<S sid ="153" ssid = "12">• For MDWs, their morphological patterns and stems are detected, e.g., )j:izfl ‘friend+s’ is derived by affixation of the plural affix fl to the noun (stem) )j:iz (MA S indicates a suffixation pattern), and fl=fl=�� ‘happily’ is a reduplication of the stem fl=� ‘happy’ (MR AABB indicates an AABB reduplication pattern).</S>
			<S sid ="154" ssid = "13">• For FTs, their types and normalized forms are detected, e.g., 12:30 is the normalized form of the time expression +-Cf-+JJ (“tim” indicates a time expression).</S>
			<S sid ="155" ssid = "14">• For NEs, their types are detected, e.g., :$�±.</S>
			<S sid ="156" ssid = "15">‘Li Junsheng’ is a person name.</S>
			<S sid ="157" ssid = "16">The five types of words cannot be defined by any consistent classification criteria (e.g., the relation between MDWs and LWs depends on the lexicon being used); the taxonomy therefore does not give a clear definition of Chinese words.</S>
			<S sid ="158" ssid = "17">We do not intend for this article to give a standard definition of Chinese words.</S>
			<S sid ="159" ssid = "18">Instead, we treat Chinese word segmentation as a preprocessing step where the best segmentation units depend on how they are used in the consuming applications.</S>
			<S sid ="160" ssid = "19">The five word types represent the five types of Chinese words that appear in most applications.</S>
			<S sid ="161" ssid = "20">This is one of the reasons that we title this article “a pragmatic approach.” We focus on two tasks in the approach: processing of the five types of Chinese word using a unified framework that can be jointly optimized (Sections 4 and 5), and adapting our system to different applications (Section 6).</S>
			<S sid ="162" ssid = "21">Now, we describe each of the five word types in Table 1 in detail.</S>
			<S sid ="163" ssid = "22">LWs (lexicon words): Although some previous research has suggested carrying out Chinese word segmentation without the use of dictionaries (e.g., Sproat and Shih 1990; Sun, Shen and Tsou 1998), we believe that a dictionary is an essential component of many applications.</S>
			<S sid ="164" ssid = "23">For example, in a machine translation system, it is desirable to segment a sentence into LWs as much as possible so that the candidate translations of these words can be looked up in a bilingual dictionary.</S>
			<S sid ="165" ssid = "24">Similarly, we would also like to segment a sentence into LWs in a Chinese text-to-speech (TTS) system because the pronunciations stored in the dictionary are usually much more precise than those generated dynamically (for instance, by character-to-sound rules).</S>
			<S sid ="166" ssid = "25">In our system, we used a lexicon containing 98,668 words, including 22,996 Chi Figure 1 (a) A Chinese sentence.</S>
			<S sid ="167" ssid = "26">Slashes indicate word boundaries.</S>
			<S sid ="168" ssid = "27">(b) An output of our word segmentation system.</S>
			<S sid ="169" ssid = "28">Square brackets indicate word boundaries.</S>
			<S sid ="170" ssid = "29">+ indicates a morpheme boundary.</S>
			<S sid ="171" ssid = "30">537 nese characters stored as single-character words.</S>
			<S sid ="172" ssid = "31">This lexicon is a combination of several dictionaries authored by Chinese linguists and used in different Microsoft applications.</S>
			<S sid ="173" ssid = "32">Thus, all LWs in theory are similar to those described in Packard (2000), i.e., linguistic units that are “salient and highly relevant to the operation of the language processor.” MDWs (morphologically derived words): Chinese words of this type have the following two characteristics.</S>
			<S sid ="174" ssid = "33">First, MDWs can be generated from one or more LWs (called stems) via a productive morphological process.</S>
			<S sid ="175" ssid = "34">For example, in Figure 2, the MDW fl= fl= � � ‘happily’ is generated from a stem fl= � ‘happy’ via an AABB reduplication process.</S>
			<S sid ="176" ssid = "35">As shown in Table 1, there are five main categories of morphological processes, each of which has several subcategories, as detailed in Figure 2 (see Wu [2003] for a detailed description): • Affixation (MP and MS): )j:izfl (friend - plural) ‘friends’; • Reduplication (MR): fl=� ‘happy’ → fl=fl=�� ‘happily’; • Splitting (MS) (i.e., a set of expressions that are separate words at the syntactic level but single words at the semantic level): z,-JX ‘already ate’, where the bi-character word z,-X ‘eat’ is split by the particle J ‘already’; • Merging (MM): JJI ‘on duty’ + TJI ‘off duty’ → JTJI ‘on-off duty’; and • Head Particle (MHP) (i.e., expressions that are verb + comp): tB� ‘out’ → tB� ‘walk out’.</S>
			<S sid ="177" ssid = "36">‘walk’ + The second characteristic of MDWs is that they form stable Chinese character sequences in the corpus.</S>
			<S sid ="178" ssid = "37">That is, the components within the MDWs are strongly correlated (of high co-occurrence frequency), while the components at both ends have low correlations with words outside the sequence.</S>
			<S sid ="179" ssid = "38">We shall describe in Section 5.2 how the ‘stability’ of a Chinese sequence is measured qualitatively, and how to construct a morph-lexicon for Chinese morphology analysis.</S>
			<S sid ="180" ssid = "39">FTs (factoids): There are ten categories of factoid words, such as time and date expressions, as shown in Table 1.</S>
			<S sid ="181" ssid = "40">All FTs can be represented as regular expressions.</S>
			<S sid ="182" ssid = "41">Therefore, the detection and normalization of FTs can be achieved by Finite State Machines.</S>
			<S sid ="183" ssid = "42">NEs (named entities): NEs are frequently used Chinese names, including person names, location names, and organization names.</S>
			<S sid ="184" ssid = "43">One cannot develop a regular grammar that rejects or accepts the constructions of NEs with high accuracy, as we can do with most FTs.</S>
			<S sid ="185" ssid = "44">In Section 5.3, we shall describe how we use both heuristics and statistical models for NER.</S>
			<S sid ="186" ssid = "45">NWs (new words): NWs are OOV words that are neither recognized as named entities or factoids nor derived by morphological rules.</S>
			<S sid ="187" ssid = "46">In particular, we focus on low- frequency new words, including newly coined words, occasional words, and mostly time-sensitive words (Wu and Jiang 2000).</S>
			<S sid ="188" ssid = "47">Many current segmenters simply ignore NWs, assuming that they are of little significance in most applications.</S>
			<S sid ="189" ssid = "48">However, we argue that the identification of those words is critical because a single unidentified word can cause segmentation errors in the surrounding words.</S>
			<S sid ="190" ssid = "49">For NLP applications that require full parsing, it is even more critical because a single error would cause a whole sentence to fail.</S>
			<S sid ="191" ssid = "50">538 Figure 2 Taxonomy of morphologically derived words (MDWs) in MSRSeg.</S>
			<S sid ="192" ssid = "51">3.2 MSR Standard.</S>
			<S sid ="193" ssid = "52">The taxonomy employed here has been specified in detail in the MSR standard.</S>
			<S sid ="194" ssid = "53">There are two general guidelines for the development of the standard: 1.</S>
			<S sid ="195" ssid = "54">The standard should be applicable to a wide variety of NLP tasks, of.</S>
			<S sid ="196" ssid = "55">which some representative examples are Chinese text input, IR, TTS, ASR, and MT. 2.</S>
			<S sid ="197" ssid = "56">The standard should be compatible with existing standards, of which.</S>
			<S sid ="198" ssid = "57">representative examples are the Chinese NE standards in ET/ER99, the Mainland standard (GB/T), Taiwan’s ROCLING standard (CNS14366; Huang et al. 1997), and the UPenn Chinese Treebank (Xia 1999), as much as possible.4 We are seeking a standard that is “linguistically felicitous, computationally feasible, and [ensures] data uniformity” (Huang et al. 1997; Sproat and Shih 2002).</S>
			<S sid ="199" ssid = "58">The MSR standard consists of a set of specific rules that aims at unambiguously determining the word segmentation of a Chinese sentence, given a reference lexicon.</S>
			<S sid ="200" ssid = "59">The development of the standard is an iterative procedure, interacting with the development of a gold test set (which we will describe in the next section).</S>
			<S sid ="201" ssid = "60">We begin with an initial set of 4 MET is a Chinese named entity standard defined in the MUC (message understanding conference,.</S>
			<S sid ="202" ssid = "61">http://www.itl.nist.gov/iaui/894.02/related projects/muc/).</S>
			<S sid ="203" ssid = "62">ER99 is an extension of MET, though it is not as universally used as MET (http://www.nist.gov/speech/tests/ieer/er 99/er 99.htm).</S>
			<S sid ="204" ssid = "63">539 segmentation rules, based on which four human annotators label a test corpus.</S>
			<S sid ="205" ssid = "64">Whenever an interannotator conflict is detected (automatically), we resolve it by revising the standard (e.g., mostly by adding more specific rules).</S>
			<S sid ="206" ssid = "65">The process is iterated until no conflict is detected.</S>
			<S sid ="207" ssid = "66">For example, we begin with the rule for detecting MDWs: “if a character sequence can be derived from a LW via a morphological process, then the sequence is treated as an MDW candidate.” We then observe that both z,-JX ‘already ate’ and z,- J - JJc X ‘already had a meal’ are derived from the LW z,- X ‘eat’ via the morphological process of splitting.</S>
			<S sid ="208" ssid = "67">While z,- J X is a reasonable MDW, z,- J - JJc X is debatable.</S>
			<S sid ="209" ssid = "68">We then add a rule: “MDW candidates with complex internal structures should be segmented.” We also add a set of specific rules to define what a complex internal structure is. An example of those rules is “for MDW candidates of type MS, we only consider sequences that are less than four characters long.” One drawback of the approach is that the standard would become very complicated as we continue to add such specific rules, and people would start making clerical errors.</S>
			<S sid ="210" ssid = "69">We currently do not have a systematic solution to this.</S>
			<S sid ="211" ssid = "70">The complexity has to be controlled manually.</S>
			<S sid ="212" ssid = "71">That is, all new added rules are recompiled by a linguist so that the total number of rules is manageable.</S>
			<S sid ="213" ssid = "72">3.3 MSR Gold Test Set and Training Set.</S>
			<S sid ="214" ssid = "73">Several questions had to be answered when we were developing the gold test set for evaluation.</S>
			<S sid ="215" ssid = "74">1.</S>
			<S sid ="216" ssid = "75">How should we construct a test corpus for reliable evaluation?.</S>
			<S sid ="217" ssid = "76">2.</S>
			<S sid ="218" ssid = "77">Does the segmentation in the gold test set depend on a particular lexicon?.</S>
			<S sid ="219" ssid = "78">3.</S>
			<S sid ="220" ssid = "79">Should we assume a single correct segmentation for a sentence?.</S>
	</SECTION>
	<SECTION title="What are the evaluation criteria?. " number = "4">
			<S sid ="221" ssid = "1">the gold test set?</S>
			<S sid ="222" ssid = "2">We answer the first three questions in this section and leave the rest for Section 3.5.</S>
			<S sid ="223" ssid = "3">First, to conduct a reliable evaluation, we select a test corpus that contains approximately half a million Chinese characters that have been proofread and balanced in terms of domains and styles.</S>
			<S sid ="224" ssid = "4">The distributions are shown in Table 2.</S>
			<S sid ="225" ssid = "5">The gold test set is developed by annotating the test corpus according to the MSR standard via the iterative procedure described in Section 3.2.</S>
			<S sid ="226" ssid = "6">The statistics are shown in Table 3.</S>
			<S sid ="227" ssid = "7">Some fragments of the gold test set are shown in Figure 3, and the notation is presented in Table 1.</S>
			<S sid ="228" ssid = "8">As discussed in Section 3.1, we believe that the lexicon is a critical component of many applications.</S>
			<S sid ="229" ssid = "9">The segmentation of the gold test set depends upon a reference lexicon, which is the combination of several lexicons that are used in Microsoft applications, including a Chinese text input system (Gao et al. 2002), ASR (Chang et al. 2001), TTS (Chu et al. 2003), and the MSRNLP Chinese parser (Wu and Jiang 2000).</S>
			<S sid ="230" ssid = "10">The lexicon consists of 98,668 entries.</S>
			<S sid ="231" ssid = "11">We also developed a morph-lexicon, which contains 50,963 high-frequency MDWs.</S>
			<S sid ="232" ssid = "12">We will describe how the morph-lexicon was constructed in Section 5.2.</S>
			<S sid ="233" ssid = "13">Regarding the third question, though it is common that there are multiple plausible segmentations for a given Chinese sentence, we keep only a single gold segmentation for each sentence for two reasons.</S>
			<S sid ="234" ssid = "14">The first is simplicity.</S>
			<S sid ="235" ssid = "15">The second is due to the fact 540 Table 2 Domain/style distribution in the MSR test corpus.</S>
			<S sid ="236" ssid = "16">Do mai n/St yle (M B) D e s c r i p t i v e w r i t i n g E x p o s i t o r y w r i t i n g N a r r a t i v e w r i t i n g P r a c t i c a l w r i t i n g 5 S p o k e n To tal ( % ) Cul ture 2 . 2 4 9.</S>
			<S sid ="237" ssid = "17">6 1 2.</S>
			<S sid ="238" ssid = "18">2 6 4 ( 6 ) Eco nom ic 1 0 . 6 10 2.6 5 5.</S>
			<S sid ="239" ssid = "19">1 1 2.</S>
			<S sid ="240" ssid = "20">7 1 8 1 ( 1 7 ) Lite ratu re 3 3 . 1 1 3 . 2 6 . 3 5 2.</S>
			<S sid ="241" ssid = "21">6 (5 ) Mili tary 4 2.</S>
			<S sid ="242" ssid = "22">1 4 2.</S>
			<S sid ="243" ssid = "23">1 (4 ) Poli tics 3 6 . 2 10 2.9 8 8.</S>
			<S sid ="244" ssid = "24">8 10 0.8 32 8.7 (31 ) Scie nce &amp; Tec h. 7 . 3 1 4 . 7 8 5.</S>
			<S sid ="245" ssid = "25">8 2 . 1 9 . 4 11 9.3 (11 ) Soci ety 4 . 5 6 . 2 5 6.</S>
			<S sid ="246" ssid = "26">9 2 3.</S>
			<S sid ="247" ssid = "27">9 9 1.</S>
			<S sid ="248" ssid = "28">5 (8 ) Spo rt 1 0 . 5 3 3.</S>
			<S sid ="249" ssid = "29">7 8 . 3 5 2.</S>
			<S sid ="250" ssid = "30">5 (5 ) Co mp uter 2 4 . 8 6 5.</S>
			<S sid ="251" ssid = "31">6 9 0.</S>
			<S sid ="252" ssid = "32">4 (9 ) La w 2 . 1 2 6.</S>
			<S sid ="253" ssid = "33">3 2 8.</S>
			<S sid ="254" ssid = "34">4 (3 ) T o t a l ( % ) 4 4 . 9 ( 4 ) 12 0.</S>
			<S sid ="255" ssid = "35">5 (1 2) 57 1.8 (54 ) 18 2.1 (17 ) 13 1.2 (13 ) 1,0 51 (10 0) Table 3 Words in the MSR gold test set.</S>
			<S sid ="256" ssid = "36">Word type N LW 2 0 5, 1 6 2 MD W 3 , 7 4 6 FT 6 , 6 3 0 NE: Pe rso n na m e 4 , 3 4 7 Lo cat io n na m e 5 , 3 1 1 Or ga ni za tio n na m e 3 , 8 5 0 that we currently do not know any effective way of using multiple segmentations in the above-mentioned applications.</S>
			<S sid ="257" ssid = "37">In particular, we segment each sentence as much as possible into words that are stored in the reference lexicon.</S>
			<S sid ="258" ssid = "38">When there are multiple segmentations for a sentence, we keep the one that contains the fewest number of words.</S>
			<S sid ="259" ssid = "39">We have also manually developed a training set according to the MSR standard.</S>
			<S sid ="260" ssid = "40">It contains approximately 40 million Chinese characters from various domains of text such as newspapers, novels, and magazines.</S>
			<S sid ="261" ssid = "41">In our experiments, 90% of the training set is used for model parameter estimation, and the remaining 10% is a held-out set for tuning.</S>
			<S sid ="262" ssid = "42">3.4 SIGHAN’s Bakeoff Standards and Corpora.</S>
			<S sid ="263" ssid = "43">As mentioned in Section 1, MSRSeg is designed as an adaptive segmenter that consists of two components: (1) a generic segmenter that can adapt to different domain vocabularies, and (2) a set of output adaptors, learned from application data, for adapting to different application-specific standards.</S>
			<S sid ="264" ssid = "44">5 Chinese writing is normally divided into the first three: descriptive, expository, and narrative.</S>
			<S sid ="265" ssid = "45">Practical.</S>
			<S sid ="266" ssid = "46">writing is just an umbrella term for practical writing such as notes, letter, emails, and marriage announcements.</S>
			<S sid ="267" ssid = "47">541 Figure 3 Fragments of the MSR gold test set.</S>
			<S sid ="268" ssid = "48">Therefore, we evaluate MSRSeg using five corpora, each corresponding to a different standard, and consistent train–test splits, as shown in Table 4.</S>
			<S sid ="269" ssid = "49">MSR is described in previous sections, and the other four are standards used in SIGHAN’s First International Chinese Word Segmentation Bakeoff (or Bakeoff for brevity) (Sproat and Emerson 2003).</S>
			<S sid ="270" ssid = "50">In the Bakeoff corpora, OOV is defined as the set of words in the test corpus not occurring in the training corpus.</S>
			<S sid ="271" ssid = "51">In experiments, we always consider the following adaptation paradigm.</S>
			<S sid ="272" ssid = "52">Suppose we have a general predefined standard according to which we create a large amount of training data.</S>
			<S sid ="273" ssid = "53">We then develop a generic word segmenter.</S>
			<S sid ="274" ssid = "54">Whenever we deploy the segmenter for any application, we customize the output of the segmenter according to an application-specific standard that can be partially acquired from a given small amount of application data (called adaptation data).</S>
			<S sid ="275" ssid = "55">The MSR standard described in Section 3.2 is used as the general standard in our experiments, on which the generic segmenter has been developed.</S>
			<S sid ="276" ssid = "56">The four Bakeoff standards are used as specific standards into which we wish to adapt the general standard.</S>
			<S sid ="277" ssid = "57">We notice in Table 4 that the adaptation data sets (i.e., training corpora for the four Bakeoff standards) are much smaller than the MSR training set.</S>
			<S sid ="278" ssid = "58">Thus, the experimental setting is a good simulation of the adaptation paradigm described above.</S>
			<S sid ="279" ssid = "59">In the rest of the article, we shall by default report results on the MSR data set unless otherwise stated.</S>
			<S sid ="280" ssid = "60">3.5 Evaluation Methodology.</S>
			<S sid ="281" ssid = "61">As described earlier, we argue that Chinese words (or segmentation units) cannot be defined independently of the applications, and hence a more flexible system (i.e., an Tab le 4 Sta nda rds and cor por a. Cor por a (sta nda rds) Ab bre v. # Tra ini ng wo rd # Tes t wo rd O O V MS R stan dar d M S R 2 0 M 2 2 6 K .0 02 Beij ing Uni vers ity P K 1 . 1 M 1 7 K .0 69 U. Pen n Chi nese Tree ban k C T B 2 5 0 K 4 0 K .1 81 Hon g Kon g City U. H K 2 4 0 K 3 5 K .0 71 Aca dem ia Sini ca A S 5 . 8 M 1 2 K .0 21 542 adaptive segmenter such as MSRSeg) should be adopted.</S>
			<S sid ="282" ssid = "62">However, we are faced with the challenge of performing an objective and rigorous evaluation of such a system.</S>
			<S sid ="283" ssid = "63">In general, the evaluation of NLP systems is concerned with both the criteria and the standard data sets.</S>
			<S sid ="284" ssid = "64">In this article, we argue that MSRSeg is a better system in two regards.</S>
			<S sid ="285" ssid = "65">First, the generic segmenter provides not only word segmentation but also word-internal structures (e.g., the tree structures of MDWs, FTs, and NEs, as will be described in Section 6) that cover all possible segmentations.</S>
			<S sid ="286" ssid = "66">Ideally, such a segmenter provides a superset of segmentation units where each different application can find the subset it needs.</S>
			<S sid ="287" ssid = "67">Second, the output adaptors of MSRSeg can automatically pick different subsets (i.e., segmentation units) from the superset according to different applications.</S>
			<S sid ="288" ssid = "68">Therefore, there are two criteria for evaluating an adaptive segmenter: how complete the superset is and how effective the adaptation is. The real evaluation will require some application data sets (i.e., segmented texts used by different applications).</S>
			<S sid ="289" ssid = "69">However, such application data are not available yet, and no other system has undergone such evaluation, so there is no way to compare our system against others in this fashion.</S>
			<S sid ="290" ssid = "70">The evaluation methodology we adopted in this article is a simulation.</S>
			<S sid ="291" ssid = "71">On the one hand, we developed a generic standard and a corresponding gold test set that simulates the generic superset that attempts to cover as many applications as possible.</S>
			<S sid ="292" ssid = "72">We then evaluate on the data set the completeness of the generic segmenter.</S>
			<S sid ="293" ssid = "73">On the other hand, we will show that we can effectively adapt the generic segmenter to the four different bakeoff data sets, each of which simulates an application subset.</S>
			<S sid ="294" ssid = "74">The evaluation measures we use in this study are summarized in Table 5.</S>
			<S sid ="295" ssid = "75">The performance of MSRSeg is measured through multiple precision–recall (P/R) pairs, and F-measures (defined as 2PR/(P+R)), each for one word type.</S>
			<S sid ="296" ssid = "76">Riv is the recall of in-vocabulary words.</S>
			<S sid ="297" ssid = "77">Roov is the recall of OOV words.</S>
			<S sid ="298" ssid = "78">They are used to measure the segmenter ’s performance in resolving ambiguities in word segmentation and detecting unknown words, respectively.</S>
			<S sid ="299" ssid = "79">We also test the statistical significance of results, using the criterion proposed by Sproat and Emerson (2003).</S>
			<S sid ="300" ssid = "80">In addition to Riv, the number of OAS (overlap ambiguity string) and CAS (combination ambiguity string) errors are used to measure the segmenter ’s performance of resolving ambiguities in word segmentation in more detail.</S>
			<S sid ="301" ssid = "81">Liang (1987) defines OAS and CAS as follows.</S>
			<S sid ="302" ssid = "82">Definition 1 A character string ABC is called an overlap ambiguity string (OAS) if it can be segmented into two words either as AB/C or A/BC (not both), depending on context.</S>
			<S sid ="303" ssid = "83">Table 5 Evaluation measures for Chinese word segmenter.</S>
			<S sid ="304" ssid = "84">Measures Remarks P/R/F Multiple pairs, each for one type of words (i.e., LW, MDW, FT, NE); P/R/F of NER are used for cross-system comparison Roov Test the performance of detecting unknown words Riv Test the performance of resolving ambiguities in word segmentation # OAS errors Similar to cross-bracketing, used for cross-system comparison # CAS errors Test on a set of 70 high-frequency CASs in our study Significant test See Sproat and Emerson (2003).</S>
			<S sid ="305" ssid = "85">543 Definition 2 A character string AB is called a combination ambiguity string (CAS) if A, B, and AB are words.</S>
			<S sid ="306" ssid = "86">Liang (1987) reports that the relative frequency of OASs is 1.2 per 100 characters in Chinese text, and the relative frequency of CASs is 12 times lower than that of OAS.</S>
			<S sid ="307" ssid = "87">However, according to the above definition, the relative frequency of CASs can be much higher because most single characters in Chinese can be words by themselves, and as a result, almost all two-character words can be CASs.</S>
			<S sid ="308" ssid = "88">However, this is not desirable.</S>
			<S sid ="309" ssid = "89">Consider the word fl= 5Z: ‘altitude’.</S>
			<S sid ="310" ssid = "90">Though both fl= ‘high’ and 5Z: ‘degree’ are words by themselves, the segmentation fl=/5Z: almost never occurs in reality.</S>
			<S sid ="311" ssid = "91">To remedy this problem, Sun and Tsou (2001) revise the definition as follows: Definition 3 A character string AB is called a combination ambiguity string (CAS) if A, B, and AB are words, and there is at least one context under which the segmentation A/B is plausible both semantically and syntactically.</S>
			<S sid ="312" ssid = "92">Though the revision clarifies the definition in principle, it requires a judgment of the syntactic and semantic sense of the segmentation—a task where an agreement cannot be reached easily among different human annotators.</S>
			<S sid ="313" ssid = "93">Therefore, we only use the CAS measure in a pilot study.</S>
			<S sid ="314" ssid = "94">As will be described in Section 7, the number of CAS errors is estimated by counting the wrong segmentations of the predefined 70 high- frequency CASs.</S>
			<S sid ="315" ssid = "95">While all the measures in Table 5 can be used in evaluating MSRSeg, most of them cannot be used in cross-system comparisons.</S>
			<S sid ="316" ssid = "96">For example, since the MSR gold test set is based on a reference lexicon, some of the measures are meaningless when we compare our system to other segmenters that use different lexicons.</S>
			<S sid ="317" ssid = "97">So in comparing different systems, we consider only the P/R/F of NER and the number of OAS errors (i.e., crossing brackets), because these measures are lexicon-independent and there is always a single unambiguous answer.</S>
			<S sid ="318" ssid = "98">4.</S>
			<S sid ="319" ssid = "99">Theoretical Background.</S>
			<S sid ="320" ssid = "100">This section provides some theoretical background on the basis of the development of MSRSeg.</S>
			<S sid ="321" ssid = "101">We first present in Section 4.1 a Chinese word segmentation framework that uses source–channel models of Chinese sentence generation.</S>
			<S sid ="322" ssid = "102">Then, in Section 4.2, we generalize source–channel models as linear mixture models in which a wide variety of linguistic knowledge and statistical models can be incorporated in a unified way.</S>
			<S sid ="323" ssid = "103">These models are constructed via two basic modeling tools: (1) n-gram language models (LMs; Chen and Goodman 1999), and (2) finite state automata (FSA; Roche and Schabes 1997).</S>
			<S sid ="324" ssid = "104">More specifically, the LMs we used are bigram and trigram backoff models, where the parameters are estimated using maximum-likelihood estimation (MLE) with a particular smoothing method, called modified absolute discounting, described in Gao, Goodman, and Miao (2001).</S>
			<S sid ="325" ssid = "105">LMs are used to capture statistical information such as the likelihood of word or character sequence.</S>
			<S sid ="326" ssid = "106">FSAs are used to represent (1) the lexicon, (2) the rules for detecting FTs, and (3) the rules for generating NE candidates.</S>
			<S sid ="327" ssid = "107">544 4.1 Source–Channel Models.</S>
			<S sid ="328" ssid = "108">The task of MSRSeg is to detect not only word boundaries but also word types so that words of different types can be processed as shown in Figure 1.</S>
			<S sid ="329" ssid = "109">Therefore, following the Chinese word taxonomy in Table 1, we define a Chinese word class as a group of words that are supposed to be generated according to the same distribution (or processed in the same manner) as follows: 1.</S>
			<S sid ="330" ssid = "110">Each LW is defined as a class;.</S>
			<S sid ="331" ssid = "111">2.</S>
			<S sid ="332" ssid = "112">Each MDW is defined as a class;.</S>
			<S sid ="333" ssid = "113">3.</S>
			<S sid ="334" ssid = "114">Each type of FT (e.g., time expressions) is defined as a class;.</S>
			<S sid ="335" ssid = "115">4.</S>
			<S sid ="336" ssid = "116">Each type of NE (e.g., person names) is defined as a class; and.</S>
	</SECTION>
	<SECTION title="All NWs belong  to a class.. " number = "5">
			<S sid ="337" ssid = "1">Notice that both the LW and MDW classes are open sets and that we need to assign a floor-value to those words that are not stored in the lexicons.</S>
			<S sid ="338" ssid = "2">In particular, we define six unknown word classes as follows.</S>
			<S sid ="339" ssid = "3">One class is used to represent all unknown LWs and all unknown MDWs whose type cannot be detected.</S>
			<S sid ="340" ssid = "4">The other five classes are used to represent unknown MDWs, one for each of the five types listed in Table 1, i.e., MP/MS, MR, MS, MM, and MHP.</S>
			<S sid ="341" ssid = "5">The probabilities of these unknown word classes are estimated using the Good-Turing method.</S>
			<S sid ="342" ssid = "6">Let w = w1 w2 ... wn be a word class sequence, and s be a Chinese sentence that is a character sequence.</S>
			<S sid ="343" ssid = "7">A segmenter ’s job is to choose the most likely word class sequence w∗ among all possible candidates into which s could have been segmented: w∗ = arg max P(w | s) = arg max P(w)P(s | w) (1) w∈GEN(s) w∈GEN(s) where GEN(s) denotes the candidate set given s. Equation (1) is the basic form of source–channel models for Chinese word segmentation.</S>
			<S sid ="344" ssid = "8">The models assume that a Chinese sentence s is generated as follows: First, a person chooses a sequence of concepts (i.e., word classes w) to be output, according to the probability distribution P(w); then the person attempts to express each concept by choosing a sequence of characters, according to the probability distribution P(s|w).</S>
			<S sid ="345" ssid = "9">The source–channel models also can be interpreted in another way: P(w) is a stochastic model estimating the probability of word class sequence.</S>
			<S sid ="346" ssid = "10">It indicates, given a context, how likely a word class occurs.</S>
			<S sid ="347" ssid = "11">For example, person names are more likely to occur before a title such as � � ‘professor ’.</S>
			<S sid ="348" ssid = "12">Consequently, we also refer to P(w) as a context model.</S>
			<S sid ="349" ssid = "13">P(s|w) is a generative model estimating how likely a character string is generated given a word class.</S>
			<S sid ="350" ssid = "14">For example, the character string :$ � ±.</S>
			<S sid ="351" ssid = "15">is more likely to be a person name than £ � ±.</S>
			<S sid ="352" ssid = "16">‘Li Junsheng’ because :$ is a common family name in China while £ is not.</S>
			<S sid ="353" ssid = "17">So P(s|w) is also referred to as class model.</S>
			<S sid ="354" ssid = "18">In our system, we use only one context model (i.e., a trigram language model) and a set of class models of different types, each of which is for one class of words, as shown in Table 6.</S>
			<S sid ="355" ssid = "19">545 Table 6 Context model, word classes, class models, and feature functions.</S>
			<S sid ="356" ssid = "20">Word class Model Feature functions, f (s, w) Context model Word class trigram, P(w) log(P(w)) LW Lexicon TRIE Number of LW in w. MDW Morph-lexicon TRIE Number of MDW in w. NE Character/word bigram, each for Σ st ∈A log(P(s∗ | NE)), where A is the set of one type, P(s∗|NE), where s∗ is a substrings that are NE of a particular type substring of s, and forms an NE.</S>
			<S sid ="357" ssid = "21">in w. FT FSA, each for one type Number of FT (of a particular type) in w. NW SVM classifier Score of SVM classifier.</S>
			<S sid ="358" ssid = "22">It should be noted that different class models are constructed in different ways (e.g., NE models are n-gram models trained on corpora, whereas FT models use derivation rules and have binary values).</S>
			<S sid ="359" ssid = "23">The dynamic value ranges of different class model probabilities can be so different (some are not probabilities but scores) that it is inappropriate to combine all models through simple multiplication as in Equation (1).</S>
			<S sid ="360" ssid = "24">One way to balance these score quantities is to introduce for each class model (i.e., channel model) a model weight λ to adjust the class model score P(s|w) to P(s|w)λ . In our experiments, these weights are optimized so as to minimize thenumber of word segmentation errors on training data under the framework of lin ear models, as described in Section 4.2.</S>
			<S sid ="361" ssid = "25">It is worth noticing that the source–channel models are the rationale behind our system, e.g., the decoding process described in Section 5.6 follows the framework.</S>
			<S sid ="362" ssid = "26">Linear models are just another representation based on the optimization algorithm of class model weights.</S>
			<S sid ="363" ssid = "27">4.2 Linear Models.</S>
			<S sid ="364" ssid = "28">The framework of linear models is derived from linear discriminant functions widely used for pattern classification (Duda, Hart, and Stork 2001) and has been recently introduced into NLP tasks by Collins and Duffy (2001).</S>
			<S sid ="365" ssid = "29">It is also related to (log-)linear models described in Berger, Della Pietra, and Della Pietra (1996), Xue (2003); Och (2003), and Peng, Feng, and McCallum (2004).</S>
			<S sid ="366" ssid = "30">We use the following notation in the rest of the article.</S>
			<S sid ="367" ssid = "31">• Training data are a set of example input/output pairs.</S>
			<S sid ="368" ssid = "32">In Chinese word segmentation, we have training samples {si , wR }, for i = 1 ...</S>
			<S sid ="369" ssid = "33">M, where each si is an input Chinese character sequence and each wR is the reference segmentation (i.e., word class sequence) of si . • We assume a set of D + 1 features fd (s, w), for d = 0 ...</S>
			<S sid ="370" ssid = "34">D. The features are arbitrary functions that map (s, w) to real values.</S>
			<S sid ="371" ssid = "35">Using vector notation, D+1 we have f(s, w) ∈lR , where f(s, w) = {f0 (s, w), f1 (s, w), ...</S>
			<S sid ="372" ssid = "36">, fD (s, w)}.</S>
			<S sid ="373" ssid = "37">As shown in Table 6, f0 (w) is called the base feature and is defined as the logarithm probability of the context model (i.e., word class trigram model).</S>
			<S sid ="374" ssid = "38">fd (s, w), for d = 1 ...</S>
			<S sid ="375" ssid = "39">D, are defined for D word classes, respectively (i.e., 546 they are basically derived from class models).</S>
			<S sid ="376" ssid = "40">Their values are either the summation of the logarithm of the probabilities of the corresponding probabilistic models, or assigned heuristically.</S>
			<S sid ="377" ssid = "41">Here, for those features that are only defined on w, we will omit s and denote them as f (w).</S>
			<S sid ="378" ssid = "42">• Finally, the parameters of the model are a vector of D + 1 parameters, each for one feature function, λ = (λ0 , λ1 , ..</S>
			<S sid ="379" ssid = "43">., λD ).</S>
			<S sid ="380" ssid = "44">λ1 , ..</S>
			<S sid ="381" ssid = "45">., λD are in fact class model weights, described in Section 4.1.</S>
			<S sid ="382" ssid = "46">The likelihood score of a word class sequence w can be written as D Score(w, s, λ) = λf(w, s) = ) λd fd (w, s)· (2) d=0 We see that Equation (2) is yet another representation of the source–channel models described in Section 4.1 by introducing class weights (i.e., adjust P(s|w) to P(s|w)λ ) and taking the logarithm of all probabilities.</S>
			<S sid ="383" ssid = "47">The decision rule of Equation (1) can then be rewritten as w∗ = arg max Score(w, s, λ)· (3) w∈GEN(s) In what follows, we will describe the way of estimating λ under the framework of gradient descent: an iterative procedure of adjusting the parameters of λ in the direction that minimizes the segmentation errors with respect to a loss function.</S>
			<S sid ="384" ssid = "48">We will present in turn the loss function and the optimization algorithm.</S>
			<S sid ="385" ssid = "49">4.2.1 Loss Function.</S>
			<S sid ="386" ssid = "50">Assume that we can measure the number of segmentation errors in w by comparing it with a reference segmentation wR using an error function Er(wR , w) (i.e., editing distance, in our case).</S>
			<S sid ="387" ssid = "51">The training criterion that directly minimizes the segmentation errors over the training data is λ∗ = arg min λ ) Er(wR , w(si , λ)), (4) i=1...M where w(si , λ) is the segmentation determined by Equation (3), where it is denoted as w∗.</S>
			<S sid ="388" ssid = "52">Equation (4) is referred to as the minimum sample risk (MSR; Gao et al. 2005) criterion hereafter.</S>
			<S sid ="389" ssid = "53">Notice that without knowing the “true” distribution of the data, the best λ can be chosen approximately based on training samples.</S>
			<S sid ="390" ssid = "54">This is known as the principle of empirical risk minimization (ERM; Vapnik 1998): If the segmenter were trained using exactly the MSR criterion, it would converge to a Bayes risk performance (minimal error rate) as the training size goes to infinity.</S>
			<S sid ="391" ssid = "55">However, Er(.)</S>
			<S sid ="392" ssid = "56">is a piecewise constant function of the model parameter λ, and thus a poor candidate for optimization by any simple gradient-type numerical search.</S>
			<S sid ="393" ssid = "57">For example, the gradient cannot be computed explicitly because Er(.)</S>
			<S sid ="394" ssid = "58">is not differ- entiable with respect to λ, and there are many local minima on the error surface.</S>
			<S sid ="395" ssid = "59">Therefore, we use an alternative loss function, minimum squared error (MSE) in equation (5), where Score(.)</S>
			<S sid ="396" ssid = "60">is defined in Equation (2), where s has been suppressed 547 for simplicity.</S>
			<S sid ="397" ssid = "61">MSELoss(λ) is simply the squared difference between the score of the correct segmentation and the score of the incorrect one, summing over all training samples.</S>
			<S sid ="398" ssid = "62">MSELoss(λ) = ) i=1...M (Score(wR, λ) − Score(wi , λ))2 · (5) It is useful to note that the MSE solution, under certain conditions, leads to approximations to maximum likelihood solution.</S>
			<S sid ="399" ssid = "63">The quality of the approximation depends upon the form of the linear discriminant functions (e.g., Equation (2)).</S>
			<S sid ="400" ssid = "64">Due to its appealing theoretical properties, the MSE criterion has received considerable attention in the literature, and there are many solution procedures available (Duda, Hart, and Stork 2001).</S>
			<S sid ="401" ssid = "65">4.2.2 Optimization Algorithm.</S>
			<S sid ="402" ssid = "66">This section discusses the delta rule, a training algorithm for an unthresholded perceptron, following the description in Mitchell (1997).</S>
			<S sid ="403" ssid = "67">The delta rule in its component form is λd = λd − ηG(λd ), (6) where η is the step size, and G is the gradient of MSELoss.6 G can be estimated by differentiating the loss function of equation (7) with respect to λd as ∂MSELoss(λ) R R G(λd ) = ∂λd = ) i=1...M (Score(wi , λ) − Score(wi , λ))( fd (wi ) − fd (wi ))· (7) However, the objective function of Equation (5) in the context of our task (i.e., Chinese word segmentation) has many local minima, and thus gradient descent cannot guarantee finding the global minimum.</S>
			<S sid ="404" ssid = "68">We therefore use a stochastic approximation to gradient descent.</S>
			<S sid ="405" ssid = "69">Whereas the gradient descent computes parameter updates after summing over all training samples as shown in Equation (7), the stochastic approximation method updates parameters incrementally, following the calculation of the error for each individual training sample, as shown in Equation (8).</S>
			<S sid ="406" ssid = "70">G(λd ) = (Score(wR, λ) − Score(wi , λ))( fd (wR ) − fd (wi )) (8) i i The stochastic approximation method can be viewed as optimizing a distinct loss function MSELossi (λ) defined for each individual training sample i as follows MSELossi (λ) = (Score(wR, λ) − Score(wi , λ))2 · (9) 6 η is usually taken as a time-decreasing function (e.g., Su and Lee 1994) to have a fast convergence speed in the beginning and a small variance in final iterations.</S>
			<S sid ="407" ssid = "71">We have tested this approach in our study, and it resulted in very limited improvement.</S>
			<S sid ="408" ssid = "72">548 The optimization algorithm we used in our experiments is shown in Figure 4.</S>
			<S sid ="409" ssid = "73">It takes T passes over the training set.</S>
			<S sid ="410" ssid = "74">All parameters are initially set to be 1.</S>
			<S sid ="411" ssid = "75">The context model parameter λ0 does change during training.</S>
			<S sid ="412" ssid = "76">Class model parameters are updated in a simple additive fashion: Parameters are altered according to the gradient with respect to MSELossi (λ).</S>
			<S sid ="413" ssid = "77">In our implementation, we approximate wR as the w in GEN(s) with the fewest errors, so Score(λ, s, wR ) − Score(λ, s, w) ≤ 0, where the equality holds only when wR = w. That is, the model parameters are updated when the sentence is wrongly segmented.</S>
			<S sid ="414" ssid = "78">The update rule increases the parameter values for word classes whose models were “underestimated” (i.e., expected feature value f (s, w) is less than observed feature value f (s, wR )), and decreases the parameter values whose models were “overestimated” (i.e., f (s, w) is larger than f (s, wR )).</S>
			<S sid ="415" ssid = "79">Empirically, the sequence of these updates, when iterated over all training samples, provides a reasonable approximation to descending the gradient with respect to the original loss function of Equation (5).</S>
			<S sid ="416" ssid = "80">Although this method cannot guarantee a globally optimal solution, it is chosen for our modeling because of its efficiency and because it achieved the best results in our experiments.</S>
			<S sid ="417" ssid = "81">The algorithm is similar to the perceptron algorithm described in Collins (2002).</S>
			<S sid ="418" ssid = "82">The key difference is that, instead of using the delta rule of Equation (8) (as shown in line 5 of Figure 4), Collins (2002) updates parameters using the rule: λt+1 ← λt + fd (wR ) − d d i fd (wi ).</S>
			<S sid ="419" ssid = "83">Our pilot study shows that our algorithm achieves slightly better results.</S>
			<S sid ="420" ssid = "84">4.3 Discussions on Robustness.</S>
			<S sid ="421" ssid = "85">The training methods described in Section 4.2 aim at minimizing errors in a training set.</S>
			<S sid ="422" ssid = "86">But test sets can be different.</S>
			<S sid ="423" ssid = "87">The robustness issue concerns how well the minimal error rate in the training set preserves in the test set.</S>
			<S sid ="424" ssid = "88">According to Dudewicz and Mishra (1988), the MSE function in general is not very robust because it is not bounded and can be contaminated from those training samples far away from the decision boundary.</S>
			<S sid ="425" ssid = "89">One of many possible solutions for improving the robustness is to introduce a margin in the training procedure of Figure 4.</S>
			<S sid ="426" ssid = "90">The basic idea is to enlarge the score difference (or score margin) between a correct segmentation (i.e., wR ) and its competing incorrect segmentations (i.e., {w; w ∈ GEN(s), w /= wR }).</S>
			<S sid ="427" ssid = "91">According to Equation (8), the perceptron training algorithm of Figure 4 does not adjust parameters if the sentence is segmented correctly.</S>
			<S sid ="428" ssid = "92">The robustness could be improved if we continued to enlarge the score margin between the correct segmentation and the top competing candidate even if the input sentence had been correctly segmented, until the Figure 4 The perceptron training algorithm for Chinese word segmentation.</S>
			<S sid ="429" ssid = "93">549 margin has exceeded a preset threshold.</S>
			<S sid ="430" ssid = "94">More specifically, we can modify Equation (8) as follows G(λd ) = (Score(wR , λ) − Score(wi , λ) − δ)( fd (wR ) − fd (wi )), (10) i i where δ is the desired margin that can either be an absolute value or a quantity proportional to the score of the correct segmentation (Su and Lee 1994).</S>
			<S sid ="431" ssid = "95">The modified training algorithm is similar to the perceptron algorithm with margins proposed by Krauth and Me` zard (1987).</S>
			<S sid ="432" ssid = "96">We leave the evaluation of the algorithm to future work.</S>
			<S sid ="433" ssid = "97">Readers can also refer to Duda, Hart, and Stork (2001) for a detailed description of margin-based learning algorithms.</S>
			<S sid ="434" ssid = "98">5.</S>
			<S sid ="435" ssid = "99">System Description.</S>
			<S sid ="436" ssid = "100">5.1 Architecture Overview.</S>
			<S sid ="437" ssid = "101">MSRSeg consists of two components: a generic segmenter and a set of output adaptors.</S>
			<S sid ="438" ssid = "102">We describe the first component in this section and leave the second to Section 6.</S>
			<S sid ="439" ssid = "103">The generic segmenter has been developed on the basis of the mathematical models described in Section 4.</S>
			<S sid ="440" ssid = "104">It consists of several components, as shown in Figure 5.</S>
			<S sid ="441" ssid = "105">1. Sentence Segmenter: To detect sentence boundaries using punctuation.</S>
			<S sid ="442" ssid = "106">clues such as . , ? and !.</S>
			<S sid ="443" ssid = "107">2.</S>
			<S sid ="444" ssid = "108">Word Candidate Generator: Given an input string s, to generate all word.</S>
			<S sid ="445" ssid = "109">candidates and store them in a word lattice.</S>
			<S sid ="446" ssid = "110">Each candidate is assigned to its word class and the class model score, e.g., log P(s∗|w), where s’ is any substring of s. Figure 5 Overall architecture of MSRSeg.</S>
			<S sid ="447" ssid = "111">550 3.</S>
			<S sid ="448" ssid = "112">Decoder: To select the best (or the N best) word segmentation (i.e., word.</S>
			<S sid ="449" ssid = "113">class sequence w*) from the lattice according to Equations (4) and (5), using the Viterbi (or A*) search algorithm.</S>
			<S sid ="450" ssid = "114">4.</S>
			<S sid ="451" ssid = "115">Wrapper: To output segmentation results using some predefined canonical.</S>
			<S sid ="452" ssid = "116">forms, e.g., MDW and FT are of their normalized form, as described in Section 3.1.</S>
			<S sid ="453" ssid = "117">Here, we will describe candidate generators for different word classes.</S>
			<S sid ="454" ssid = "118">They are (1) the lexicon (and morph-lexicon) TRIEs to generate LW (or MDW) candidates, (2) the NE class models to generate NE candidates, (3) the finite-state automaton (FSA) to generate FT candidates, and (4) the classifier to generate NW candidates.</S>
			<S sid ="455" ssid = "119">5.2 Lexicon Representation and Morphological Analysis.</S>
			<S sid ="456" ssid = "120">Lexicon words are represented as a set of TRIEs (Frakes and BaezaYates 1992), which is a particular implementation of the FSA described in Section 4.</S>
			<S sid ="457" ssid = "121">Given a character string, all prefix strings that form lexical words can be retrieved by browsing the TRIE whose root represents its first character.</S>
			<S sid ="458" ssid = "122">Though there are well-known techniques for English morphological analysis (e.g., finite-state morphology), they are difficult to extend to Chinese for two reasons.</S>
			<S sid ="459" ssid = "123">First, Chinese morphological rules are not as general as their English counterparts.</S>
			<S sid ="460" ssid = "124">For example, in most cases English plural nouns can be generated using the rule “noun + s → plural noun”.</S>
			<S sid ="461" ssid = "125">But only a small subset of Chinese nouns can be pluralized (e.g., )j ‘friends’) using its Chinese counterpart “noun + plural noun” whereas :iz 7 others (e.g., W m ‘pumpkins’) cannot.</S>
			<S sid ="462" ssid = "126">Secondly, the operations required by Chinese morphological analysis, such as copying in reduplication, merging, and splitting, cannot be implemented using current finite-state networks.8 Our solution is extended lexicalization.</S>
			<S sid ="463" ssid = "127">We simply collect all MDWs of the five types described in Section 3.1 and incorporate them into the TRIE lexicon, called morph-lexicon.</S>
			<S sid ="464" ssid = "128">The TRIEs are essentially the same as those used for lexical words, except that not only the MDW’s identity but also its morphological pattern and stem(s) are stored.</S>
			<S sid ="465" ssid = "129">The procedure of lexicalization involves three steps: (1) Candidate generation.</S>
			<S sid ="466" ssid = "130">Candidate generation is done by applying a set of morphological rules to both the word lexicon and a large corpus.</S>
			<S sid ="467" ssid = "131">For example, the rule ‘noun + fl → plural noun’ fl.</S>
			<S sid ="468" ssid = "132">(2) Statistical filtering.</S>
			<S sid ="469" ssid = "133">For each candidate, we obtain a set of statistical features such as frequency, mutual information, and left/right context dependency from a large corpus.</S>
			<S sid ="470" ssid = "134">We then use an information-gain-like metric described in Chien (1997) and Gao et al.</S>
			<S sid ="471" ssid = "135">(2002) to estimate how likely a candidate is to form a morphologically derived word and remove the “bad” candidates.</S>
			<S sid ="472" ssid = "136">The basic idea behind the metric is that a Chinese word should appear as a stable sequence in the corpus.</S>
			<S sid ="473" ssid = "137">That is, the components within the word are strongly correlated, while the components at both ends should have low correlations with words outside the sequence.</S>
			<S sid ="474" ssid = "138">(3) Linguistic selection.</S>
			<S sid ="475" ssid = "139">Finally, we manually check the remaining candidates 7 We do not consider those special cases, such as in a children’s fairy story, where the magic pumpkins.</S>
			<S sid ="476" ssid = "140">can talk.</S>
			<S sid ="477" ssid = "141">8 There are some types of copying operations that can be implemented by FSMs (e.g., Sproat 1992), but.</S>
			<S sid ="478" ssid = "142">implementation is not trivial.</S>
			<S sid ="479" ssid = "143">Because the number of MDWs is manageable, storing them as a list is not much more expensive than storing them as a finite-state network, in terms of space and access speed.</S>
			<S sid ="480" ssid = "144">Our implementation can be viewed as a pragmatic solution, easy to implement and maintain.</S>
			<S sid ="481" ssid = "145">551 and construct the morph-lexicon, where each entry is tagged with its morphological pattern and stem(s).</S>
			<S sid ="482" ssid = "146">The resulting morph-lexicon contains 50,963 MDWs.</S>
			<S sid ="483" ssid = "147">5.3 Named Entities.</S>
			<S sid ="484" ssid = "148">We consider four types of named entities: person names (PNs), location names (LNs), organization names (ONs), and transliterations of foreign names (FNs).</S>
			<S sid ="485" ssid = "149">Because any character string can in principle be a named entity of one or more types, in order to limit the number of candidates for a more effective search, we generate named entity candidates given an input string in two steps: First, for each type, we use a set of constraints (which are compiled by linguists and are represented as FSAs) to generate only those “most likely” candidates.</S>
			<S sid ="486" ssid = "150">Second, each of the generated candidates is assigned a class model probability.</S>
			<S sid ="487" ssid = "151">Class models are defined as generative models that are estimated on their corresponding named entity lists using MLE, together with a backoff smoothing schema, as described in Section 4.1.1.</S>
			<S sid ="488" ssid = "152">We will describe briefly the constraints and the class models here.</S>
			<S sid ="489" ssid = "153">The Chinese person-name model is a modified version of that described in Sproat et al.</S>
			<S sid ="490" ssid = "154">(1996).</S>
			<S sid ="491" ssid = "155">Other NE models are novel, though they share some similarities with the Chinese person-name model.</S>
			<S sid ="492" ssid = "156">5.3.1 Chinese Person Names.</S>
			<S sid ="493" ssid = "157">There are two main constraints.</S>
			<S sid ="494" ssid = "158">(1) PN patterns: We assume that a Chinese PN consists of a family name F and a given name G, and is of the pattern F+G. Both F and G are one or two characters long.</S>
			<S sid ="495" ssid = "159">(2) Family name list: We only consider PN candidates that begin with an F stored in the family name list (which contains 373 entries in our system).</S>
			<S sid ="496" ssid = "160">Given a PN candidate, which is a character string s, the class model probability P(s|PN) is computed by a character bigram model as follows: (1) generate the family name substring sF , with the probability P(sF |F); (2) generate the given name sub-string sG , with the probability P(sG |G)(or P(sG1 |G1)); and (3) generate the second given name, with the probability P(sG2 |sG1 , G2).</S>
			<S sid ="497" ssid = "161">For example, the generative probability of the string :$ � ±.</S>
			<S sid ="498" ssid = "162">given that it is a PN would be estimated as P(:$ � ±.|PN) = P(:$|F)P(�|G1)P(±.|�, G2).</S>
			<S sid ="499" ssid = "163">5.3.2 Location Names.</S>
			<S sid ="500" ssid = "164">Unlike PNs, there are no patterns for LNs.</S>
			<S sid ="501" ssid = "165">We assume that an LN candidate is generated given s (which is less than 10 characters long), if one of the following conditions is satisfied: (1) s is an entry in the LN list (which contains 30,000 LNs); (2) s ends in a keyword in a 120-entry LN keyword list (e.g., ‘city’).9 rfJ The probability P(s|LN) is computed by a character bigram model.</S>
			<S sid ="502" ssid = "166">Consider a string 3Z*;,.P ‘Shamir river ’.</S>
			<S sid ="503" ssid = "167">It is an LN candidate because it ends in an LN keyword P ‘river ’.</S>
			<S sid ="504" ssid = "168">The generative probability of the string, given that it is an LN, would be estimated as P(3Z * ;,.</S>
			<S sid ="505" ssid = "169">P|LN) = P(3Z|&lt;LN&gt;) P(*|3Z) P(;,.|*) P(P|;,.)</S>
			<S sid ="506" ssid = "170">P(&lt;/LN&gt;|P &lt;LN&gt; and &lt;/LN&gt; are symbols denoting the beginning and the end of an LN, respectively.</S>
			<S sid ="507" ssid = "171">5.3.3 Organization Names.</S>
			<S sid ="508" ssid = "172">ONs are more difficult to identify than PNs and LNs because ONs are usually nested named entities.</S>
			<S sid ="509" ssid = "173">For example, the ON cp OO OO i&apos; fil � }S&apos;j ‘Air China Corporation’ contains an LN cpOO ‘China’.</S>
			<S sid ="510" ssid = "174">9 For clarity, the constraint is a simplified version of that used in MSRSeg..</S>
			<S sid ="511" ssid = "175">552 Like the identification of LNs, an ON candidate is only generated given a character string s (less than 15 characters long), if it ends in a keyword in a 1,355-entry ON keyword list (e.g., } S&apos;j ‘corporation’).</S>
			<S sid ="512" ssid = "176">To estimate the generative probability of a nested ON, we introduce word class segmentations of s, w, as hidden variables.</S>
			<S sid ="513" ssid = "177">In principle, the ON class model recovers P(s|ON) over all possible C: P(s | ON) = Σw P(s,w | ON) = Σw P(w | ON)P(s | w, ON).</S>
			<S sid ="514" ssid = "178">Since P(s | w,ON) = P(s | w), we have P(s | ON) = Σw P(w | ON)P(s | w).</S>
			<S sid ="515" ssid = "179">We then assume that the sum is approximated by a single pair of terms P(w∗| ON)P(s | w∗ ), where w∗ is the most probable word class segmentation discovered by Equation (5).</S>
			<S sid ="516" ssid = "180">That is, we also use our system to find w*, but the source–channel models are estimated on the ON list.</S>
			<S sid ="517" ssid = "181">Consider the earlier example.</S>
			<S sid ="518" ssid = "182">Assuming that w* = LN/OO i&apos; /} S&apos;j, where cp OO is tagged as an LN, the probability P(s | ON) would be estimated using a word OO /fil �/} S&apos;j | ON) P(cpOO | LN) = P(LN | &lt;ON&gt;) P(OOi&apos; | LN) P(fil� | OOi&apos;) P(}S&apos;j | fil�) P(&lt;/ON&gt; | }S&apos;j P(cpOO | LN), where P(cpOO | LN) is the class model probability of cpOO given that it is an LN, and &lt;ON&gt; and &lt;/ON&gt; are symbols denoting the beginning and the end of an ON, respectively.</S>
			<S sid ="519" ssid = "183">5.3.4 Transliterations of Foreign Names.</S>
			<S sid ="520" ssid = "184">As described in Sproat et al.</S>
			<S sid ="521" ssid = "185">(1996), FNs are usually transliterated using Chinese character strings whose sequential pronunciation mimics the source language pronunciation of the name.</S>
			<S sid ="522" ssid = "186">Since FNs can be of any length and their original pronunciation is effectively unlimited, the recognition of such names can be tricky.</S>
			<S sid ="523" ssid = "187">Fortunately, there are only a few hundred Chinese characters that are particularly common in transliterations.</S>
			<S sid ="524" ssid = "188">Therefore, an FN candidate would be generated given s if it contains only characters stored in a transliterated name character list (which contains 618 Chinese characters).</S>
			<S sid ="525" ssid = "189">The probability P(s|FN) is estimated using a character bigram model.</S>
			<S sid ="526" ssid = "190">Notice that in our system an FN can be a PN, an LN, or an ON, depending on the context.</S>
			<S sid ="527" ssid = "191">Then, given an FN candidate, three named entity candidates, each for one category, are generated in the lattice, with the class probabilities P(s|PN) = P(s|LN) = P(s|ON) = P(s|FN).</S>
			<S sid ="528" ssid = "192">In other words, we postpone the determination of its type to the decoding phase where the context model is used.</S>
			<S sid ="529" ssid = "193">5.3.5 Abbreviations.</S>
			<S sid ="530" ssid = "194">For the sake of completeness, we describe below the basic ideas for tackling NE abbreviations within our framework.</S>
			<S sid ="531" ssid = "195">This is ongoing research, and we do not have conclusive results yet.</S>
			<S sid ="532" ssid = "196">Readers can refer to Zhu et al.</S>
			<S sid ="533" ssid = "197">(2003) and Sun, Zhou, and Gao (2003) for more details, where marginal improvements have been reported.</S>
			<S sid ="534" ssid = "198">For different types of NEs, different strategies can be adopted.</S>
			<S sid ="535" ssid = "199">We find that most abbreviations of Chinese PNs and LNs are single-character NEs.</S>
			<S sid ="536" ssid = "200">The PN and LN models described previously cannot handle them very well because (1) single-character NEs are generated in a different way from that of multicharacter NEs, and (2) the context of single-character NEs is different from multicharacter ones.</S>
			<S sid ="537" ssid = "201">For example, single- character NEs usually appear adjacent to one another, such as cp and i in cp i&apos;1f !i\ ‘China-Russia trade’.</S>
			<S sid ="538" ssid = "202">But this is not the case for multicharacter NEs.</S>
			<S sid ="539" ssid = "203">We thus define single-character PNs and LNs as two separate word classes, denoted by SCPN and SCLN, respectively.</S>
			<S sid ="540" ssid = "204">We assume that a character is a candidate of SCPN (or SCLN) only when it is included in a predefined SCPN (or SCLN) list, which 553 contains 151 (or 177) characters.</S>
			<S sid ="541" ssid = "205">The class model probabilities are assigned by unigram models as C(s) C(s) P(s | SCPN) = L C(s ) , P(s | SCLN) = L C(s ) , (11) i=1...N i=1...N where C(s) is the count of the SCPN (or SCLN) s in an annotated training set and N is the size of the SCPN (or SCLN) list.</S>
			<S sid ="542" ssid = "206">In the context model, we also differentiate between PN (or LN) and SCPN (or SCLN).</S>
			<S sid ="543" ssid = "207">Therefore, SCPN and SCLN should be labeled explicitly in the training data.</S>
			<S sid ="544" ssid = "208">It is much more difficult to detect abbreviations of ONs (denoted by ONA) because ONAs are usually multiple-character strings and can be generated from their original ON arbitrarily.</S>
			<S sid ="545" ssid = "209">For example, the abbreviation of � -&apos;- ‘Tsinghua University’ is �-&apos;- while the abbreviation of ‘Peking University’ is . We assume that an ONA candidate is only generated given a character string s (fewer than 6 characters long), if both of the following conditions are satisfied: (1) An ON has been detected in the same document, and (2) s can be derived from the ON using a generative pattern defined in Table 7.</S>
			<S sid ="546" ssid = "210">Since there is no training data for the ONA class model, we construct a score function to assign each ONA candidate a class model score.</S>
			<S sid ="547" ssid = "211">Consider a string . The generative probability of the string, given it is an ONA, would be approximated as P( | ONA) ≈ P( | ON) P( | , ON), where P( | , ON) is defined as a constant (0.8 in our experiments) if can be derived from using any generative pattern of Figure 7; 0, otherwise.</S>
			<S sid ="548" ssid = "212">If more than one ON is detected previously in the same document and can be used to derive the ONA candidate (e.g., 1J ‘North University’), only the closest ON is taken into account.</S>
			<S sid ="549" ssid = "213">We also notice that ONAs and ONs occur in similar contexts.</S>
			<S sid ="550" ssid = "214">So we do not differentiate them in the context model.</S>
			<S sid ="551" ssid = "215">5.4 Factoids.</S>
			<S sid ="552" ssid = "216">The types of factoids handled in MSRSeg are shown in Table 1 of Section 3.1.</S>
			<S sid ="553" ssid = "217">For each type of factoid, we generate a grammar of regular expressions.</S>
			<S sid ="554" ssid = "218">The ten regular expressions are then compiled into a single FSA.</S>
			<S sid ="555" ssid = "219">Given an input string s, we scan it from left to right, and output a FT candidate when a substring matches one of the ten Table 7 Generative patterns of ONA, where sij denotes the j-th character of the i-th word of ON (Sun, Zhou and Gao 2003).</S>
			<S sid ="556" ssid = "220">Condition (ON) Generated patterns (ONA) Examples ON = w1 ... wN (N ≥ 2) ONA = s11 s21 , or / / → ONA = s11 s21 s31 , or ...</S>
			<S sid ="557" ssid = "221">/ / → ONA = s11 s21... sN1 ON = w1 w2 , and w1 is not an LN ONA = w1 / → ON = w1 w2 w3 , and w1 is not an LN ONA = w1 , or / / → ONA = w1 w2 / ON = w1 w2 w3 , and w1 is an LN ONA = w2 / → / → 554 regular expressions.</S>
			<S sid ="558" ssid = "222">We also remove those FT candidates that are substrings of any other candidates of the same type.</S>
			<S sid ="559" ssid = "223">Consider the example in Figure 1; only the string Cf-:.</S>
			<S sid ="560" ssid = "224">JJ is accepted as a FT candidate (a time expression), not the substrings (e.g., Cf or Cf-:.</S>
			<S sid ="561" ssid = "225">The use of FSA is motivated by the fact that the detection of most FTs is based exclusively on their internal properties and without relying on context.</S>
			<S sid ="562" ssid = "226">This can be in principle justified by experiments.</S>
			<S sid ="563" ssid = "227">As shown in Table 8, the overall performance of FT detection using only FSA is comparable with that of using MSRSeg where the contextual information of the FT is considered (i.e., in MSRSeg, FSA are used as feature functions, and the FT are detected simultaneously with other words).</S>
			<S sid ="564" ssid = "228">If we read the results carefully, we can see that the use of context information (in MSRSeg) achieves a higher precision but a lower recall—a small but significant difference.</S>
			<S sid ="565" ssid = "229">5.5 New Words.</S>
			<S sid ="566" ssid = "230">New words in this section refer to OOV words that are neither recognized as named entities or factoids nor derived by morphological rules.</S>
			<S sid ="567" ssid = "231">These words are mostly domain- specific and/or time-sensitive, such as -:.</S>
			<S sid ="568" ssid = "232">.i1 ‘Three Links’, F J,I ‘SARS’.</S>
			<S sid ="569" ssid = "233">The identification of such new words has not been studied extensively before.</S>
			<S sid ="570" ssid = "234">It is an important issue that has substantial impact on the performance of word segmentation.</S>
			<S sid ="571" ssid = "235">For example, approximately 30% of OOV words in the SIGHAN’s PK corpus in Table 4 are new words of this type.</S>
			<S sid ="572" ssid = "236">There has been previous work on detecting Chinese new words from a large corpus in an off-line manner and updating the dictionary before word segmentation.</S>
			<S sid ="573" ssid = "237">However, our approach is able to detect new words online, i.e., to spot new words in a sentence on the fly during the process of word segmentation, where widely used statistical features such as mutual information or term frequency are not available.</S>
			<S sid ="574" ssid = "238">For brevity, we will focus on the identification of two-character new words, denoted as NW 11.</S>
			<S sid ="575" ssid = "239">Other types of new words such as NW 21 (a two-character word followed with a character) and NW 12 can be detected similarly (e.g., by viewing the two- character word as an inseparable unit, like a character).</S>
			<S sid ="576" ssid = "240">These three types amount to 85% of all NWs in the PK corpus.</S>
			<S sid ="577" ssid = "241">Here, we shall describe the class model and context model for NWI, and the creation of training data by sampling.</S>
			<S sid ="578" ssid = "242">5.5.1 Class Model.</S>
			<S sid ="579" ssid = "243">We use a classifier (SVMlight [Joachims 2002] in our experiments) to estimate the likelihood of two adjacent characters forming a new word.</S>
			<S sid ="580" ssid = "244">Of the great number of features with which we experimented, four linguistically motivated features are chosen due to their effectiveness and availability for online detection.</S>
			<S sid ="581" ssid = "245">They are independent word probability (IWP), anti-word pair (AWP), word formation analogy Table 8 FT detection results on the MSR gold test set.</S>
			<S sid ="582" ssid = "246">The ‘All’ column shows the results of detecting all 10 types of factoids, as described in Table 1, which amount to 6630 factoids, as shown in Table 3.</S>
			<S sid ="583" ssid = "247">A l l ( P / R ) da t ( P/ R ) ti m (P / R ) me a (P /R ) mo n (P /R ) FSA 0 . 9 0 6 / 0 . 9 0 5 0.9 67/ 0.8 70 0.9 67/ 0.9 67 0.9 11/ 0.9 19 0.9 91/ 0.9 75 MS RSe g 0 .908/ 0.896 0.9 80/ 0.8 51 0.9 73/ 0.9 67 0.9 13/ 0.8 98 0.9 94/ 0.9 75 555 (WFA), and morphological productivity (MP).</S>
			<S sid ="584" ssid = "248">We now describe each feature in turn.</S>
			<S sid ="585" ssid = "249">In Section 5.5.2, we shall describe the way the training data (new word list) for the classifier is created by sampling.</S>
			<S sid ="586" ssid = "250">IWP (independent word probability) is a real-valued feature.</S>
			<S sid ="587" ssid = "251">Most Chinese characters can be used either as independent words or component parts of multicharacter words, or both.</S>
			<S sid ="588" ssid = "252">The IWP of a single character is the likelihood of this character to appear as an independent word in texts (Wu and Jiang 2000): IWP(x) = C(x, W ) , (12) C(x) where C(x, W ) is the number of occurrences of the character x as an independent word in training data, and C(x) is the total number of occurrences of x in training data.</S>
			<S sid ="589" ssid = "253">We assume that the IWP of a character string is the product of the IWPs of the component characters.</S>
			<S sid ="590" ssid = "254">Intuitively, the lower the IWP value, the more likely the character string forms a new word.</S>
			<S sid ="591" ssid = "255">In our implementation, the training data is word-segmented.</S>
			<S sid ="592" ssid = "256">AWP (anti-word pair) is a binary feature derived from IWP.</S>
			<S sid ="593" ssid = "257">For example, the value of AWP of an NW 11 candidate ab is defined as: AWP(ab)=1 if IWP(a)&gt;θ or IWP(b) &gt;θ;0, otherwise.</S>
			<S sid ="594" ssid = "258">θ ∈ [0, 1] is a preset threshold.</S>
			<S sid ="595" ssid = "259">Intuitively, if one of the component char acters is very likely to be an independent word, it is unlikely to be able to form a word with any other characters.</S>
			<S sid ="596" ssid = "260">While IWP considers all component characters in a new word candidate, AWP only considers the one with the maximal IWP value.</S>
			<S sid ="597" ssid = "261">WFA (word formation analogy) is a binary feature.</S>
			<S sid ="598" ssid = "262">Given a character pair (x, y), a character (or a multicharacter string) z is called the common stem of (x, y) if at least one of the following two conditions hold: (1) character strings xz and yz are lexical words (i.e., x and y as prefixes); and (2) character strings zx and zy are lexical words (i.e., x and y as suffixes).</S>
			<S sid ="599" ssid = "263">We then collect a list of such character pairs, called affix pairs, of which the number of common stems is larger than a preset threshold.</S>
			<S sid ="600" ssid = "264">The value of WFA for a given NW 11 candidate ab is defined as: WFA(ab) = 1 if there exists an affix pair (a, x) (or (b, x)) and the string xb (or ax) is a lexical word; 0, otherwise.</S>
			<S sid ="601" ssid = "265">For example, given an ) = 1 because ( , NW 11 candidate 1� (xia4gang3, ‘be laid off’), we have WFA(1� 1) is an affix pair (they have 32 common stems such as l:, VI, {5, if_, [Il, &apos;f, JI) and � (shang4gang3, ‘take over a shift’) is a lexical word.</S>
			<S sid ="602" ssid = "266">MP (morphological productivity) is a real-valued feature.</S>
			<S sid ="603" ssid = "267">It is a measure of the productivity of a particular construction, as defined here (Baayen 1989): MP(x) = n1 (x) .</S>
			<S sid ="604" ssid = "268">(13) N(x) MP is strongly related to the Good-Turing estimate.</S>
			<S sid ="605" ssid = "269">Here, N is the number of tokens of a particular construction found in a corpus, e.g., the number of tokens of all nouns ending in - , and n1 is the number of types of that construction, e.g., the number of unique nouns ending in - . Intuitively, a higher value of MP indicates a higher probability that (one of) the component parts of a multicharacter string appears to be a word.</S>
			<S sid ="606" ssid = "270">For example, Sproat and Shih (2002) show that the MP values of Chinese noun affix - and verb affix - are 0.20 and 0.04, respectiv ely, indicating that is a much more productive affix, while the MP value of single-character nouns which belong to 556 a closed and nonproductive class is close to 0.</S>
			<S sid ="607" ssid = "271">These results are in agreement with our intuition.</S>
			<S sid ="608" ssid = "272">Similarly, we find some very productive characters with high MP values.</S>
			<S sid ="609" ssid = "273">For example, in our training set, there are 236 words that contain the character &apos;§, among which 13 occur only once.</S>
			<S sid ="610" ssid = "274">5.5.2 Context Model.</S>
			<S sid ="611" ssid = "275">The motivations for using a context model for NWI are twofold.</S>
			<S sid ="612" ssid = "276">The first is to capture useful contextual information.</S>
			<S sid ="613" ssid = "277">For example, new words are more likely to be nouns than pronouns, and POS tagging is context-sensitive.</S>
			<S sid ="614" ssid = "278">The second is more important.</S>
			<S sid ="615" ssid = "279">As described in Section 4, with a context model, NWI can be performed simultaneously with other word segmentation tasks (e.g., word breaking, NER, and morphological analysis) in a unified manner.</S>
			<S sid ="616" ssid = "280">However, it is difficult to develop a training corpus where new words are annotated because “we usually do not know what we don’t know.” Our solution is Monte Carlo simulation.</S>
			<S sid ="617" ssid = "281">We sample a set of new words from our dictionary according to the distribution—the probability that any lexical word w would be a new word P(NW|w).</S>
			<S sid ="618" ssid = "282">We then generate a new-word-annotated corpus from a word-segmented text corpus.</S>
			<S sid ="619" ssid = "283">Now we describe the way P(NW|w) is estimated.</S>
			<S sid ="620" ssid = "284">It is reasonable to assume that new words are those words whose probability of appearing in a new document is lower than general lexical words.</S>
			<S sid ="621" ssid = "285">Let Pi (k) be the probability of word wi that occurs k times in a document.</S>
			<S sid ="622" ssid = "286">In our experiments, we assume that P(NW|wi ) can be approximated by the probability of wi occurring less than K times in a new document: K 1 P(NW | wi ) ≈ ) Pi (k), (14) k = 0 where the constant K (7 in our experiments) is dependent on the size of the document: The larger the document, the larger the value.</S>
			<S sid ="623" ssid = "287">Pi (k) can be estimated using several term distribution models (Chapter 15.3 in Manning and Schu¨ tze [1999]).</S>
			<S sid ="624" ssid = "288">Following Gao and Lee (2000), we use K-Mixture (Katz 1996) which estimates Pi (k) as Pi (k) = (1 − a)δk, 0 + β a 1 ( β β + 1 )k , (15) where δk,0 =1 if k=0; 0, otherwise.</S>
			<S sid ="625" ssid = "289">α and β are parameters that can be fit using the observed mean λ and the observed inverse document frequency IDF as follows: λ = cf df β = λ × 2IDF − 1 = cf − df , and a = λ , (16) df β where cf is the total number of occurrence of word wi in training data, df is the number of documents in training data in which wi occurs, and N is the total number of documents.</S>
			<S sid ="626" ssid = "290">In our implementation, the training data contain approximately 40,000 documents that have been balanced among domain, style, and time.</S>
			<S sid ="627" ssid = "291">557 Table 9 NW 11 identification results on PK test set.</S>
			<S sid ="628" ssid = "292">P R F All feat ures 0.5 65 0.7 88 0.6 58 w/ o IW P 0.3 95 0.8 35 0.5 36 w/ o AW P 0.5 08 0.7 23 0.5 96 w/ o MP 0.5 56 0.7 71 0.6 46 w/ o WF A 0.5 61 0.7 79 0.6 52 Table 10 NW 21 identification results on PK test set.</S>
			<S sid ="629" ssid = "293">P R F All feat ures 0.4 20 0.8 11 0.5 53 w/ o IW P 0.1 04 0.9 73 0.1 88 w/ o AW P 0.3 38 0.7 30 0.4 62 w/ o MP 0.3 98 0.7 16 0.5 12 w/ o WF A 0.4 01 0.7 97 0.5 34 5.5.3 Evaluation Results.</S>
			<S sid ="630" ssid = "294">The NWI component has been constructed as an SVM classifier.</S>
			<S sid ="631" ssid = "295">This section discusses two factors that we believe have the most impact on the performance of NWI.</S>
			<S sid ="632" ssid = "296">First, we investigate the relative contribution of the four linguistically motivated features in NWI.</S>
			<S sid ="633" ssid = "297">Second, we compare methods where we use the NWI component (i.e., an SVM classifier) as a post-processor versus as a feature function in the linear models of Equation (4).</S>
			<S sid ="634" ssid = "298">Table 11 NWI results on PK and CTB corpora, NWI as post-processor versus unified approach.</S>
			<S sid ="635" ssid = "299">PK CTB MS RSe g Ro ov F P R Ro ov F P R w/ o NW I .7 41 .95 6 .94 9 .96 3 .6 90 .89 2 .87 5 .91 0 w/ NW I (post pro cess or) .7 46 .95 3 .94 7 .96 0 .7 22 .89 9 .88 6 .91 2 w/ NW I (uni fied app roac h) .7 81 .95 5 .95 2 .95 9 .7 46 .90 4 .89 5 .91 4 Table 12 NWI results on HK and AS corpora, NWI as post-processor versus unified approach.</S>
			<S sid ="636" ssid = "300">HK AS MS RSe g Ro ov F P R Ro ov F P R w/ o NW I .6 94 .94 7 .93 7 .95 8 .4 36 .95 1 .95 8 .94 3 w/ NW I (post pro cess or) .7 28 .95 2 .94 4 .95 9 .5 49 .95 5 .95 0 .95 9 w/ NW I (uni fied app roac h) .7 46 .95 4 .94 8 .96 0 .5 84 .95 8 .95 5 .96 1 558 The NWI results on the PK test set are shown in Tables 9 and 10.</S>
			<S sid ="637" ssid = "301">We turned off the features one at a time and recorded the scores of each ablated NWI component.</S>
			<S sid ="638" ssid = "302">It turns out that in cases of both NW 11 and NW 12, IWP is obviously the most effective feature.</S>
			<S sid ="639" ssid = "303">Tables 11 and 12 show results of NWI on four Bakeoff test sets.</S>
			<S sid ="640" ssid = "304">We can see that unified approaches (i.e., using the NWI component as a feature function) significantly outperform consecutive approaches (i.e., using the NWI component as a post-processor) consistently, in terms of both Roov and P/R/F of the overall word segmentation.</S>
			<S sid ="641" ssid = "305">This demonstrates empirically the benefits of using the context model for NWI and the unified approach to Chinese word segmentation, as described in 5.5.2.</S>
			<S sid ="642" ssid = "306">5.6 Decoder.</S>
			<S sid ="643" ssid = "307">The decoding process follows the source–channel framework.</S>
			<S sid ="644" ssid = "308">It consists of three steps: Step 1: Throughout the process, we maintain an array of word class candidates, called a lattice, which is initialized to be empty.</S>
			<S sid ="645" ssid = "309">Step 2: Given a Chinese sentence, all possible words of different types are generated simultaneously by the corresponding channel models described in Sections 5.2 to 5.5.</S>
			<S sid ="646" ssid = "310">For example, as shown in Table 6, the lexicon TRIE generates LW candidates; the SVM classifier generates NW candidates, and so on.</S>
			<S sid ="647" ssid = "311">All the generated candidates are added to the lattice.</S>
			<S sid ="648" ssid = "312">Each element in the lattice is a 5tuple (w, i, l, t, s), where w is the word candidate, i is the starting position of w in the sentence, l is the length of w, t is the word class tag, and s is the class model score of w assigned by its feature function in Table 6.</S>
			<S sid ="649" ssid = "313">Some examples are shown in Figure 5.</S>
			<S sid ="650" ssid = "314">Step 3: The Viterbi (or A*) algorithm is used to search for the best word class sequence, among all candidate segmentations in the lattice, according to Equations (2) and (3).</S>
			<S sid ="651" ssid = "315">For efficiency, we sometimes need to control the search space.</S>
			<S sid ="652" ssid = "316">Given an input sentence s, all word candidates are ranked by their normalized class model score λf (.).</S>
			<S sid ="653" ssid = "317">Thus, the number of candidates (i.e., the size of the lattice) is controlled by two parameters: • Number threshold: The maximum number of candidates cannot be larger than a given threshold; • Score threshold: The difference between the class model score of the top-ranked candidates and the bottom-ranked candidates cannot be larger than a given threshold.</S>
	</SECTION>
	<SECTION title="Standards Adaptation. " number = "6">
			<S sid ="654" ssid = "1">This section describes the second component of MSRSeg: a set of adaptors for adjusting the output of the generic segmenter to different application-specific standards.</S>
			<S sid ="655" ssid = "2">We consider the following standards adaptation paradigm.</S>
			<S sid ="656" ssid = "3">Suppose we have a general standard predefined by ourselves.</S>
			<S sid ="657" ssid = "4">We have also created a large amount of training data that are segmented according to this general standard.</S>
			<S sid ="658" ssid = "5">We then develop a generic word segmenter, i.e., the system described in Section 5.</S>
			<S sid ="659" ssid = "6">Whenever we 559 deploy the segmenter for any application, we need to customize the output of the segmenter according to an application-specific standard, which is not always explicitly defined.</S>
			<S sid ="660" ssid = "7">However, it is often implicitly defined in a given amount of application data (called adaptation data) from which the specific standard can be partially acquired.</S>
			<S sid ="661" ssid = "8">6.1 Transformation-Based Learning Approach.</S>
			<S sid ="662" ssid = "9">In MSRSeg, standards adaptation is conducted by a postprocessor that performs an ordered list of transformations on the output of the generic segmenter—removing extraneous word boundaries and inserting new boundaries—to obtain a word segmentation that meets a different standard.</S>
			<S sid ="663" ssid = "10">The method we use is Transformation-Based Learning (TBL; Brill [1995]), which requires an initial segmentation, a goal segmentation into which we wish to transform the initial segmentation, and a space of allowable transformations (i.e., transformation templates).</S>
			<S sid ="664" ssid = "11">Under the above-mentioned adaptation paradigm, the initial segmentation is the output of the generic segmenter.</S>
			<S sid ="665" ssid = "12">The goal segmentation is adaptation data.</S>
			<S sid ="666" ssid = "13">The transformation templates can make reference to words (i.e., lexicalized templates) as well as some predefined types (i.e., class-type based templates), as described below.</S>
			<S sid ="667" ssid = "14">We notice that most variability in word segmentation across different standards comes from those words that are not typically stored in the dictionary.</S>
			<S sid ="668" ssid = "15">Those words are dynamic in nature and are usually formed through productive morphological processes.</S>
			<S sid ="669" ssid = "16">In this study, we focus on three categories: MDW, NE, and FT. For each word class that belongs to these categories, we define an internal structure similar to Wu (2003).</S>
			<S sid ="670" ssid = "17">The structure is a tree with ‘word class’ as the root and ‘component types’ as the other nodes.</S>
			<S sid ="671" ssid = "18">There are 30 component types.</S>
			<S sid ="672" ssid = "19">As shown in Figure 6, the word class Affixation has three component types: Prefix, Stem, and Suffix.</S>
			<S sid ="673" ssid = "20">Similarly, PersonName has two component types and Date has nine—3 as non-terminals and 6 as terminals.</S>
			<S sid ="674" ssid = "21">These internal structures are assigned to words by the generic segmenter at Figure 6 Word internal structure and class-type transformation templates.</S>
			<S sid ="675" ssid = "22">560 Table 13 Comparison scores for PK open and CTB open.</S>
			<S sid ="676" ssid = "23">PK (# of Tr.</S>
			<S sid ="677" ssid = "24">Word = 1.1M) CTB (# of Tr.</S>
			<S sid ="678" ssid = "25">Word = 250K) P R F Ro ov Ri v P R F Ro ov Ri v 1.</S>
			<S sid ="679" ssid = "26">MS RSe g w/ o ada ptat ion .82 4 .85 4 .83 9 .3 20 .86 1 .79 9 .81 8 .80 9 .6 24 .86 1 2.</S>
			<S sid ="680" ssid = "27">MS RSe g .95 2 .95 9 .95 5 .7 81 .97 2 .89 5 .91 4 .90 4 .7 46 .95 0 3.</S>
			<S sid ="681" ssid = "28">FM M w/ ada ptat ion .91 3 .94 6 .92 9 .5 24 .97 7 .80 5 .87 4 .83 8 .5 21 .95 2 4.</S>
			<S sid ="682" ssid = "29">Ran k 1 in Bak eoff .95 6 .96 3 .95 9 .7 99 .97 5 .90 7 .91 6 .91 2 .7 66 .94 9 5.</S>
			<S sid ="683" ssid = "30">Ran k 2 in Bak eoff .94 3 .96 3 .95 3 .7 43 .98 0 .89 1 .91 1 .90 1 .7 36 .94 9 run time.</S>
			<S sid ="684" ssid = "31">The transformation templates for words of the above three categories are of the form: Condition: word class Actions: • Insert: Place a new boundary between two component types.</S>
			<S sid ="685" ssid = "32">• Delete: Remove an existing boundary between two component types.</S>
			<S sid ="686" ssid = "33">Since the application of the transformations derived from the above templates is conditioned on word class and makes reference to component types, we call the templates class-type transformation templates.</S>
			<S sid ="687" ssid = "34">Some examples are shown in Figure 6.</S>
			<S sid ="688" ssid = "35">In addition, we also use lexicalized transformation templates as follows: • Insert: Place a new boundary between two lemmas.</S>
			<S sid ="689" ssid = "36">• Delete: Remove an existing boundary between two lemmas.</S>
			<S sid ="690" ssid = "37">Here, lemmas refer to those basic lexical words that cannot be formed by any productive morphological process.</S>
			<S sid ="691" ssid = "38">They are mostly single characters, two-character words, and 4-character idioms.</S>
			<S sid ="692" ssid = "39">6.2 Evaluation Results.</S>
			<S sid ="693" ssid = "40">The results of standards adaptation on four Bakeoff open test sets are shown in Tables 13 and 14.10 A set of transformations for each standard is learned using TBL from the corresponding Bakeoff training set.</S>
			<S sid ="694" ssid = "41">For each test set, we report results using our system with and without standards adaptation (Rows 1 and 2).</S>
			<S sid ="695" ssid = "42">It turns out that performance improves dramatically across the board in all four test sets.</S>
			<S sid ="696" ssid = "43">For comparison, we also include in each table the results of using the FMM (forward maximum matching) greedy segmenter as a generic segmenter (Row 3), and the top 2 scores (sorted by F) that are reported in SIGHAN’s First International Chinese Word Segmentation Bakeoff (Rows 4 and 5).11 We can see that with adaptation, 10 See Section 8.3 for the definitions of open test and close test..</S>
			<S sid ="697" ssid = "44">11 The FMM algorithm processes through the sentence from left to right, taking the longest match with the.</S>
			<S sid ="698" ssid = "45">lexicon entry at each point.</S>
			<S sid ="699" ssid = "46">Similarly, the BMM (backward maximum matching) algorithm processes the sentence from right to left.</S>
			<S sid ="700" ssid = "47">561 Table 14 Comparison scores for HK open and AS open.</S>
			<S sid ="701" ssid = "48">HK (# of Tr.</S>
			<S sid ="702" ssid = "49">Word = 240K) AS (# of Tr.</S>
			<S sid ="703" ssid = "50">Word = 5.8M) P R F Ro ov Ri v P R F Ro ov Ri v 1.</S>
			<S sid ="704" ssid = "51">MS RSe g w/ o ada ptat ion .81 9 .82 2 .82 0 .5 93 .84 0 .83 2 .83 8 .83 5 .4 05 .84 7 2.</S>
			<S sid ="705" ssid = "52">MS RSe g .94 8 .96 0 .95 4 .7 46 .97 7 .95 5 .96 1 .95 8 .5 84 .96 9 3.</S>
			<S sid ="706" ssid = "53">FM M w/ ada ptat ion .81 8 .82 3 .82 1 .5 91 .84 1 .93 0 .94 7 .93 9 .1 60 .96 4 4.</S>
			<S sid ="707" ssid = "54">Ran k 1 in Bak eoff .95 4 .95 8 .95 6 .7 88 .97 1 .89 4 .91 5 .90 4 .4 26 .92 6 5.</S>
			<S sid ="708" ssid = "55">Ran k 2 in Bak eoff .86 3 .90 9 .88 6 .5 79 .93 5 .85 3 .89 2 .87 2 .2 36 .90 6 Table 15 Size of training data set and the adaptation results on AS open.</S>
			<S sid ="709" ssid = "56">Size of trai nin g set( # wor ds) R P F Ro ov Ri v 5.8 M .96 1 .95 6 .95 8 .6 03 .96 8 2.9 M .95 9 .95 0 .95 4 .6 23 .96 6 1.1 M .95 4 .94 5 .94 9 .5 91 .96 2 .25 M .94 7 .93 5 .94 1 .5 95 .95 5 w/ o ada ptat ion .83 2 .83 8 .83 5 .4 05 .84 7 our generic segmenter can achieve state-of-the-art performance on different standards, showing its superiority over other systems.</S>
			<S sid ="710" ssid = "57">For example, there is no single segmenter in the Bakeoff that achieved top-2 ranks in all four test sets (Sproat and Emerson 2003).</S>
			<S sid ="711" ssid = "58">We notice in Tables 13 and 14 that the quality of adaptation seems to depend largely upon the size of adaptation data (indicated by # of Tr.</S>
			<S sid ="712" ssid = "59">Word in the tables): we outperformed the best Bakeoff systems in the AS set because of the large size of the adaptation data, while we are worse in the CTB set because of the small size of the adaptation data.</S>
			<S sid ="713" ssid = "60">To verify our hypothesis, we evaluated the adaptation results using subsets of the AS training set of different sizes and observed the same trend, as shown in Table 15.</S>
			<S sid ="714" ssid = "61">However, even with a much smaller adaptation data set (e.g., 250K words), we still outperform the best Bakeoff results.</S>
	</SECTION>
	<SECTION title="Training Data Creation. " number = "7">
			<S sid ="715" ssid = "1">This section describes (semi-)automatic methods of creating the training data based on the estimated class model probability P(w) (i.e., trigram probability) in Equation (1).</S>
			<S sid ="716" ssid = "2">Ideally, given an annotated corpus, where each sentence is segmented into words that are tagged by their classes, the trigram word class probabilities can be calculated using MLE.</S>
			<S sid ="717" ssid = "3">Unfortunately, building such annotated training corpora is very expensive.</S>
			<S sid ="718" ssid = "4">7.1 Bootstrapping Approach and Beyond.</S>
			<S sid ="719" ssid = "5">Our basic solution is the bootstrapping approach described in Gao et al.</S>
			<S sid ="720" ssid = "6">(2002).</S>
			<S sid ="721" ssid = "7">It consists of three steps: (1) Initially, we use a greedy word segmenter to annotate the corpus and obtain an initial context model based on the initial annotated corpus; (2) we reannotate the corpus using the obtained models; and (3) we retrain the context 562 Figure 7 (a) A Chinese OAS 19 �.</S>
			<S sid ="722" ssid = "8">(b) Two sentences in the training set, which contain the OAS and (c) whose OASs have been replaced with the single tokens &lt;OAS&gt;.</S>
			<S sid ="723" ssid = "9">(Li et al. 2003).</S>
			<S sid ="724" ssid = "10">Table 16 Methods of resolving OAs in word segmentation, on the MSR test set.</S>
			<S sid ="725" ssid = "11">Met hod s Ac cur ac y FM M 7 3 . 1 % BM M 7 1 . 5 % Rule + FM M 9 0 . 7 % Rule + BM M 9 1 . 3 % Our s 9 4 . 3 % model using the reannotated corpus.12 Steps 2 and 3 are iterated until the performance of the system converges.</S>
			<S sid ="726" ssid = "12">This approach is also named Viterbi iterative training, an approximation of EM training.</S>
			<S sid ="727" ssid = "13">In the above approach, the quality of the context model depends to a large degree upon the quality of the initial annotated corpus, which is, however, not satisfied due to two problems.</S>
			<S sid ="728" ssid = "14">First, the greedy segmenter cannot deal with the segmentation ambiguities, and even after many iterations, these ambiguities can only be partially resolved.</S>
			<S sid ="729" ssid = "15">Second, many factoids and named entities cannot be identified using the greedy word segmenter, which is based on the dictionary.</S>
			<S sid ="730" ssid = "16">To solve the first problem, we use two methods to resolve segmentation ambiguities in the initially segmented training data.</S>
			<S sid ="731" ssid = "17">We classify word segmentation ambiguities into two classes: overlap ambiguity (OA) and combination ambiguity (CA), corresponding, respectively, to OAS and CAS, defined in Section 3.5.</S>
			<S sid ="732" ssid = "18">To resolve OA, we identify all OASs in the training data and replace them with a single token &lt;OAS&gt;.</S>
			<S sid ="733" ssid = "19">An example is shown in Figure 7.</S>
			<S sid ="734" ssid = "20">By doing so, we remove the portion of training data that are likely to contain OA errors.</S>
			<S sid ="735" ssid = "21">We thus train a context model using the reduced training set that does not contain any OASs.</S>
			<S sid ="736" ssid = "22">Intuitively, the resulting context model would resolve the ambiguities.</S>
			<S sid ="737" ssid = "23">The method has been tested on the MSR test set.</S>
			<S sid ="738" ssid = "24">Our main results are shown in Table 16.</S>
			<S sid ="739" ssid = "25">We can see that the FMM (or backward maximum matching—BMM) method can only resolve 73.1% (or 71.1%) of OAs, while using our method, the resulting context model can resolve 94.3% of the OAs.</S>
			<S sid ="740" ssid = "26">Our method is different from previous ones that use lexicalized rules to resolve OAS.</S>
			<S sid ="741" ssid = "27">For example, Sun and Zuo (1998) report that over 90% of OAs can be disambiguated 12 The greedy word segmenter is based on a FMM algorithm..</S>
			<S sid ="742" ssid = "28">563 Figure 8 Results of 70 high-frequency two-character CASs.</S>
			<S sid ="743" ssid = "29">‘Voting’ indicates the accuracy of the baseline method that always chooses the more frequent case of a given CAS.</S>
			<S sid ="744" ssid = "30">‘ME’ indicates the accuracy of the maximum-entropy classifier.</S>
			<S sid ="745" ssid = "31">‘VSM’ indicates the accuracy of the method of using VSM for disambiguation.</S>
			<S sid ="746" ssid = "32">simply by rules.</S>
			<S sid ="747" ssid = "33">We reimplemented their method in our experiments and found that 90.7% (or 91.3%) of the OAs in the MSR test set can be resolved.</S>
			<S sid ="748" ssid = "34">The result is similar to Sun and Zou’s but still not as good as ours.</S>
			<S sid ="749" ssid = "35">Therefore, we conclude that our method significantly outperforms the rule-based approaches.</S>
			<S sid ="750" ssid = "36">Another advantage of our method is that it is an unsupervised approach that requires no human annotation.</S>
			<S sid ="751" ssid = "37">Readers can refer to Li et al.</S>
			<S sid ="752" ssid = "38">(2003) for more details.</S>
			<S sid ="753" ssid = "39">To resolve CA, we select 70 high-frequency two-character CASs (e.g., --!</S>
			<S sid ="754" ssid = "40">‘talent’ and --!/ ‘just able’), as shown in Figure 8.</S>
			<S sid ="755" ssid = "41">For each CAS, we train a binary classifier using sentences that contain the CAS and that have been segmented using the greedy segmenter.</S>
			<S sid ="756" ssid = "42">Then, for each occurrence of a CAS in the initial segmented training data, the corresponding classifier is used to determine whether the CAS should be segmented.</S>
			<S sid ="757" ssid = "43">Our experiments show that 95.7% of the CAs can be resolved.</S>
			<S sid ="758" ssid = "44">Detailed results are shown in Figure 8, where ‘Voting’ indicates the accuracy of the baseline method that always chooses the more frequent case of a given CAS, and ‘VSM’ indicates the accuracy of the VSM-inspired (vector space model) binary classifier, which will be described here.13 Suppose we have a CAS, s, whose position in a sentence is i. We use its six surrounding words w in positions i−3, i−2, i−1, i+1, i+2, and i+3 as features.</S>
			<S sid ="759" ssid = "45">We then define a set of feature functions to simulate the TFIDF scores.</S>
			<S sid ="760" ssid = "46">Each feature function is a mapping f (s, w) ∈ lR.</S>
			<S sid ="761" ssid = "47">In particular, let TF1(s, w) (or TF2(s, w)) be the term frequency of w in the case that s is a 1-word (or 2-word) string.</S>
			<S sid ="762" ssid = "48">Similarly, let IDF1 (s, w) (or IDF2 (s, w)) be 1 if w only occurs in the case that s is a 1-word (or 2-word) string.</S>
			<S sid ="763" ssid = "49">If w occurs in both cases, let IDF1 (s, w) = IDF2 (s, w) = 0.25.</S>
			<S sid ="764" ssid = "50">We also assign weight λ for each position empirically (i.e., in our experiments, we have λ−3 =λ+3 =1, λ−2 =λ+2 =4, and λ−1 =λ+1 =7).</S>
			<S sid ="765" ssid = "51">Then we can calculate the score of s to be 1-word or 2-word by Equations (18) and (19), respectively.</S>
			<S sid ="766" ssid = "52">The CAS is a single word if Score1(s) &gt; Score2(s), and two words otherwise.</S>
			<S sid ="767" ssid = "53">Score 1(s) = )TF 1(s, wi )IDF 1(s, wi )λi (17) i=−3...+3,i/=0 Score 2(s) = )TF 2(s, wi )IDF 2(s, wi )λi (18) i=−3...+3,i/=0 13 The VSM-inspired classifier for resolving CAs was mainly proposed and implemented by Wenfeng Yang.</S>
			<S sid ="768" ssid = "54">when he was visiting Microsoft Research Asia.</S>
			<S sid ="769" ssid = "55">564 Our experiments show that the VSM-inspired classifier outperforms other well- known classifiers for this particular task.</S>
			<S sid ="770" ssid = "56">For example, a maximum entropy classifier using the same features achieved an overall accuracy of 94.1%.</S>
			<S sid ="771" ssid = "57">For the second problem of NE and FT detection, though, we can simply use the FSA- based approach, as described in Section 5.4, to detect FTs in the initial segmented corpus; our method of NER in the initial step (i.e., step 1) is a little more sophisticated.</S>
			<S sid ="772" ssid = "58">First, we manually annotate named entities on a small subset (called the seed set) of the training data.</S>
			<S sid ="773" ssid = "59">Then we obtain a context model on the seed set (called the seed model).</S>
			<S sid ="774" ssid = "60">We thus improve the context model that is trained on the initial annotated training corpus by interpolating it with the seed model.</S>
			<S sid ="775" ssid = "61">Finally, we use the improved context model in steps 2 and 3 of the bootstrapping.</S>
			<S sid ="776" ssid = "62">We shall show in the next subsection that a relatively small seed set (e.g., 150K words) is enough to get a reasonably good context model for initialization.</S>
			<S sid ="777" ssid = "63">7.2 Evaluation Results.</S>
			<S sid ="778" ssid = "64">To justify the methods just described, we built a large number of context models using different initial corpora.</S>
			<S sid ="779" ssid = "65">For each of the initial corpora, a context model is trained using the Viterbi iterative procedure until convergence, i.e., the improvement of the word segmentation performance of the resulting system, is less than a preset threshold.</S>
			<S sid ="780" ssid = "66">The results are shown in Table 17, where Row 1 (FMM) presents the segmentation results of using the initial corpus segmented by a greedy word segmenter— the basic solution described earlier; in Row 2, we resolve segmentation (overlap) ambiguities on top of the corpus in Row 1; we then tag FTs in Rows 3 and 4.</S>
			<S sid ="781" ssid = "67">From Rows 5 to 8, several NE annotated seed sets of different sizes are used, showing the trade-off between performance and human cost.</S>
			<S sid ="782" ssid = "68">In Rows 1 to 8, we use the raw training set containing approximately 50 million characters.</S>
			<S sid ="783" ssid = "69">For comparison, we also include in Row 9 the results of MSRSeg, whose context model has been trained on a 20-million-word manually annotated corpus.</S>
			<S sid ="784" ssid = "70">The experimental results reveal several facts.</S>
			<S sid ="785" ssid = "71">Table 17 Comparison of performance of MSRSeg: The versions that are trained using (semi-)supervised iterative training with different initial training sets (Rows 1 to 8) versus the version that is trained on annotated corpus of 20 million words (Row 9).</S>
			<S sid ="786" ssid = "72">I n i t i a l t r a i n i n g s e t Wo rd se g me nta tio n F T P N L N O N F P R P R P R P R P R 1 2 3 4 FMM 1+ OA 1+ FT 2+ FT .8 7 7 .833 .927 .8 8 6 .841 .936 .9 1 9 .894 .946 .9 2 7 .903 .954 .90 3 .88 7 .90 2 .88 6 5 6 7 8 4 + N E S ee d se t ( M w o r d ) 0.1 5 0.3 5 0.5 0 1.0 0 .9 6 1 .955 .968 .9 6 7 .962 .973 .9 6 7 .962 .972 .9 6 8 .963 .973 .90 0 .88 9 .90 3 .89 1 .90 5 .89 5 .90 5 .89 5 .83 5 .81 8 .84 0 .82 0 .84 4 .82 1 .85 4 .82 6 .89 7 .86 5 .90 0 .86 6 .90 0 .86 3 .90 3 .86 5 .78 0 .68 1 .79 4 .68 0 .80 0 .67 8 .80 2 .67 9 9 MSR trainin g set .9 7 4 .969 .979 .90 5 .89 9 .87 0 .90 6 .89 2 .85 5 .81 6 .65 4 565 Table 18 Precision of person name recognition on the MSR test set, using Viterbi iterative training, initialized by four seed sets with different sizes.</S>
			<S sid ="787" ssid = "73">See d set (M char ) w/ o ite rat ion w/ 1 ite rat ion w/ 2 ite rat ion s 0.15 . 7 4 5 .7 90 (+ 1.</S>
			<S sid ="788" ssid = "74">6 % ) .8 0 0 (+ 0.</S>
			<S sid ="789" ssid = "75">7 % ) 0.35 . 7 5 7 .7 96 (+ 1.</S>
			<S sid ="790" ssid = "76">8 % ) .8 0 2 (+ 0.</S>
			<S sid ="791" ssid = "77">5 % ) 0.50 . 7 8 3 .8 24 (+ 5.</S>
			<S sid ="792" ssid = "78">2 % ) .8 3 5 (+ 1.</S>
			<S sid ="793" ssid = "79">3 % ) 1.00 . 8 1 5 .8 35 (+ 2.</S>
			<S sid ="794" ssid = "80">5 % ) .8 4 0 (+ 0.</S>
			<S sid ="795" ssid = "81">6 % ) • Although the greedy segmenter (FMM) can resolve around 90% of ambiguities in word segmentation, as shown in Table 16, the resulting segmenter is still much worse than MSRSeg because a large number of unknown words cannot be detected correctly even after Viterbi iterative learning.</S>
			<S sid ="796" ssid = "82">• The method of resolving OA brings marginal improvements.</S>
			<S sid ="797" ssid = "83">Since the method does not require any human annotation, Row 2 shows the best results we achieved in our experiments using unsupervised learning approaches.</S>
			<S sid ="798" ssid = "84">• Factoid rules, although simple, bring substantial improvements.</S>
			<S sid ="799" ssid = "85">• The Viterbi iterative training method does not turn out to be an effective way of resolving ambiguities in word segmentation or of detecting new words.</S>
			<S sid ="800" ssid = "86">In Rows 1 to 4, the word segmentation performance always saturates after 2 or 3 iterations, with little improvement.</S>
			<S sid ="801" ssid = "87">For example, FMM (Row 1) achieves an initial segmentation F-measure of 0.8771, and after two iterations, it saturates and ends up with 0.8773.</S>
			<S sid ="802" ssid = "88">Table 19 Precision of location name recognition on the MSR test set, using Viterbi iterative training, initialized by four seed sets with different sizes.</S>
			<S sid ="803" ssid = "89">Seed set (M char) w/o iteration w/1 iteration w/2 iterations 0.15 .883 .895 (+1.4%) .897 (+0.2%) 0.35 .893 .901 (+0.9%) .900 (−0.1%) 0.50 .894 .901 (+0.8%) .900 (−0.1%) 1.00 .895 .902 (+0.8%) .903 (+0.1%) Table 20 Precision of organization name recognition on the MSR test set, using Viterbi iterative training, initialized by four seed sets with different sizes.</S>
			<S sid ="804" ssid = "90">See d set (M char ) w/ o ite rat ion w/ 1 ite rat ion w/ 2 ite rat ion s 0.15 . 6 9 5 .77 0 (+1 0.8 %) .7 8 0 (+ 1.</S>
			<S sid ="805" ssid = "91">3 % ) 0.35 . 7 3 7 .78 6 (+6 .6 %) .7 9 4 (+ 1.</S>
			<S sid ="806" ssid = "92">0 % ) 0.50 . 7 4 5 .79 0 (+6 .0 %) .8 0 0 (+ 1.</S>
			<S sid ="807" ssid = "93">3 % ) 1.00 . 7 5 7 .79 6 (+5 .2 %) .8 0 2 (+ 0.</S>
			<S sid ="808" ssid = "94">8 % ) 566 • The Viterbi iterative training is effective in boosting the precision of NER without great sacrifices for recall (e.g., the recall remains almost the same when using the seed set of Row 5 in Table 17, or becomes a little worse when using the seed sets of Rows 6 to 8).</S>
			<S sid ="809" ssid = "95">As shown in Tables 18–20, we start with a series of seed sets of different sizes and achieve a reasonable accuracy of NER, which is comparable with that of MSRSeg, after two iterations.</S>
			<S sid ="810" ssid = "96">• The use of a small NE annotated seed set (e.g., in Row 5) would achieve the best trade-off between performance and human effort, because after two iterations, the accuracy of NER is very close to that of using larger seed sets, while the human effort of creating the seed set is much less.</S>
	</SECTION>
	<SECTION title="System Evaluation. " number = "8">
			<S sid ="811" ssid = "1">8.1 System Results.</S>
			<S sid ="812" ssid = "2">Our system is designed so that components such as the FT detector and NE recognizer can be “switched on or off” so that we can investigate the relative contribution of each component to the overall word segmentation performance.</S>
			<S sid ="813" ssid = "3">To date, we have not done a separate evaluation of MDW recognition.</S>
			<S sid ="814" ssid = "4">We leave that to future work.</S>
			<S sid ="815" ssid = "5">The main results are shown in Table 21.</S>
			<S sid ="816" ssid = "6">For comparison, we also include in the table (Row 1) the results of using the greedy segmenter (FMM) described in Section 7.</S>
			<S sid ="817" ssid = "7">Row 2 shows the baseline results of our system, where only the lexicon is used.</S>
			<S sid ="818" ssid = "8">It is interesting to find, in Rows 1 and 2, that the dictionary-based methods already achieve quite good recall, but the precision is not very good because those methods cannot correctly identify unknown words that are not in the lexicon, such as factoids and named entities.</S>
			<S sid ="819" ssid = "9">We also find that even using the same lexicon, our approach based on the linear mixture models outperforms the greedy approach (with a slight but statistically significant difference) because the use of context model resolves more ambiguities in segmentation.</S>
			<S sid ="820" ssid = "10">The most promising property of our approach is that the linear mixture models provide a flexible framework where a wide variety of linguistic knowledge and statistical models can be combined in a unified way.</S>
			<S sid ="821" ssid = "11">As shown in Rows 3 to 6, when components are switched on in turn by activating corresponding class models, the overall word segmentation performance increases consistently.</S>
			<S sid ="822" ssid = "12">Table 21 MSRSeg system results for the MSR test set.</S>
			<S sid ="823" ssid = "13">Word segmentation FT PN LN ON Segmenter P R P R P R P R P R 1 F M M .8 37 . 9 2 7 2 Ba se lin e .8 63 . 9 4 7 3 2 + F T .9 13 . 9 6 1 .90 4 .89 8 4 3 + P N .9 50 . 9 7 2 .90 5 .89 8 .79 0 .90 5 5 4 + L N .9 55 . 9 7 5 .90 5 .89 9 .85 8 .90 6 .794 .86 0 6 5 + O N .9 69 . 9 7 9 .90 5 .89 9 .87 0 .90 6 .892 .85 5 .816 .654 567 We also conduct an error analysis, which shows that 85% of errors come from NER and factoid detection, especially the NE abbreviations, although the tokens of these word types amount to only 8.3% in the MSR test set.</S>
			<S sid ="824" ssid = "14">The remaining 15% of errors are mainly due to new words.</S>
			<S sid ="825" ssid = "15">8.2 Comparison with Other Systems using the MSR Test Set.</S>
			<S sid ="826" ssid = "16">We compare our system with three other Chinese word segmenters on the MSR test set:14 1.</S>
			<S sid ="827" ssid = "17">The MSWS system is one of the best available products.</S>
			<S sid ="828" ssid = "18">It is released by.</S>
			<S sid ="829" ssid = "19">Microsoft (as a set of Windows APIs).</S>
			<S sid ="830" ssid = "20">MSWS first conducts word breaking using MM (augmented by heuristic rules for disambiguation), and then conducts factoid detection and NER using rules.</S>
			<S sid ="831" ssid = "21">2.</S>
			<S sid ="832" ssid = "22">The LCWS system is one of the best research systems in mainland China..</S>
			<S sid ="833" ssid = "23">It is released by Beijing Language University.</S>
			<S sid ="834" ssid = "24">The system works similarly to MSWS, but has a larger dictionary containing more PNs and LNs.</S>
			<S sid ="835" ssid = "25">3.</S>
			<S sid ="836" ssid = "26">The PBWS system is a rule-based Chinese parser (Wu and Jiang 2000) that.</S>
			<S sid ="837" ssid = "27">can also output word segmentation results.</S>
			<S sid ="838" ssid = "28">It explores high-level linguistic knowledge such as syntactic structure for Chinese word segmentation and NER.</S>
			<S sid ="839" ssid = "29">As mentioned earlier, to achieve a fair comparison, we compare the previously mentioned four systems only in terms of NER precision and recall and the number of OAS errors.</S>
			<S sid ="840" ssid = "30">However, we find that due to the different annotation specifications used by these systems, it is still very difficult to compare their results automatically.</S>
			<S sid ="841" ssid = "31">For example, m i&amp; Iff ‘Beijing city government’ has been segmented inconsistently as /i&amp;Iff ‘Beijing city’ + ‘government’ or /mi&amp;Iff ‘Beijing’ + ‘city government’ even in the same system.</S>
			<S sid ="842" ssid = "32">Worse still, some LNs tagged in one system are tagged as ONs in another system.</S>
			<S sid ="843" ssid = "33">Therefore, we have to manually check the results.</S>
			<S sid ="844" ssid = "34">We picked 933 sentences at random containing 22,833 words (including 329 PNs, 617 LNs, and 435 ONs) for testing.</S>
			<S sid ="845" ssid = "35">We also did not differentiate LNs and ONs in evaluation.</S>
			<S sid ="846" ssid = "36">That.</S>
			<S sid ="847" ssid = "37">is, we only checked the word boundaries of LNs and ONs and treated both tags as interchangeable.</S>
			<S sid ="848" ssid = "38">The results are shown in Table 22.</S>
			<S sid ="849" ssid = "39">We can see that in this small test set, MSRSeg achieves the best overall performance of NER and the best performance of resolving OASs.</S>
			<S sid ="850" ssid = "40">8.3 Evaluations on Bakeoff Test Sets.</S>
			<S sid ="851" ssid = "41">Table 23 presents the comparison results of MSRSeg on four Bakeoff test sets with others reported previously.</S>
			<S sid ="852" ssid = "42">The layout of the table follows (Peng, Feng, and McCallum 2004).</S>
			<S sid ="853" ssid = "43">SXX indicates participating sites in the 1st SIGHAN International Chinese Word Segmentation Bakeoff (Sproat and Emerson 2003).</S>
			<S sid ="854" ssid = "44">CRFs indicates the word segmenter reported in Peng, Feng, and McCallum (2004), which uses models of linear-chain con 14 The three systems are well known in mainland China, but to our knowledge, no standard evaluations on.</S>
			<S sid ="855" ssid = "45">Chinese word segmentation have been published.</S>
			<S sid ="856" ssid = "46">Although our comparison evaluations are limited to NER and crossing brackets (described later), we think the comparison we draw is still informative.</S>
			<S sid ="857" ssid = "47">568 Table 22 Cross-system comparison results.</S>
			<S sid ="858" ssid = "48"># O AS L N P N O N Seg men ters err or s P R F P R F P R F MS WS 6 3 .93 5 .44 2 .60 0 .90 7 .74 4 .81 8 .64 2 .46 9 .60 0 LC WS 4 9 .85 4 .72 0 .78 2 .94 5 .78 1 .85 6 .71 3 .13 1 .22 2 PB WS 2 0 .76 7 .73 6 .75 2 .78 0 .78 7 .78 4 .81 7 .21 6 .34 2 MS RSe g 7 .87 6 .86 4 .87 0 .83 0 .89 7 .86 2 .79 9 .61 7 .69 6 Table 23 Comparisons against other segmenters: In Column 1, SXX indicates participating sites in the 1st SIGHAN International Chinese Word Segmentation Bakeoff, and CRFs indicates the word segmenter reported in (Peng et al. 2004).</S>
			<S sid ="859" ssid = "49">In Columns 2 to 5, entries contain the F-measure of each segmenter on different open runs, with the best performance in bold.</S>
			<S sid ="860" ssid = "50">Column Site-Avg is the average F-measure over the data sets on which a segmenter reported results of open runs, where a bolded entry indicates the segmenter outperforms MSRSeg.</S>
			<S sid ="861" ssid = "51">Column Our-Avg is the average F-measure of MSRSeg over the same data sets, where a bolded entry indicates that MSRSeg outperforms the other segmenter.</S>
			<S sid ="862" ssid = "52">AS o AS c CT Bo CT Bc H Ko H Kc PK o PK c Site Av g Our Av g S01 .8 81 .8 81 .90 1 .95 3 .95 1 . 9 1 7 . 9 3 0 S02 .9 12 .8 74 . 9 1 2 . 9 0 4 S03 .87 2 .8 29 .88 6 .92 5 . 8 7 8 . 9 4 3 S04 .93 7 .93 9 . 9 3 7 . 9 5 5 S05 .94 2 .7 32 .89 4 S06 .94 5 .8 29 .92 4 .92 4 S07 .94 0 . 9 4 0 . 9 5 5 S08 .95 6 .90 4 .93 8 .93 6 . 9 4 7 . 9 5 5 S09 .96 1 .94 6 S10 .9 01 .8 31 .95 9 .94 7 . 9 3 0 . 9 3 0 S11 .90 4 .8 84 .87 9 .88 6 . 8 8 8 . 9 4 3 S12 .95 9 .91 6 CR Fs .95 7 .95 6 .8 94 .8 49 .94 6 .92 8 .94 6 .94 1 . 9 3 6 . 9 4 3 MS RSe g .95 8 .9 04 .95 4 .95 5 . 9 4 3 ditional random fields (CRFs).</S>
			<S sid ="863" ssid = "53">Entries contain the F-measure of each segmenter on different open runs, indicated by XXo, with the best performance in bold.</S>
			<S sid ="864" ssid = "54">Column Site- Avg is the average F-measure over the data sets on which a segmenter reported results of open runs, where a bolded entry indicates the segmenter outperforms MSRSeg.</S>
			<S sid ="865" ssid = "55">Column Our-Avg is the average F-measure of MSRSeg over the same data sets, where a bolded entry indicates that MSRSeg outperforms the other segmenter.</S>
			<S sid ="866" ssid = "56">For completeness, we also include in Table 23 the results of closed runs, indicated by XXc.</S>
			<S sid ="867" ssid = "57">In a closed test, one can only use training material from the training data for the particular corpus being tested on.</S>
			<S sid ="868" ssid = "58">No other material was allowed (Sproat and Emerson 2003).</S>
			<S sid ="869" ssid = "59">Since MSRSeg uses the MSR corpus for training, our results are of open tests.15 15 It would be more informative if the comparison could be conducted in closed tests, which implies that.</S>
			<S sid ="870" ssid = "60">dictionaries and models of MSRSeg should be generated solely on the given training data.</S>
			<S sid ="871" ssid = "61">We leave this for future work.</S>
			<S sid ="872" ssid = "62">569 Several conclusions can be drawn from Table 23.</S>
			<S sid ="873" ssid = "63">First, for the same system, open tests generally achieve better results than closed tests due to the use of additional training material.16 Second, there is no single segmenter that performs best in all four data sets.</S>
			<S sid ="874" ssid = "64">Third, MSRSeg achieves consistently high performance across all four data sets.</S>
			<S sid ="875" ssid = "65">For example, MSRSeg achieves better average performance than the other three segmenters that report results on all four data sets (i.e., S03, S11, CRF).</S>
			<S sid ="876" ssid = "66">In particular, MSRSeg outperforms them on every data set.</S>
			<S sid ="877" ssid = "67">There are two segmenters that achieve better average F-measure than ours.</S>
			<S sid ="878" ssid = "68">One is S02, which reported results on CTB only.</S>
			<S sid ="879" ssid = "69">The other is S10, which reported results on CTB and PK.</S>
			<S sid ="880" ssid = "70">From these results, we conclude that MSRSeg is an adaptive word segmenter that achieves state- of-the-art performance on different data sets, corresponding to different domains and standards.</S>
			<S sid ="881" ssid = "71">As described in Section 2.1, most segmenters, including the ones in Table 23, can be roughly grouped into two categories: ones that use a rule-based approach and ones that use a statistical approach.</S>
			<S sid ="882" ssid = "72">MSRSeg is a hybrid system that takes advantage of both approaches.</S>
			<S sid ="883" ssid = "73">Though rule-based systems (e.g., S08, S10, and S11 in Table 23) can achieve reasonably good results, they cannot effectively make use of increasingly large training data and are weak in unknown word detection and adaptation.</S>
			<S sid ="884" ssid = "74">Some statistical segmenters (e.g., S01 and S07 in Table 23) use generative models such as HMM for Chinese word segmentation.</S>
			<S sid ="885" ssid = "75">However, it is very difficult to incorporate linguistic knowledge into the (approximated or assumed) generation process of Chinese sentences, underneath which the models are developed.</S>
			<S sid ="886" ssid = "76">Discriminative models (e.g., the linear models in MSRSeg, where though all components models are derived from generative models, they are combined using discriminatively trained weights) are free from this issue and provide a flexible mathematical framework to incorporate arbitrary linguistic knowledge.</S>
			<S sid ="887" ssid = "77">They do not assume any underlying generation process.</S>
			<S sid ="888" ssid = "78">Instead, they assume that the training and test sets are generated from the same distribution, but the form of the distribution (i.e., generative process) is unknown.</S>
			<S sid ="889" ssid = "79">If we view Chinese word segmentation as a classification problem, i.e., to discriminate between “good” segmentations and “bad” ones, we may prefer discriminative models to generative models.</S>
			<S sid ="890" ssid = "80">Intuitively, it is sufficient to find directly the desired features that can differentiate good segmentations from bad ones (as in discriminative models).</S>
			<S sid ="891" ssid = "81">It is, however, not necessary to estimate the distributions based upon which Chinese sentences are generated (or segmentations) first, and then use the estimated distributions to construct the desired features (as in generative models).</S>
			<S sid ="892" ssid = "82">As pointed out by Vapnik (1998): “When solving a given problem, solve it directly and try to avoid solving a more general problem as an intermediate step.” Our models are similar to the maximum entropy models in Xue (2003) and CRFs in Peng, Feng, and McCallum (2004) in that all these models give the flexibility to incorporate arbitrary features and can be discriminatively trained.</S>
			<S sid ="893" ssid = "83">Our models are novel in that many feature functions are derived from probabilistic or heuristic models inspired by source–channel models of Chinese sentence generation, as described in Section 4.3.</S>
			<S sid ="894" ssid = "84">Therefore, these feature functions are not only potentially more reasonable but also much more informative than, for instance, the binary features used in standard maximum entropy models in NLP.</S>
			<S sid ="895" ssid = "85">16 It is interesting to see that, in AS, close tests achieve better performance than open tests, although among.</S>
			<S sid ="896" ssid = "86">different systems.</S>
			<S sid ="897" ssid = "87">This is because the training data of AS is much larger than the other three corpora, and those segmenters that apply statistical approaches, such as S09 (Xue 2003) and CRFs, have been well trained.</S>
			<S sid ="898" ssid = "88">570 We also notice that many segmenters (e.g., S03 and S04 in Table 23) separate unknown word detection from word segmentation.</S>
			<S sid ="899" ssid = "89">Though this would make the development of the segmenter easier, it seems to be a flawed solution in reality, as we discussed earlier.</S>
			<S sid ="900" ssid = "90">The benefits of integrating both tasks has also been shown empirically in Table 23.</S>
	</SECTION>
	<SECTION title="Conclusions. " number = "9">
			<S sid ="901" ssid = "1">This article presents a pragmatic approach to Chinese word segmentation.</S>
			<S sid ="902" ssid = "2">Our main contributions are threefold.</S>
			<S sid ="903" ssid = "3">First, we view Chinese words as segmentation units whose definition is pragmatic in nature and depends on how they are used and processed (differently) in realistic applications, while theoretical linguists define words using purely linguistic criteria.</S>
			<S sid ="904" ssid = "4">Second, we propose a pragmatic mathematical framework for Chinese word segmentation, where various problems of word segmentation (i.e., word breaking, morphological analysis, factoid detection, NER, and NWI) are solved in a unified approach.</S>
			<S sid ="905" ssid = "5">The approach is based on linear models where component models are inspired by source–channel models of Chinese sentence generation.</S>
			<S sid ="906" ssid = "6">Third, we describe in detail an adaptive Chinese word segmenter, MSRSeg.</S>
			<S sid ="907" ssid = "7">This pragmatic system consists of two components: (1) a generic segmenter that is based on the mathematical framework of word segmentation and unknown word detection, and that can adapt to different domain-specific vocabularies, and (2) a set of output adaptors for adapting the output of the former to different application-specific standards.</S>
			<S sid ="908" ssid = "8">Evaluation on five test sets with different standards shows that the adaptive system achieves state-of-the-art performance on all the test sets.</S>
			<S sid ="909" ssid = "9">One area of our future work is to apply MSRSeg in a wide range of practical applications.</S>
			<S sid ="910" ssid = "10">We believe that some application-specific features can also be integrated into the framework.</S>
			<S sid ="911" ssid = "11">For instance, in MT, it would be interesting to investigate how to jointly optimize the performances of both word segmentation and word alignment.</S>
			<S sid ="912" ssid = "12">As one of the reviewers pointed out, though the reliable high performance of MSRSeg is impressive, it is by far one of the most complex systems with access to the richest resources.</S>
			<S sid ="913" ssid = "13">Hence, another interesting area of our future work is to explore whether the performance is attributed to a superior architecture or simply to the richer resources.</S>
			<S sid ="914" ssid = "14">We have developed a simplified version of MSRSeg, called S-MSRSeg.</S>
			<S sid ="915" ssid = "15">It does not use the morph-lexicon and is trained using one-fifth of the MSR training data in Table 4, which are only partially labeled (i.e., LWs are not annotated).</S>
			<S sid ="916" ssid = "16">Interestingly, S-MSRSeg achieves very similar (or slightly worse) performance on the five test sets in Table 4.</S>
			<S sid ="917" ssid = "17">This demonstrates again the potential of our pragmatic approach to Chinese word segmentation.</S>
			<S sid ="918" ssid = "18">The work reported in this article represents not an end but a beginning of yet another view of Chinese word segmentation.</S>
			<S sid ="919" ssid = "19">Toward this end, S-MSRSeg and its training and test data sets are publicly available (e.g., at http://research.microsoft.com/∼jfgao) for the sake of encouraging others to improve upon the work we have carried out.</S>
	</SECTION>
	<SECTION title="Acknowledgments">
			<S sid ="920" ssid = "20">The work reported in this article was a team effort.</S>
			<S sid ="921" ssid = "21">The number of people intimately involved in this project is far too large for us to enumerate here.</S>
			<S sid ="922" ssid = "22">We only name a few now.</S>
			<S sid ="923" ssid = "23">We thank the manager teams of the NLC group at MSRA and the NLG at NISD, especially Ming Zhou, HongJiang Zhang, Jun Liu, and KaiFu Lee, for initiating and funding the project.</S>
			<S sid ="924" ssid = "24">We thank Ashley Chang, Hongqiao Li, Jianfeng Li, Jianghong Li, Haowei Qin, Jian Sun, Xinsong Xia, Wenfeng Yang, Ye Zhang, and Xiaodan Zhu for their help in the experimentation and evaluation of our system, and for data annotation.</S>
			<S sid ="925" ssid = "25">We also thank John Chen, Nianwen Xue, 571 Richard Sproat, Keh Yi Su, Hisami Suzuki, and the three anonymous reviewers for their comments on early drafts of this article.</S>
	</SECTION>
</PAPER>
