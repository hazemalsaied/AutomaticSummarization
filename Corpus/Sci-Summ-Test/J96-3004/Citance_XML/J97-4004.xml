<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">Tokenization is the process of mapping sentences from character strings into strings of words.</S>
		<S sid ="2" ssid = "2">This paper sets out to study critical tokenization, a distinctive type of tokenization following the principle of maximum tokenization.</S>
		<S sid ="3" ssid = "3">The objective in this paper is to develop its mathematical description and understanding.</S>
		<S sid ="4" ssid = "4">The main results are as follows: (1) Critical points are all and only unambiguous tokett boundaries for any character string on a complete dictionary; (2) Any critically tokenized word string is a minimal element in the partially ordered set of all tokenized word strings with respect to the word string cover relation; (3) Any tokenized string can be reproduced from a critically tokenized word string but not vice versa; ( 4) Critical tokenization forms the sound mathemati­ cal foundation for categorizing tokenization ambiguity into critical and hidden types, a precise mathematical understanding of conventional concepts like combinational and overlapping ambi­ guities; (5) Many important maximum tokenization variations, such as forward and backward maximum matching and shortest tokenization, are all true subclasses of critical tokenization.</S>
		<S sid ="5" ssid = "5">It is believed that critical tokenization provides a precise mathematical description of the principle of maximum tokenization.</S>
		<S sid ="6" ssid = "6">Important implications and practical applications of critical tokenization in effective ambiguity resolution and in efficient tokenization implementation are also carefully examined.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="7" ssid = "7">Words, and tokens in general, are the primary building blocks in almost all linguistic theories (e.g., Gazdar, Klein, Pullum, and Sag 1985; Hudson 1984) and language pro­ cessing systems (e.g., Allen 1995; Grosz, Jones, and Webber 1986).</S>
			<S sid ="8" ssid = "8">Sentence, or string, tokenization, the process of mapping sentences from character strings to strings of words, is the initial step in natural language processing (Webster and Kit 1992).</S>
			<S sid ="9" ssid = "9">Since in written Chinese there is no explicit word delimiter (equivalent to the blank space in written English), the problem of Chinese sentence tokenization has been the focus of considerable research efforts, and significant advancements have been made (e.g., Bai 1995; Zhang et al. 1994; Chen and Liu 1992; Chiang et al. 1992; Fan and Tsai 1988; Gan 1995; Gan, Palmer, and Lua 1996; Guo 1993; He, Xu, and Sun 1991; Huang 1989; Huang and Xia 1996; Jie 1989; Jie, Liu, and Liang 1991a, 1991b; Jin and Chen 1995; Lai et al. 1992; Li et al. 1995; Liang 1986, 1987, 1990; Liu 1986a, 1986b; Liu, Tan, and Shen 1994; Lua 1990, 1994, and 1995; Ma 1996; Nie, Jin, and Hannan 1994; Sproat and Shih 1990; Sproat et al. 1996; Sun and T&apos;sou 1995; Sun and Huang 1996; Tung and Lee 1994; Wang, Su, and Mo 1990; Wang 1989; Wang, Wang, and Bai 1991; Wong et al. 1995; Wong et al. 1994; Wu et al. 1994; Wu and Su 1993; Yao, Zhang, and Wu 1990; Yeh and Lee 1991; Zhang, Chen, and Chen 1991).</S>
			<S sid ="10" ssid = "10">* Institute of Systems Science, National University of Singapore, Kent Ridge, Singapore 119597; email: guojin@iss.nns.sg © 1997 Association for Computational Linguistics The tokenization problem exists in almost all natural languages, including Japanese (Yosiyuki, Takenobu, and Hozumi 1992), Korean (Yun, Lee, and Rim 1995), German (Pachunke et al. 1992), and English (Garside, Leech, and Sampson 1987), in various media, such as continuous speech and cursive handwriting, and in numerous appli­ cations, such as translation, recognition, indexing, and proofreading.</S>
			<S sid ="11" ssid = "11">For Chinese, sentence tokenization is still an unsolved problem, which is in part due to its overall complexity but also due to the lack of a good mathematical de­ scription and understanding of the problem.</S>
			<S sid ="12" ssid = "12">The theme in this paper is therefore to develop such a mathematical description.</S>
			<S sid ="13" ssid = "13">In particular, this paper focuses on critical tokenization1 a distinctive type of tokenization following the maximum principle.</S>
			<S sid ="14" ssid = "14">What is to be established in this paper is the notion of critical tokenization itself, together with its precise descriptions and well-proved properties.</S>
			<S sid ="15" ssid = "15">We will prove that critical points are all and only unambiguous token boundaries for any character string on a complete dictionary.</S>
			<S sid ="16" ssid = "16">We will show that any critically to­ kenized word string is a minimal element in the partially ordered set of all tokenized word strings on the word string cover relation.</S>
			<S sid ="17" ssid = "17">We will also show that any tokenized string can be reproduced from a critically tokenized word string but not vice versa.</S>
			<S sid ="18" ssid = "18">In other words, critical tokenization is the most compact representation of tokenization.</S>
			<S sid ="19" ssid = "19">In addition, we will show that critical tokenization forms a sound mathematical foun­ dation for categorizing critical ambiguity and hidden ambiguity in tokenizations, which provides a precise mathematical understanding of conventional concepts like combinational and overlapping ambiguities.</S>
			<S sid ="20" ssid = "20">Moreover, we will confirm that some im­ portant maximum tokenization variations, such as forward and backward maximum matching and shortest tokenization, are all subclasses of critical tokenization.</S>
			<S sid ="21" ssid = "21">Based on a mathematical understanding of tokenization, we reported, in Guo (1997), a series of interesting findings.</S>
			<S sid ="22" ssid = "22">For instance, there exists an optimal algorithm that can identify all and only critical points, and thus all unambiguous token bound­ aries, in time proportional to the input character string length but independent of the size of the tokenization dictionary.</S>
			<S sid ="23" ssid = "23">Tested on a representative corpus, about 98% of the critical fragments generated are by themselves desired tokens.</S>
			<S sid ="24" ssid = "24">In other words, about 98% dose-dictionary tokenization accuracy can be achieved efficiently without disambiguation.</S>
			<S sid ="25" ssid = "25">Another interesting finding is that, for those critical fragments with critical ambi­ guities, by replacing the conventionally adopted meaning preservation criterion with the critical tokenization criterion, disagreements among (human) judges on the ac­ ceptability of a tokenization basically become nonexistent.</S>
			<S sid ="26" ssid = "26">Consequently, an objective (human) analysis and annotation of all (critical) tokenizations in a corpus becomes achievable, which in turn leads to some important observations.</S>
			<S sid ="27" ssid = "27">For instance, we ob­ served from a Chinese corpus of four million morphemes a very strong tendency to have one tokenization per source.</S>
			<S sid ="28" ssid = "28">Naturally, this observation suggests tokenization disam­ biguation strategies notably different from the mainstream best-path-finding strategy.</S>
			<S sid ="29" ssid = "29">For instance, the simple strategy of tokenization by memorization alone could easily ex­ hibit critical ambiguity resolution accuracy of no less than 90%, which is notably higher than what has been achieved in the literature.</S>
			<S sid ="30" ssid = "30">Moreover, it has been observed that crit­ ical tokenization can also provide helpful guidance in identifying hidden ambiguities and in determining unregistered (unknown) tokens (Guo 1997).</S>
			<S sid ="31" ssid = "31">While these are just some of the very primitive findings, they are nevertheless promising and motivate 1 All terms mentioned here will be precisely defined later in this paper..</S>
			<S sid ="32" ssid = "32">us to rigorously formalize the tokenization problem and to carefully explore logical consequences.</S>
			<S sid ="33" ssid = "33">The rest of the paper is organized as follows: In Section 2, we formally define the string generation and tokenization operations that form the basis of our frame­ work.</S>
			<S sid ="34" ssid = "34">In Section 3, we will study tokenization ambiguities and explore the concepts of critical points and critical fragments.</S>
			<S sid ="35" ssid = "35">In Section 4, we define the word string cover relation and prove it to be a partial order, define critical tokenization as the set of min­ imal elements of the tokenization partially ordered set, and illustrate the relationship between critical tokenization and string tokenization.</S>
			<S sid ="36" ssid = "36">Section 5 discusses the relation­ ship between critical tokenization and various types of tokenization ambiguities, while Section 6 addresses the relationship between critical tokenization and various types of maximum tokenizations.</S>
			<S sid ="37" ssid = "37">Finally, in Sections 7 and 8, after discussing some helpful implications of critical tokenization in effective tokenization disambiguation and in efficient tokenization implementation, we suggest areas for future research and draw some conclusions.</S>
	</SECTION>
	<SECTION title="Generation and Tokenization. " number = "2">
			<S sid ="38" ssid = "1">In order to address the topic clearly and accurately, a precise and well-defined formal notation is required.</S>
			<S sid ="39" ssid = "2">What is used in this paper is primarily from elementary Boolean algebra and Formal Language Theory, which can be found in most graduate-level textbooks on discrete mathematics.</S>
			<S sid ="40" ssid = "3">This section aims at refreshing several simple terms and conventions that will be applied throughout this paper and at introducing the two new concepts of character string generation and tokenization.</S>
			<S sid ="41" ssid = "4">For the remaining basic concepts and conventions, we mainly follow Aho and Ullman (1972, Chapter 0, Mathematical Preliminaries), and Kolman and Busby (1987).</S>
			<S sid ="42" ssid = "5">2.1 Character, Alphabet, and Character String.</S>
			<S sid ="43" ssid = "6">Definition 1 An alphabet I: = {a,b,c, ...}</S>
			<S sid ="44" ssid = "7">is a finite set of symbols.</S>
			<S sid ="45" ssid = "8">Each symbol in the alphabet is a character.</S>
			<S sid ="46" ssid = "9">The alphabet size is the number of characters in the alphabet and is denoted II:I. Character strings over an alphabet I: are defined2 in the following manner: 1.</S>
			<S sid ="47" ssid = "10">e is a character string over . e is called the empty character string.</S>
			<S sid ="48" ssid = "11">2.</S>
			<S sid ="49" ssid = "12">If S is a character string over and a is a character in I:, then Sa is a. character string over I:.</S>
			<S sid ="50" ssid = "13">3.</S>
			<S sid ="51" ssid = "14">S&apos; is a character string over I: if and only if its being so follows from (1) and (2).</S>
			<S sid ="52" ssid = "15">The length of a character string S is the number of characters in the string and is denoted lSI.</S>
			<S sid ="53" ssid = "16">A position in a character string is the position after a character in the string.</S>
			<S sid ="54" ssid = "17">If characters in a character string are indexed from 1 to n, then positions in the string are indexed from 0 to n, with 0 for the position before the first character and n for that after the last character.</S>
			<S sid ="55" ssid = "18">2 This definition is adapted from Aho and Ullman (1972, 15)..</S>
			<S sid ="56" ssid = "19">Example 1 The set of 26 upper case and 26 lower case English characters forms the English alphabet &apos;E = {a,b, ...,z,A,B,.</S>
			<S sid ="57" ssid = "20">,Z}.</S>
			<S sid ="58" ssid = "21">5 = thisishisbook is a character string over the alphabet.</S>
			<S sid ="59" ssid = "22">Its string length is 13.</S>
			<S sid ="60" ssid = "23">In this paper, characters are represented with small characters a, b, c, or their subscript form ab bb and ck.</S>
			<S sid ="61" ssid = "24">The capital letter 5 or its expanded form 5 = c1 ...</S>
			<S sid ="62" ssid = "25">Cn is used to represent a character string.</S>
			<S sid ="63" ssid = "26">We let &apos;E* denote the set containing all character strings over &apos;E including e, and I;+ denote the set of all character strings over &apos;E but excluding e. 2.2 Word, Dictionary, and Word String.</S>
			<S sid ="64" ssid = "27">Definition 2 Let alphabet &apos;E = {a,b,c, ...}</S>
			<S sid ="65" ssid = "28">be a finite set of characters.</S>
			<S sid ="66" ssid = "29">A dictionary D is a set of character strings over the alphabet &apos;E.</S>
			<S sid ="67" ssid = "30">That is, D = { x, y,z, ...}</S>
			<S sid ="68" ssid = "31">&apos;E*.</S>
			<S sid ="69" ssid = "32">Any element in the dictionary is a word.</S>
			<S sid ="70" ssid = "33">The dictionary size is the number of words in the dictionary and is denoted jDj.</S>
			<S sid ="71" ssid = "34">Word strings over a dictionary 0 are defined in the following manner: 1.</S>
			<S sid ="72" ssid = "35">v is a word string over D. v is called the empty word string.</S>
			<S sid ="73" ssid = "36">2.</S>
			<S sid ="74" ssid = "37">If W is a word string over D and w is a word in D, then Ww is a word.</S>
			<S sid ="75" ssid = "38">string over D. 3.</S>
			<S sid ="76" ssid = "39">W&apos; is a word string over D if and only if its being so follows from (1) and (2).</S>
			<S sid ="77" ssid = "40">The length of a word string W is the number of words in the string and is denoted !WI.</S>
			<S sid ="78" ssid = "41">We let D* denote the set containing all word strings over D, including v and let D+ denote the set of all word strings over D but excluding v. Example 1 (cont.)</S>
			<S sid ="79" ssid = "42">The set D = {this, is, his, book} is a tiny English dictionary from the English alphabet.</S>
			<S sid ="80" ssid = "43">Both his and book are words over the English alphabet.</S>
			<S sid ="81" ssid = "44">The dictionary size is 4, i.e., IDI = 4.</S>
			<S sid ="82" ssid = "45">&quot;this is his book&quot; is a word string.</S>
			<S sid ="83" ssid = "46">Its string length is 4.</S>
			<S sid ="84" ssid = "47">To differentiate between character string and word string, blank spaces are added between words in word strings.</S>
			<S sid ="85" ssid = "48">For example, &quot;this is his book&quot; represents a word string of length 4 (four words concatenated) while thisishisbook consists of a character string of length 13 (13 characters in sequence).</S>
			<S sid ="86" ssid = "49">Slash I is sometimes used as a (hidden) word delimiter.</S>
			<S sid ="87" ssid = "50">For instance, thisjis/hisjbook is an equivalent representation to &quot;this is his book&quot;.</S>
			<S sid ="88" ssid = "51">Generally, capital letters X, Y, Z, and W, or their expanded forms such as W = w1 ...Wm, represent word strings.</S>
			<S sid ="89" ssid = "52">Small letters x, y, z, and w, or their expanded forms such as w = c1 ...</S>
			<S sid ="90" ssid = "53">Cn, represent both words as elements in a dictionary and character strings over an alphabet.</S>
			<S sid ="91" ssid = "54">In other words, they are both w E D and w E &apos;E*.</S>
			<S sid ="92" ssid = "55">The word string made up of the single word w alone is represented by w1 In cases where context makes it clear, the superscript can be omitted and w is also used for representing the single word string w1 2.3 Character String Generation.</S>
			<S sid ="93" ssid = "56">Definition 3 Let E = {a,b,c, ...}</S>
			<S sid ="94" ssid = "57">be an alphabet and D = {x, y,z, ...}</S>
			<S sid ="95" ssid = "58">be a dictionary over the alphabet.</S>
			<S sid ="96" ssid = "59">The character string generation operation G is a mapping G: D* --+ E* defined as: 1.</S>
			<S sid ="97" ssid = "60">Empty word string v is mapped to empty character string e. That is,.</S>
			<S sid ="98" ssid = "61">G(v) =e. 2.</S>
			<S sid ="99" ssid = "62">Single word string w1 is mapped to the character string of the single.</S>
			<S sid ="100" ssid = "63">word.</S>
			<S sid ="101" ssid = "64">That is, G(w 1 = w. word string Ww is mapped to the concatenation of character string G(W) and G(w).</S>
			<S sid ="102" ssid = "65">That is, G(Ww) = G(W)G(w).</S>
			<S sid ="103" ssid = "66">G(W) is said to be the generated character string of the word string W from dictio­ nary D. Note that the character string generation operation G is a homomorphism (Aho and Ullman 1972, 17) with property G(w1 = w. Example 1 (cont.)</S>
			<S sid ="104" ssid = "67">The character string thisishisbook is the generated character string of the word string &quot;this is his book&quot;.</S>
			<S sid ="105" ssid = "68">That is, G(&quot;this is his book&quot;) = thisishisbook.</S>
			<S sid ="106" ssid = "69">2.4 Character String Tokenization.</S>
			<S sid ="107" ssid = "70">Definition 4 The character string tokenization operation T is a mapping T 0: E* --+ 2°* defined as: if S is a character string in E*, then T 0 (S) is the set of dictionary word strings mapped by the character string generation operation G to the character string S. That is, T 0 (S) = {WIG(W) = S, WED*}.</S>
			<S sid ="108" ssid = "71">Any word string Win T 0 (S) is a tokenized word string, or simply a tokenization, of the character string S. Sometimes the character string tokenization operation is emphasized as the ex­ haustive tokenization operation or ET operation for short.</S>
			<S sid ="109" ssid = "72">In addition, the tokenized word string or tokenization is emphasized as the exhaustively tokenized word string or exhaustive tokenization or ET tokenization for short.</S>
			<S sid ="110" ssid = "73">Note that the character string tokenization operation T 0 is the inverse homomorphism (Aho and Ullman 1972, 18) of the character string generation operation G. Example 1 (cont.)</S>
			<S sid ="111" ssid = "74">Given character string thisishisbook, for the tiny English dictionary D = {this, is, his, book}, there is T 0 (thisishisbook) ={&quot;this is his book&quot;}.</S>
			<S sid ="112" ssid = "75">In other words, the word string &quot;this is his book&quot; is the only tokenization over the dictionary D. Given dictionary D&apos; = {th, this, is, his, book}, in which this also a word, there is To,(thisishisbook) ={&quot;this is his book&quot;, &quot;this is his book&quot;}.</S>
			<S sid ="113" ssid = "76">In other words, the character string has two tokenizations over the dictionary D&apos;.</S>
			<S sid ="114" ssid = "77">Example 2 For character string fundsand and the tiny English dictionary D = {fund ,funds,and, sand}, there is T 0 (fundsand) ={&quot;funds and&quot;, &apos;&apos;fund sand&quot;}.</S>
			<S sid ="115" ssid = "78">In other words, both &apos;&apos;funds and&quot; and &apos;fund sand&quot; are tokenizations of character string fundsand.</S>
			<S sid ="116" ssid = "79">2.5 Discussion.</S>
			<S sid ="117" ssid = "80">Our intention, in formally defining characters and words, is to establish our mathe­ matical system clearly and accurately.</S>
			<S sid ="118" ssid = "81">To keep discussion concise, the definitions of elementary concepts such as strings and substrings, although widely used in this pa­ per, will be taken for granted.</S>
			<S sid ="119" ssid = "82">We limit our basic notion to what has already been defined in Aho and Ullman (1972) and Kolman and Busby (1987).</S>
			<S sid ="120" ssid = "83">Mathematically, word strings are nothing but symbol strings, with each symbol representing a word in the dictionary.</S>
			<S sid ="121" ssid = "84">In that sense, the word string definition is redundant as it is already covered by the definition of character string.</S>
			<S sid ="122" ssid = "85">However, since the relationships between character strings and word strings are very important in this paper, we believe it to be appropriate to list both definitions explicitly.</S>
			<S sid ="123" ssid = "86">What is new in this section is mathematical definitions for character string genera­ tion and tokenization.</S>
			<S sid ="124" ssid = "87">We consider them fundamental to our mathematical description of the string tokenization problem.</S>
			<S sid ="125" ssid = "88">There are two points worth highlighting here.</S>
			<S sid ="126" ssid = "89">The first relates to the introduction of the character string generation operation.</S>
			<S sid ="127" ssid = "90">In the literature, the tokenization problem is normally modeled independently with no connection whatsoever with the charac­ ter string generation problem.</S>
			<S sid ="128" ssid = "91">By contrast, we model tokenization and generation as inverse problems to each other.</S>
			<S sid ="129" ssid = "92">In this way, we establish a well-defined mathematical system consisting of an alphabet, a dictionary, and the (generation) homomorphism (operation) and its inverse defined on the alphabet and dictionary.</S>
			<S sid ="130" ssid = "93">As will be seen throughout this paper, the establishment of the generation operation renders various types of tokenization problems easy to describe.</S>
			<S sid ="131" ssid = "94">The generation problem is relatively simple and easy to manage, so any modeling of the tokenization problem as its inverse (that is, as the generation problem) should make it more tractable.</S>
			<S sid ="132" ssid = "95">The second point is in regard to the tokenization definition.</S>
			<S sid ="133" ssid = "96">In the literature, the string tokenization operation is normally required to generate a unique tokenized word string.</S>
			<S sid ="134" ssid = "97">Following such a definition of tokenization, introducing tokenization disam­ biguation at the very beginning is inevitable.</S>
			<S sid ="135" ssid = "98">We believe this to be a pitfall that has trapped many researchers.</S>
			<S sid ="136" ssid = "99">In contrast, we define the character string tokenization op­ eration as the inverse operation (inverse homomorphism) of the character string gen­ eration operation (homomorphism).</S>
			<S sid ="137" ssid = "100">Naturally, the result of the tokenization operation is a set of tokenizations rather than a single word string.</S>
			<S sid ="138" ssid = "101">Such treatment suggests that we could use the divide-and-conquer problem-solving strategy-to decompose the complex string tokenization problem into several smaller and, hopefully, simpler subproblems.</S>
			<S sid ="139" ssid = "102">That is the basis of our two-stage, five-step iterative problem-solving strategy for sentence tokenization (Guo 1997).</S>
	</SECTION>
	<SECTION title="Critical Point and Fragment. " number = "3">
			<S sid ="140" ssid = "1">After clarifying both sentence generation and tokenization operations, we undertake next to further clarify sentence tokenization ambiguities.</S>
			<S sid ="141" ssid = "2">Among all the concepts to be introduced, critical points and critical fragments are probably two of the most important.</S>
			<S sid ="142" ssid = "3">We will prove that, for any character string on a c&apos;omplete tokenization dictionary, its critical points are all and only unambiguous token boundaries, and its critical fragments are the longest substrings with all inner positions ambiguous.</S>
			<S sid ="143" ssid = "4">3.1 Ambiguity.</S>
			<S sid ="144" ssid = "5">Let be an alphabet, D a dictionary, and 5 a character string over the alphabet.</S>
			<S sid ="145" ssid = "6">Definition 5 The character string S from the alphabet I; has tokenization ambiguity on dictionary D, if JTv(S)J &gt; 1.</S>
			<S sid ="146" ssid = "7">S has no tokenization ambiguity, if JTv(S)J = 1.</S>
			<S sid ="147" ssid = "8">Sis ill-formed on dictionary D, if JTv(S)J = 0.</S>
			<S sid ="148" ssid = "9">A tokenization WE T 0 (S) has tokenization ambiguity, if there exists another tokenization W&apos; E Tv(S), W&apos; -1- W. Example 2 (cont.)</S>
			<S sid ="149" ssid = "10">Since Tv(fundsand) = {&apos;&apos;funds and&quot;, &apos;fund sand&quot;}, i.e., ITv(fundsand)l = 2 &gt; 1, the character string fundsand has tokenization ambiguity.</S>
			<S sid ="150" ssid = "11">In other words, it is ambiguous in tokenization.</S>
			<S sid ="151" ssid = "12">Moreover, the tokenization &apos;funds and&quot; has tokenization ambiguity since there exists another possible tokenization &apos;fund sand&quot; for the same character string.</S>
			<S sid ="152" ssid = "13">This definition is quite intuitive.</S>
			<S sid ="153" ssid = "14">If a character string could be tokenized in multiple ways, it would be ambiguous in tokenization.</S>
			<S sid ="154" ssid = "15">If a character string could only be tokenized in a unique way, it would have no tokenization ambiguity.</S>
			<S sid ="155" ssid = "16">If a character string could not be tokenized at all, it would be ill-formed.</S>
			<S sid ="156" ssid = "17">In this latter case, the dictionary is incomplete.</S>
			<S sid ="157" ssid = "18">Intuitively, a position in a character string is ambiguous in tokenization or is an ambiguous token boundary if it is a token boundary in one tokenization but not in another.</S>
			<S sid ="158" ssid = "19">Formally, let 5 = c1 ...Cn be a character string over an alphabet I; and let D be a dictionary over the alphabet.</S>
			<S sid ="159" ssid = "20">Definition 6 Position p has tokenization ambiguity or is an ambiguous token boundary, if there are two tokenizations X = X1 ...</S>
			<S sid ="160" ssid = "21">X5 and Y = Y1 ... y1 in Tv(5), such that G(x1 ... xu) = c1 ...</S>
			<S sid ="161" ssid = "22">Cp and G(xu+1 ...</S>
			<S sid ="162" ssid = "23">Xs) = Cp+l ...Cn for some index u, and for any index v, there is neither G(y1 ..·Yv) = CJ ..</S>
			<S sid ="163" ssid = "24">.Cp nor G(Yv+1·.</S>
			<S sid ="164" ssid = "25">·Yt) = Cp+1· ..</S>
			<S sid ="165" ssid = "26">en.</S>
			<S sid ="166" ssid = "27">Otherwise, the position has no tokenization ambiguity, or is an unambiguous token boundary.</S>
			<S sid ="167" ssid = "28">Example 1 (cont.)</S>
			<S sid ="168" ssid = "29">Given a typical English dictionary and the character string 5 = thisishisbook, all three positions after character s are unambiguous in tokenization or are unambiguous to­ ken boundaries, since all possible tokenizations must take these positions as token boundaries.</S>
			<S sid ="169" ssid = "30">Example 2 (cont.)</S>
			<S sid ="170" ssid = "31">Given a typical English dictionary and the character stringS= fundsand, the position after the middle character s is ambiguous in tokenization or is an ambiguous token boundary since it is a token boundary in tokenization &apos;funds and&quot; but not in another tokenization &apos;fund sand&quot;.</S>
			<S sid ="171" ssid = "32">3.2 Complete Dictionary.</S>
			<S sid ="172" ssid = "33">To avoid ill-formedness in sentence tokenization, we now introduce the concept of a complete tokenization dictionary.</S>
			<S sid ="173" ssid = "34">Definition 7 A dictionary D over an alphabet I; is complete if for any character string S from the alphabet, 5 E I;*, there is JTv(5)J 1.</S>
			<S sid ="174" ssid = "35">That is, for any character string S = c1 ...</S>
			<S sid ="175" ssid = "36">Cn from the alphabet, there exists at least one word string W = w1 ...Wm with S as its generated character string, G(W) = S. Theorem 1 A dictionary D over an alphabet is complete if and only if all the characters in the alphabet are single-character words in the dictionary.</S>
			<S sid ="176" ssid = "37">Proof On the one hand, every single character is also a character string (of length 1).</S>
			<S sid ="177" ssid = "38">To ensure that such a single-character string is being tokenized, the single character must be a word in the dictionary.</S>
			<S sid ="178" ssid = "39">On the other hand, if all the characters are words in the dictionary, any character string can at least be tokenized as a string of single-character words.</S>
			<S sid ="179" ssid = "40">D Theorem 1 spells out a simple way of making any dictionary complete, which calls for adding all the characters of an alphabet into a dictionary as single-character words.</S>
			<S sid ="180" ssid = "41">This is referred to as the dictionary completion process.</S>
			<S sid ="181" ssid = "42">If not specified otherwise, in this paper, when referring to a complete dictionary or tokenization dictionary, we mean the dictionary after the completion process.</S>
			<S sid ="182" ssid = "43">3.3 Critical Point and Fragment.</S>
			<S sid ="183" ssid = "44">Let S = c1 ...Cn be a character string over the alphabet and let D be a dictionary over the alphabet.</S>
			<S sid ="184" ssid = "45">In addition, let To(S) be the tokenization set of Son D. Definition 8 Position p in character string S = c1 ...</S>
			<S sid ="185" ssid = "46">Cn is a critical point, if for any word string W = w1 ...Wm in To(S), there exists an index k, 0 s; k :S m, such that G(w1 ... wk) = c1 ...</S>
			<S sid ="186" ssid = "47">Cp and G(wk+l ...Wm) = Cp+l ...</S>
			<S sid ="187" ssid = "48">Cn.</S>
			<S sid ="188" ssid = "49">In particular, the starting position 0 and the ending position n are the two ordinary critical points.</S>
			<S sid ="189" ssid = "50">Substring Cp+l ...cq is a critical fragment of S on D, if both p and q are critical points and any other position r in between them, p &lt; r &lt; q, is not a critical point.</S>
			<S sid ="190" ssid = "51">Example 1 (cont.)</S>
			<S sid ="191" ssid = "52">Given a typical English dictionary, there are five critical points in the character string S = thisishisbook.</S>
			<S sid ="192" ssid = "53">They are 0, 4, 6, 9, and 13.</S>
			<S sid ="193" ssid = "54">The corresponding four critical fragments are this, is, his, and book.</S>
			<S sid ="194" ssid = "55">Example 2 (cont.)</S>
			<S sid ="195" ssid = "56">Given a typical English dictionary, there is no extraordinary critical point in the char­ acter string S = fundsand.</S>
			<S sid ="196" ssid = "57">It is by itself the only critical fragment of this character string.</S>
			<S sid ="197" ssid = "58">Given a complete tokenization dictionary, it is obvious that all single-character crit­ ical fragments or, more generally, single-character strings, possess unique tokenization.</S>
			<S sid ="198" ssid = "59">That is, they possess neither ambiguity nor ill-formedness in tokenization.</S>
			<S sid ="199" ssid = "60">However, the truth of the statement below (Lemma 1) is less obvious.</S>
			<S sid ="200" ssid = "61">Lemma 1 For a complete tokenization dictionary, all multicharacter critical fragments and all of their inner positions are ambiguous in tokenization.</S>
			<S sid ="201" ssid = "62">Proof Let S = c1 ...en, n &gt; 1, be a multicharacter critical fragment.</S>
			<S sid ="202" ssid = "63">Because the tokenization dictionary is complete, the critical fragment can at least be tokenized as a string of single-character words.</S>
			<S sid ="203" ssid = "64">On the other hand, because it is a critical fragment, for any position p, 1 ::; p ::; n - 1, there must exist a tokenization W = Wt ...Wm in To(S) such that for any index k, 0 ::; k ::; m, there is neither G(w1 ...wk) = c1 ...</S>
			<S sid ="204" ssid = "65">Cp nor G(wk+l ... wm) = Cp+l ...</S>
			<S sid ="205" ssid = "66">Cn.</S>
			<S sid ="206" ssid = "67">As this tokenization differs from the above-mentioned tokenization of the string of single-character words, the critical fragment has at least two different tokenizations and thus has tokenization ambiguity.</S>
			<S sid ="207" ssid = "68">0 Theorem 2 For any character string on a complete tokenization dictionary, its critical points are all and only unambiguous token boundaries.</S>
			<S sid ="208" ssid = "69">Proof By Lemma 1, all positions within critical fragments are ambiguous in tokenization.</S>
			<S sid ="209" ssid = "70">By Definition 8, critical points are unambiguous in tokenization.</S>
			<S sid ="210" ssid = "71">o Corollary For any character string on a complete tokenization dictionary, its critical fragments are the longest substrings with all inner positions ambiguous.</S>
			<S sid ="211" ssid = "72">Proof By Theorem 2.</S>
			<S sid ="212" ssid = "73">0 3.4 Discussion.</S>
			<S sid ="213" ssid = "74">In this section, we have described sentence tokenization ambiguity from three differ­ ent angles: character strings, tokenizations, and individual string positions.</S>
			<S sid ="214" ssid = "75">The basic idea is conceptually simple: ambiguity exists when there are different means to the same end.</S>
			<S sid ="215" ssid = "76">For instance, as long as a character string has multiple tokenizations, it is ambiguous.</S>
			<S sid ="216" ssid = "77">This description of ambiguity is complete.</S>
			<S sid ="217" ssid = "78">Given a character string and a dic­ tionary, it is always possible to answer deterministically whether or not a string is ambiguous in tokenization.</S>
			<S sid ="218" ssid = "79">Conceptually, for any character string, by checking every one of its possible substrings in a dictionary, and then by enumerating all valid word concatenations, all word strings with the character string as their generated character string can be produced.</S>
			<S sid ="219" ssid = "80">Just counting the number of such word strings will provide the answer to whether or not the character string is ambiguous.</S>
			<S sid ="220" ssid = "81">Some researchers question the validity of the complete dictionary assumption.</S>
			<S sid ="221" ssid = "82">Here we argue that, even in the strictest linguistic sense, there exists no single character that cannot be used as a single-character word in sentences.</S>
			<S sid ="222" ssid = "83">In any case, any natural language must allow us to directly refer to single characters.</S>
			<S sid ="223" ssid = "84">For instance, you could say &quot;character x has many written forms&quot; or &quot;the character x in this word can be omitted&quot; for any character x.3 3 Even so, some researchers might still insist that the character x here is just for temporary use and.</S>
			<S sid ="224" ssid = "85">cannot be regarded as a regular word with the many linguistic properties generally associated with words.</S>
			<S sid ="225" ssid = "86">Understanding the importance of such a distinction, we will use the more generic term token, rather than the loaded term word, when we need to highlight the distinction.</S>
			<S sid ="226" ssid = "87">It must be added, however, that the two are largely used interchangeably in this paper.</S>
			<S sid ="227" ssid = "88">The validity of the complete dictionary assumption can also be justified from an engineering perspective.</S>
			<S sid ="228" ssid = "89">To ensure a so-called soft landing, any practical application system must be designed so that every input character string can always be tokenized.</S>
			<S sid ="229" ssid = "90">In other words, a complete dictionary is an operational must.</S>
			<S sid ="230" ssid = "91">Moreover, without such a complete dictionary, it would not be possible to avoid ill-formedness in sentence tokenization nor to make the generation-tokenization system for character and words closed and complete.</S>
			<S sid ="231" ssid = "92">Without such definitions of well-formedness, any rigorous formal study would be impossible.</S>
			<S sid ="232" ssid = "93">The concepts of critical point and critical fragment are fundamental to our sen­ tence tokenization theory.</S>
			<S sid ="233" ssid = "94">By adopting the complete dictionary assumption, it has been proven that critical points are all and only unambiguous token boundaries while critical fragments are the longest substrings with all inner positions ambiguous.</S>
			<S sid ="234" ssid = "95">This is a very strong and significant statement.</S>
			<S sid ="235" ssid = "96">It provides us with a precise un­ derstanding of what and where tokenization ambiguities are.</S>
			<S sid ="236" ssid = "97">Although the proof itself is easy to follow, the result has nonetheless been a surprise.</S>
			<S sid ="237" ssid = "98">As demonstrated in Guo (1997), many researchers have tried but failed to answer the question in such a precise and complete way.</S>
			<S sid ="238" ssid = "99">Consequently, while they proposed many sophisticated algorithms for the discovery of ambiguity (and certainty), they never were able to arrive at such a concise and complete solution.</S>
			<S sid ="239" ssid = "100">As critical points are all and only unambiguous token boundaries, an identifica­ tion of all of them would allow for a long character string to be broken down into several short but fully ambiguous critical fragments.</S>
			<S sid ="240" ssid = "101">As shown in Guo (1997), critical points can be completely identified in linear time.</S>
			<S sid ="241" ssid = "102">Moreover, in practice, most criti­ cal fragments are dictionary tokens by themselves, and the remaining nondictionary fragments are generally very short.</S>
			<S sid ="242" ssid = "103">In short, the understanding of critical points and fragments will significantly assist us in both efficient tokenization implementation and tokenization ambiguity resolution.</S>
			<S sid ="243" ssid = "104">The concepts of critical point and critical fragment are similar to those of segment point and character segment in Wang (1989, 37), which were defined on a sentence word graph for the purpose of analyzing the computational complexity of his new tokenization algorithm.</S>
			<S sid ="244" ssid = "105">However, Wang (1989) neither noticed their connection with tokenization ambiguities nor realized the importance of the complete dictionary as­ sumption, and hence failed to demonstrate their crucial role in sentence tokenization.</S>
	</SECTION>
	<SECTION title="Critical Tokenization. " number = "4">
			<S sid ="245" ssid = "1">This section seeks to disclose an important structure of the set of different tokeniza­ tions.</S>
			<S sid ="246" ssid = "2">We will see that different tokenizations can be linked by the cover relationship to form a partially ordered set.</S>
			<S sid ="247" ssid = "3">Based on that, we will establish the notion of criti­ cal tokenization and prove that every tokenization is a subtokenization of a critical tokenization, but no critical tokenization has true supertokenization.</S>
			<S sid ="248" ssid = "4">4.1 Cover Relationship.</S>
			<S sid ="249" ssid = "5">Definition 9 Let X and Y be word strings.</S>
			<S sid ="250" ssid = "6">X covers Y, or X has a cover relation to Y, denoted X::::; Y, if for any substring Xs of X, there exists substring Y5 of Y, such that IXsl ::::; IYsl and G(Xs) = G(Y5 ).</S>
			<S sid ="251" ssid = "7">If X ::::; Y, then X is called a covering word stting of Y, and Y a covered word string of X. Intuitively, X ::::; Y implies lXI ::::; IYI.</S>
			<S sid ="252" ssid = "8">In other words, shorter word strings cover longer word strings.</S>
			<S sid ="253" ssid = "9">However, an absence of X ::::; Y does not imply the existence of Y :::; X. Some word strings do not cover each other.</S>
			<S sid ="254" ssid = "10">In other words, shorter word strings do not always cover longer word strings.</S>
			<S sid ="255" ssid = "11">Example 1 (cont.)</S>
			<S sid ="256" ssid = "12">The word string &quot;this is his book&quot; covers the word string &quot;this is his book&quot;, but not vice versa.</S>
			<S sid ="257" ssid = "13">Example 2 (cont.)</S>
			<S sid ="258" ssid = "14">The word strings &apos;funds and&quot; and &apos;fund sand&quot; do not cover each other.</S>
			<S sid ="259" ssid = "15">Definition 9&apos; Let A and B be sets of word strings.</S>
			<S sid ="260" ssid = "16">A covers B, or A has a cover relation to B, denoted A:::; B, if for any Y E B, there is X E A, such that X:::; Y. If A:::; B, A is called a covering word string set of B, and B a covered word string set of A. Example 3 Given the alphabet = {a,b,c,d}, dictionary D = {a,b,c,d,ab,be,cd,abc,bed}, and char­ acter stringS= abed from the alphabet, there is T0 (S) = {a/b/c/d,a/b/cd, ajbcjd, a/bed, abjcjd, ab/cd, abc/d}.</S>
			<S sid ="261" ssid = "17">Among them, there are {abc/d} :::; {abjcjd, ajbc/d}, {abjcd} :::; {abjcjd, ajbjcd}, {a/bed}:::; {ajbcjd, ajbjcd} and {abjcjd, ajbc/d, ajbjcd}:::; {a/b/c/d}.</S>
			<S sid ="262" ssid = "18">Moreover, there is {abcjd, abjcd, a/bed}:::; Tv(S).</S>
			<S sid ="263" ssid = "19">4.2 Partially Ordered Set.</S>
			<S sid ="264" ssid = "20">Lemma 2 The cover relation is transitive, reflexive, and antisymmetric.</S>
			<S sid ="265" ssid = "21">That is, the cover relation is a (reflexive) partial order.</S>
			<S sid ="266" ssid = "22">Lemma 2, proved in Guo (1997), reveals that the cover relation is a partial order­ a well-defined mathematical structure with good mathematical properties.</S>
			<S sid ="267" ssid = "23">Conse­ quently, from any textbook on discrete mathematics (Kolman and Busby [1987], for example), it is known that the tokenization set Tv(S), together with the word string cover relation :::;, forms a partially ordered set, or simply a poset.</S>
			<S sid ="268" ssid = "24">We shall denote this poset by (Tv(S),:::;).</S>
			<S sid ="269" ssid = "25">In case there is no confusion, we may refer to the poset simply as Tv(S).</S>
			<S sid ="270" ssid = "26">In the literature, usually a poset is graphically presented in a Hasse diagram, which is a digraph with vertices representing poset elements and arcs representing direct partial order relations between poset elements.</S>
			<S sid ="271" ssid = "27">In a Hasse diagram, all connections implied by the partial order&apos;s transitive property are eliminated.</S>
			<S sid ="272" ssid = "28">That is, if X:::; Y and Y:::; Z, there should be no arc from X to Z. Example 3 (cont.)</S>
			<S sid ="273" ssid = "29">The poset T 0 (abcd) = {ajbjcjd, ajb/cd, ajbcjd, ajbcd, abjcjd, abjcd, abcjd} can be graph­ ically presented in the Hasse diagram in Figure 1.</S>
			<S sid ="274" ssid = "30">Certain elements in a poset are of special importance for many of the properties and applications of posets.</S>
			<S sid ="275" ssid = "31">In this paper, we are particularly interested in the minimal elements and least elements.</S>
			<S sid ="276" ssid = "32">In standard textbooks, they are defined in the following manner: Let (A,:::;) be a poset.</S>
			<S sid ="277" ssid = "33">An element a E A is called a minimal element of A if there is no element c E A, c f= a, such that c :::; a. An element a E A is called a least element of A if a :::; x for all x EA.</S>
			<S sid ="278" ssid = "34">(Kolman and Busby 1987, 195196).</S>
			<S sid ="279" ssid = "35">Figure 1 The Hasse diagram for the poset To(abcd) = {a/bfcfd, afbfcd, afbcfd, afbcd, abfcfd, abfcd, abcfd}.</S>
			<S sid ="280" ssid = "36">Example 1 (cont.)</S>
			<S sid ="281" ssid = "37">The word string &quot;this is his book&quot; is both the minimal element and the least element of both T 0 ( thisishisbook) = {&quot;this is his book&quot;} and TO&apos; ( thisishisbook) = {&quot;th is is his book&quot;, &quot;this is his book&quot;}.</S>
			<S sid ="282" ssid = "38">Example 2 (cont.)</S>
			<S sid ="283" ssid = "39">The poset T 0 (fundsand) = {&quot;funds and&quot;, &apos;fund sand&quot;} has both &quot;funds and&quot; and &apos;fund sand&quot; as its minimal elements, but has no least element.</S>
			<S sid ="284" ssid = "40">Example 3 (cont.)</S>
			<S sid ="285" ssid = "41">The poset T0 (abcd) = {ajbjcjd, afbfcd, ajbcjd, ajbcd, abjcjd, abfcd, abcfd} has three minimal elements: abcjd, abfcd, ajbcd.</S>
			<S sid ="286" ssid = "42">It has no least element.</S>
			<S sid ="287" ssid = "43">Note that any finite nonempty poset has at least one minimal element.</S>
			<S sid ="288" ssid = "44">Any poset has at most one least element (Kolman and Busby 1987, 195198).</S>
			<S sid ="289" ssid = "45">4.3 Critical Tokenization.</S>
			<S sid ="290" ssid = "46">This section deals with the most important concept--critical tokenization.</S>
			<S sid ="291" ssid = "47">Let :E be an alphabet, D a dictionary over the alphabet, and 5 a character string over the alphabet.</S>
			<S sid ="292" ssid = "48">In this case, (T0 (5), :S:) is the poset.</S>
			<S sid ="293" ssid = "49">Definition 10 The character string critical tokenization operation Co is a mapping Co: :E* --+ 2°.</S>
			<S sid ="294" ssid = "50">defined as: for any 5 in :E*, C 0 (S) = {W I W is a minimal element of the poset (To(S), ::;)}.</S>
			<S sid ="295" ssid = "51">Any word string W in Co(S) is a critically tokenized word string, or simply a critical tokenization, or CT tokenization for short, of the character string 5.</S>
			<S sid ="296" ssid = "52">And Co(5) is the set of critical tokenizations.</S>
			<S sid ="297" ssid = "53">In other words, the critical tokenization operation maps any character string to its set of critical tokenizations.</S>
			<S sid ="298" ssid = "54">A word string is critical if any other word string does not cover it.</S>
			<S sid ="299" ssid = "55">Example 1 (cont.)</S>
			<S sid ="300" ssid = "56">Given the English alphabet, the tiny Dictionary D = {th, this, is, his, book}, and the character string 5 = thisishisbook, there is Cv(5) = {&quot;this is his book&quot;}.</S>
			<S sid ="301" ssid = "57">This critical tokenization set contains the unique critical tokenization &quot;this is his book&quot;.</S>
			<S sid ="302" ssid = "58">Note that the only difference between &quot;this is his book&quot; and &quot;this is his book&quot; is that the word this in the former is split into two words th and is in the latter.</S>
			<S sid ="303" ssid = "59">Example 2 (cont.)</S>
			<S sid ="304" ssid = "60">Given the English alphabet, the tiny Dictionary D = {fund, funds, and, sand}, and the character string 5 = fundsand, there is Cv(5) = {&apos;funds and&quot;, &apos;&apos;fund sand&quot;}.</S>
			<S sid ="305" ssid = "61">Example 3 (cont.)</S>
			<S sid ="306" ssid = "62">Let :E = {a,b,c,d} and D = {a,b,c,d,ab,bc,cd,abc,bcd}.</S>
			<S sid ="307" ssid = "63">There is C0 (abcd) abjcd, ajbcd}.</S>
			<S sid ="308" ssid = "64">If D&apos; = {a,b,c,d,ab,bc,cd}, then C 0,(abcd) = {ajbcjd, abjcd}.</S>
			<S sid ="309" ssid = "65">{abcjd, Example 4 Given the English alphabet, the tiny Dictionary D = {the, blue, print, blueprint}, and the character string 5 = theblueprint, there are T 0 (5) = {&quot;the blueprint&quot;, &quot;the blue print&quot;} and C0 (S) = {&quot;the blueprint&quot;}.</S>
			<S sid ="310" ssid = "66">Note that the tokenization &quot;the blue print&quot; is not critical (not a critical tokenization).</S>
			<S sid ="311" ssid = "67">4.4 Super- and SubTokenization.</S>
			<S sid ="312" ssid = "68">Intuitively, a tokenization is a subtokenization of another tokenization if further to­ kenizing words in the latter can produce the former.</S>
			<S sid ="313" ssid = "69">Formally, let S be a character string over an alphabet and let D be a dictionary over the alphabet.</S>
			<S sid ="314" ssid = "70">In addition, let X= X1 ...</S>
			<S sid ="315" ssid = "71">Xn andY= Y1 ..</S>
			<S sid ="316" ssid = "72">·Ym be tokenizations of 5 on D, X, Y E Tv(S).</S>
			<S sid ="317" ssid = "73">That gives us.</S>
			<S sid ="318" ssid = "74">the following definition: Definition 11 Y is a subtokenization of X and X is a supertokenization of Y if, for any word x in X, there exists a substring Ys of Y such that x = G(Y5 ).</S>
			<S sid ="319" ssid = "75">Y is a true subtokenization of X and X is a true supertokenization of Y, if Y is a subtokenization of X and X -I Y. Example 1 (cont.)</S>
			<S sid ="320" ssid = "76">The tokenization &quot;this is his book&quot; is a subtokenization of the critical tokenization &quot;this is his book&quot;.</S>
			<S sid ="321" ssid = "77">Example 4 (cont.)</S>
			<S sid ="322" ssid = "78">The tokenization &quot;the blue print&quot; is a subtokenization of the critical tokenization &quot;the blueprint&quot;.</S>
			<S sid ="323" ssid = "79">4.5 Theorem.</S>
			<S sid ="324" ssid = "80">Lemma 3 Y is a subtokenization of X if and only if X S Y. Proof If X S Y, by definition, for any substring Xs of X, there exists substring Ys of Y, such that IXsl S IYsl and G(Xs) = G(Y5 ).</S>
			<S sid ="325" ssid = "81">Also by definition, there is x = G(x) for every single word x. As any single word in a word string is also its single-word substring, it can be concluded that for any word x in X, there exists a substring Ys of Y, such that X= G(Y5 ).</S>
			<S sid ="326" ssid = "82">On the other hand, if Y is a subtokenization of X, by definition, for any word x in X, there exists a substring Ys of Y such that x = G(Y5 ).</S>
			<S sid ="327" ssid = "83">Thus, given any substring Xs of X, Xs = x1 ...</S>
			<S sid ="328" ssid = "84">Xn, for any k, 1 k n, there exists a substring Yk of Y such that Xk = G(Yk)· Denote Ys = Y1 ...</S>
			<S sid ="329" ssid = "85">Y m&apos; there is IXsl IYsl and G(Xs) = G(Y 5 ).</S>
			<S sid ="330" ssid = "86">By definition, there is X Y. D Lemma 3 reveals that a word string is covered by another word string if and only if every word in the latter is realized in the former as a word string.</S>
			<S sid ="331" ssid = "87">In other words, a covering word string is in a more compact form than its covered word string.</S>
			<S sid ="332" ssid = "88">Theorem 3 Every tokenization has a critical tokenization as its supertokenization, but critical to­ kenization has no true supertokenization.</S>
			<S sid ="333" ssid = "89">That is, for any tokenization Y, Y E T 0 (5), there exists critical tokenization X, X E Co(S), such that X is a supertokenization of Y. Moreover, if Y is a critical tokenization and X is its supertokenization, there is X = Y. Proof By definition, for any tokenization Y, Y E T0 (5), there is a critical tokenization X, X E Co(S), such that X Y. By Lemma 3, it would be the same as saying that X is a supertokenization of Y. The second part of the theorem is from the definition of critical tokenization.</S>
			<S sid ="334" ssid = "90">D Theorem 3 states that no critical tokenization can be produced by further tokeniz­ ing words in other tokenizations.</S>
			<S sid ="335" ssid = "91">However, all other tokenizations can be produced from at least one critical tokenization by further tokenizing words in it.</S>
			<S sid ="336" ssid = "92">Example 3 (cont.)</S>
			<S sid ="337" ssid = "93">Given To(S) = {ajbjcjd, ajbjcd, ajbcjd, ajbcd, abjcjd, abjcd, abcjd}, there is C 0 (S) = {abcjd, abjcd, ajbcd} T 0 (S).</S>
			<S sid ="338" ssid = "94">By splitting the word abc in abcjd E C0 (S) into ajbjc, abjc or ajbc, we can make another three tokenizations in T0 (S): ajbjcjd, abjcjd and ajbcjd.</S>
			<S sid ="339" ssid = "95">Similarly, from abjcd, we can bring back ajbjcjd, abjcjd and ajbjcd; and from abcjd, we can recover ajbjcjd, abjcjd and ajbcjd.</S>
			<S sid ="340" ssid = "96">By merging all word strings produced together with word strings in Co(S) = {abcjd, abjcd, ajbcd}, the entire tokenization set T0 (S) is reclaimed.</S>
			<S sid ="341" ssid = "97">4.6 Discussion.</S>
			<S sid ="342" ssid = "98">Since the theory of partially ordered sets is well established, we can use it to enhance our understanding of the mathematical structure of string tokenization.</S>
			<S sid ="343" ssid = "99">One of the obvious and immediate results is the concept of critical tokenization, which is simply another name for the minimal element set of a poset.</S>
			<S sid ="344" ssid = "100">The least element is another important concept.</S>
			<S sid ="345" ssid = "101">Although it may seem trivial to the string tokenization problem, the critical tokenization is, in fact, absolutely crucial.</S>
			<S sid ="346" ssid = "102">For instance, Theorem 3 states that, from critical tokenization, any tokenization can be produced (enumerated).</S>
			<S sid ="347" ssid = "103">As the number of critical tokenizations is normally considerably less than the total amount of all possible tokenizations, this theorem leads us to focus on the study of a few critical ones.</S>
			<S sid ="348" ssid = "104">In the next few sections, we shall further investigate certain important aspects of critical tokenizations.</S>
	</SECTION>
	<SECTION title="Critical and Hidden  Ambiguities. " number = "5">
			<S sid ="349" ssid = "1">This section clarifies the relationship between critical tokenization and various types ·of tokenization ambiguities.</S>
			<S sid ="350" ssid = "2">5.1 Critical Ambiguity in Tokenization.</S>
			<S sid ="351" ssid = "3">Definition 12 Let E be an alphabet, D a dictionary, and S a character string over the alphabet.</S>
			<S sid ="352" ssid = "4">The character string S from the alphabet E has critical ambiguity in tokenization on dictionary D if IC0 (S)I &gt; 1.</S>
			<S sid ="353" ssid = "5">S has no critical ambiguity in tokenization if ICo(S)I = 1.</S>
			<S sid ="354" ssid = "6">A tokenization WE To(S) has critical ambiguity in tokenization if there exists another tokenization W&apos; E T 0 (S), W&apos; :f. W, such that neither W:::; W&apos; nor W&apos;:::; W holds.</S>
			<S sid ="355" ssid = "7">Example 2 (cont.)</S>
			<S sid ="356" ssid = "8">Since C0 (fundsand) = {&apos;funds and&quot;, &apos;fund sand&quot;}, i.e., ICo(Jundsand)l = 2 &gt; 1, the character string fundsand has critical ambiguity in tokenization.</S>
			<S sid ="357" ssid = "9">Moreover, the tok­ enization &quot;funds and&quot; has critical ambiguity in tokenization since there exists another possible tokenization &apos;fund sand&quot; such that both &apos;funds and&quot; :::; &apos;fund sand&quot; and &apos;fund sand&quot; :::; &apos;funds and&quot; do not hold.</S>
			<S sid ="358" ssid = "10">Example 4 (cont.)</S>
			<S sid ="359" ssid = "11">Since C0 (theblueprint) = {&quot;the blueprint&quot;}, the character string theblueprint does not have critical ambiguity in tokenization.</S>
			<S sid ="360" ssid = "12">It helps to clarify that the only difference between the definition of tokenization ambiguity and that of critical ambiguity in tokenization lies in the tokenization set: While tokenization ambiguity is defined on the entire tokenization set To(S), critical ambiguity in tokenization is defined only on the critical tokenization set Co(S), which is a subset of To(S).</S>
			<S sid ="361" ssid = "13">As all critical tokenizations are minimal elements on the word string cover re­ lationship, the existence of critical ambiguity in tokenization implies that the &quot;most powerful and commonly used&quot; (Chen and Liu 1992, 104) principle of maximum to­ kenization would not be effective in resolving critical ambiguity in tokenization and implies that other means such as statistical inferencing or grammatical reasoning have to be introduced.</S>
			<S sid ="362" ssid = "14">In other words, critical ambiguity in tokenization is unquestionably critical.</S>
			<S sid ="363" ssid = "15">Critical ambiguity in tokenization is the precise mathematical description of con­ ventional concepts such as disjunctive ambiguity (Webster and Kit [1992, 1108], for example) and overlapping ambiguity (Sun and T&apos;sou [1995, 121], for example).</S>
			<S sid ="364" ssid = "16">We will return to this topic in Section 5.4.</S>
			<S sid ="365" ssid = "17">5.2 Hidden Ambiguity in Tokenization.</S>
			<S sid ="366" ssid = "18">Definition 13 Let E be an alphabet, D a dictionary, and S a character string over the alphabet.</S>
			<S sid ="367" ssid = "19">The character string S from the alphabet E has hidden ambiguity in tokenization on dictionary D if T 0 (S) :f. C0 (S).</S>
			<S sid ="368" ssid = "20">A tokenization WE T0 (S) has hidden ambiguity in tokenization if there exists another tokenization W&apos; E T0 (S), W&apos; :f. W, such that w:::;w&apos;.</S>
			<S sid ="369" ssid = "21">Example 4 (cont.)</S>
			<S sid ="370" ssid = "22">Let S = theblueprint, To(S) = {&quot;the blueprint&quot;, &quot;the blue print&quot;}, and Co(S) = {&quot;the blueprint&quot;}.</S>
			<S sid ="371" ssid = "23">Since T 0 (5) =1Co(S), the character sting theblueprint has hidden ambigu­ ity in tokenization.</S>
			<S sid ="372" ssid = "24">Since &quot;the blueprint&quot; ::; &quot;the blue print&quot;, the character string &quot;the blueprint&quot; has hidden ambiguity in tokenization.</S>
			<S sid ="373" ssid = "25">Intuitively, a tokenization has hidden ambiquity in tokenization, if some words in it can be further decomposed into word strings, such as &quot;blueprint&quot; to &quot;blue print&quot;.</S>
			<S sid ="374" ssid = "26">They are called hidden or invisible because others cover them.</S>
			<S sid ="375" ssid = "27">The resolution of hidden ambiguity in tokenization is the aim of the principle of maximum tokenization Uie 1989; Jie and Liang 1991).</S>
			<S sid ="376" ssid = "28">Under this principle, only covering tokenizations win and all covered tokenizations are discarded.</S>
			<S sid ="377" ssid = "29">Hidden ambiguity in tokenization is the precise mathematical description of con­ ventional concepts such as conjunctive ambiguity (Webster and Kit [1992, 1108], for example), combinational ambiguity (Liang [1987], for example) and categorical ambi­ guity (Sun and T&apos;sou [1995, 121], for example).</S>
			<S sid ="378" ssid = "30">We will return to this topic in Sec­ tion 5.4.</S>
			<S sid ="379" ssid = "31">5.3 Ambiguity = Critical + Hidden.</S>
			<S sid ="380" ssid = "32">Let I: be an alphabet, D a dictionary, and S a character string over the alphabet.</S>
			<S sid ="381" ssid = "33">Theorem 4 A character string S over an alphabet I: has tokenization ambiguity on a tokenization dictionary D if and only if S has either critical ambiguity in tokenization or hidden ambiguity in tokenization.</S>
			<S sid ="382" ssid = "34">Proof If S has critical ambiguity in tokenization, by definition, there is ICo(S)I &gt; 1.</S>
			<S sid ="383" ssid = "35">If S has hidden ambiguity in tokenization, by definition, there is To(S) =1Co(S).</S>
			<S sid ="384" ssid = "36">In both cases, since Co(S) T 0 (S), there must be IT 0 (S)I &gt; 1.</S>
			<S sid ="385" ssid = "37">By definition, S has tokenization ambiguity.</S>
			<S sid ="386" ssid = "38">If S has tokenization ambiguity, by definition, there is ITo(S)I &gt; 1.</S>
			<S sid ="387" ssid = "39">Since any finite nonempty poset has at least one minimal element, there is ICo(S)I &gt; 0.</S>
			<S sid ="388" ssid = "40">Since Co(S) To(S), there is To(S) =1Co(S) if ICo(S)I = 1.</S>
			<S sid ="389" ssid = "41">In this case, by definition, S has hidden ambiguity in tokenization.</S>
			<S sid ="390" ssid = "42">If ICo(S)I &gt; 1, by definition, S has critical ambiguity in tokenization.</S>
			<S sid ="391" ssid = "43">0 Theorem 4 explicitly and precisely states that tokenization ambiguity is the union of critical ambiguity in tokenization and hidden ambiguity in tokenization.</S>
			<S sid ="392" ssid = "44">This result helps us in the understanding of character string tokenization ambiguity.</S>
			<S sid ="393" ssid = "45">5.4 Discussion.</S>
			<S sid ="394" ssid = "46">By freezing the problem of token identity determination, tokenization ambiguity iden­ tification and resolution are all that is required in sentence tokenization.</S>
			<S sid ="395" ssid = "47">Consequently, it must be crucial and beneficial to pursue an explicit and accurate understanding of various types of character string tokenization ambiguities and their relationships.</S>
			<S sid ="396" ssid = "48">In the literature, however, the general practice is not to formally define and classify ambiguities but to apply various terms to them, such as overlapping ambiguity and combinational ambiguity in their intuitive and normally fuzzy senses.</S>
			<S sid ="397" ssid = "49">Nevertheless, efforts do exist to rigorously assign them precise, formal meanings.</S>
			<S sid ="398" ssid = "50">As a representa tive example, in Webster and Kit (1992, 1108), both conjunctive (combinational) and disjunctive (overlapping) ambiguities are defined in the manner given below.</S>
			<S sid ="399" ssid = "51">1.</S>
			<S sid ="400" ssid = "52">TYPE 1: In a sequence of Chinese4 characters S = a1 ... a;b1 ... bj, if a1.</S>
			<S sid ="401" ssid = "53">... a;, b1 ... bj, and S are each a word, then there is conjunctive ambiguity inS.</S>
			<S sid ="402" ssid = "54">The segmentS, which is itself a word, contains other words.</S>
			<S sid ="403" ssid = "55">This is also known as multicombinational ambiguity.</S>
			<S sid ="404" ssid = "56">2.</S>
			<S sid ="405" ssid = "57">TYPE II: In a sequence of Chinese characters S = a1 ... a;b1 ... bjc1 ...Ckf if.</S>
			<S sid ="406" ssid = "58">a1 ... a;b1 ... bj and b1 ... bjcl ... ck are each a word, then S is an overlapping ambiguous segment, or in other words, the segment S displays disjunctive ambiguity.</S>
			<S sid ="407" ssid = "59">The segment b1 ... bj is known as an overlap, which is usually one character long.</S>
			<S sid ="408" ssid = "60">The definitions above contain nothing improper.</S>
			<S sid ="409" ssid = "61">In fact, conjunctive (combina­ tional) ambiguity as defined above is a special case of hidden ambiguity in tokeniza­ tion, since 11a1 ... a;b1 ... b( ::; lla1 ... a;/b1 ... b(.</S>
			<S sid ="410" ssid = "62">Moreover, disjunctive (overlapping) ambiguity is a special case of critical ambiguity in tokenization, since for the character string S = a1 ... a;b1 ... bjcl ...Ckf both II a1 ... a;b1 ... bj/ c1 ...</S>
			<S sid ="411" ssid = "63">Ck and II a1 ... a;/b1 ... bjcl ... ck&quot; are critical tokenizations.</S>
			<S sid ="412" ssid = "64">The definitions above, however, are neither complete nor critical.</S>
			<S sid ="413" ssid = "65">In our opinion, a definition is complete only if any phenomenon in the problem domain can be properly described (defined).</S>
			<S sid ="414" ssid = "66">With regard to the character string tokenization problem proper, this completeness requirement can be translated as: given an alphabet, a dictionary, and a character string, the definition should be sufficient to answer the following two questions: (1) does this character string have tokenization ambiguity?</S>
			<S sid ="415" ssid = "67">(2) if yes, what type of ambiguity does it have?</S>
			<S sid ="416" ssid = "68">The definitions above cannot fulfill this completeness requirement.</S>
			<S sid ="417" ssid = "69">For instance, if a1 ... a;, b1 . : . bj,c1 ...Ckf and a1 ... a;b1 ... bjcl ... ck are all words in a dictionary, the character string S = a1 ... a;b1 ... bjc1 ...</S>
			<S sid ="418" ssid = "70">Ckf while intuitively in Type I (conjunctive am­ biguity), is, in fact, captured neither by Type I nor by Type II.</S>
			<S sid ="419" ssid = "71">We agree that, although to do so would not be trivial, it is nevertheless possible to make the definitions above complete by carefully listing and including all possible cases.</S>
			<S sid ="420" ssid = "72">However, criticality, which is what is being explored in this paper, would most probably still not be captured in such a carefully generalized ambiguity definition.</S>
			<S sid ="421" ssid = "73">What we believe to be crucial is the association between tokenization ambigu­ ity and the maximization or minimization property of the partially ordered set on the cover relation.</S>
			<S sid ="422" ssid = "74">As will be illustrated later in this paper, such an association is exceptionally important in attempting to understand ambiguities and in developing disambiguation strategies.</S>
			<S sid ="423" ssid = "75">In short, both the cover relation and critical tokenization have given us a clear picture of character string tokenization ambiguity as expressed in Theorem 4.</S>
	</SECTION>
	<SECTION title="Maximum Tokenization. " number = "6">
			<S sid ="424" ssid = "1">This section clarifies the relationship between critical tokenization (CT) and three other representative implementations of the principle of maximum tokenization, i.e., forward maximum tokenization (FT), backward maximum tokenization (BT) and shortest to­ kenization (ST).</S>
			<S sid ="425" ssid = "2">It will be proven that ST, FT and BT are all true subclasses of CT. 4 Although Webster and Kit include the modifier Chinese, the definition has nothing to do with specific.</S>
			<S sid ="426" ssid = "3">characteristics of Chinese but is general (multilingual).</S>
			<S sid ="427" ssid = "4">6.1 Forward Maximum Tokenization.</S>
			<S sid ="428" ssid = "5">Let I: be an alphabet, D a dictionary on the alphabet, and S a character string over the alphabet.</S>
			<S sid ="429" ssid = "6">Definition 14 A tokenization W = w1 ...</S>
			<S sid ="430" ssid = "7">Wm E To(S) is a forward maximum tokenization of S over I: and D, or FT tokenization for short, if, for any k, 1 ::::; k ::::; m, there exist i and j, 1 ::::; i ::::; j ::::; n, such that5 1.</S>
			<S sid ="431" ssid = "8">G(w1 ... wk1) = c1 ...</S>
			<S sid ="432" ssid = "9">Ci1, 2.</S>
			<S sid ="433" ssid = "10">Wk = Ci ...Cj, and.</S>
			<S sid ="434" ssid = "11">3.</S>
			<S sid ="435" ssid = "12">For any j&apos;, j &lt; j&apos; ::::; n, there is ci ... ci&apos; tJ_ D..</S>
			<S sid ="436" ssid = "13">The forward maximum tokenization operation, or FT operation for short, is a map­ ping Fo: I:* -+ 2°* defined as: for any S E I:*, Fo(S) = {W I W is aFT tokenization of S over I: and D}.</S>
			<S sid ="437" ssid = "14">This definition is in fact a descriptive interpretation of the widely recommended conventional constructive forward maximum tokenization procedure (Liu 1986a, 1986b; Liang 1986, 1987; Chen and Liu 1992; Webster and Kit 1992).</S>
			<S sid ="438" ssid = "15">Example 3 (cont.)</S>
			<S sid ="439" ssid = "16">The character stringS= abed has the word string abcjd as its sole FT tokenization in T0 (S) = {ajbjcjd, ajbjcd, ajbcjd, ajbcd, abjcjd, abjcd, abcjd}, i.e., F 0 (S) = {abcjd}.</S>
			<S sid ="440" ssid = "17">Example 2 (cont.)</S>
			<S sid ="441" ssid = "18">F0 (fundsand) = {&apos;funds and&quot;}, i.e., the character string fundsand has its sole FT tok­ enization &quot;funds and&quot;.</S>
			<S sid ="442" ssid = "19">Example 4 (cont.)</S>
			<S sid ="443" ssid = "20">F0 (S) = {&quot;the blueprint&quot;}, i.e., the word string &quot;the blueprint&quot; is the only FT tokenization for the character string S = theblueprint.</S>
			<S sid ="444" ssid = "21">Lemma 4 For all S E I:*, there are IFo(S)I ::::; 1 and Fo(S) Co(S).</S>
			<S sid ="445" ssid = "22">That is to say, any character string has, at most, a single FT tokenization.</S>
			<S sid ="446" ssid = "23">Moreover, if the FT tokenization exists, it is a CT tokenization.</S>
			<S sid ="447" ssid = "24">Proof ·Certain character strings do not have FT tokenization on some dictionaries, even if they have many possible tokenizations.</S>
			<S sid ="448" ssid = "25">For example, given the alphabet I: = {a,b,c, d} and the dictionary D ={a, abc, bed}, there is T 0 (abcd) = {ajbcd}.</S>
			<S sid ="449" ssid = "26">But the single tokenization does not fulfill condition (3) in the definition above for k = 1, because the longer word abc exists in the dictionary.</S>
			<S sid ="450" ssid = "27">5 Note, as a widely adopted convention, in case k &lt; 1, w1 ... wk_1 represents the empty word string v. and c1 ... ck_1 represents the empty character string e. Assume both X = X1 ...</S>
			<S sid ="451" ssid = "28">Xm and Y = Yl ...</S>
			<S sid ="452" ssid = "29">Ym&apos; are FT tokenizations, X =/= Y. Then, there must exist k, 1 :::; k:::; min(m,m&apos;), such that Xk&apos; = Yk&apos;&apos; for all k&apos;, 1 :::; k&apos; &lt; k, but xk =/= Yk· Since G(X) = G(Y), there must be lxkl =/= IYkl· Consequently, either X or Y is unable to fulfill condition (3) of definition 14.</S>
			<S sid ="453" ssid = "30">By contradiction, there must be X= Y. In other words, any character string at most has single FT tokenization.</S>
			<S sid ="454" ssid = "31">Assume the FT tokenization X = x1 ...</S>
			<S sid ="455" ssid = "32">Xm is not a CT tokenization.</S>
			<S sid ="456" ssid = "33">By Theorem 3, there must exist a CT tokenization Y = y1 ...Ym&apos; such that X =/= Y and Y :::; X. Thus, by the cover relation definition, for any substring Ys of Y, there exists substring Xs of X, such that IYsl :::; IXsl and G(Xs) = G(Ys)· Since X =/= Y, there must exist k, 1 :::; k :::; min(m, m&apos;), such that Xk&apos; = Yk&apos;, for all k&apos;, 1 :::; k&apos; &lt; k, but lxkl :::; IYkl· This leads to a conflict with condition (3) in the definition.</S>
			<S sid ="457" ssid = "34">In other words, X cannot be an FT tokenization if it is not a CT tokenization.</S>
			<S sid ="458" ssid = "35">D 6.2 Backward Maximum Tokenization.</S>
			<S sid ="459" ssid = "36">Let I: be an alphabet, D a dictionary on the alphabet, and S a character strings over the alphabet.</S>
			<S sid ="460" ssid = "37">Definition 15 A tokenization W = w1 ...</S>
			<S sid ="461" ssid = "38">Wm E T0 ( S) is a backward maximum tokenization of S over I: and D, or BT tokenization for short, if for any k, 1 :::; k:::; m, there exist i and j, 1 :::; i :::; j :::; n, such that 1.</S>
			<S sid ="462" ssid = "39">G(wk+l ...Wm) = Cj+l ...</S>
			<S sid ="463" ssid = "40">Cn1 2.</S>
			<S sid ="464" ssid = "41">wk = c; ..</S>
			<S sid ="465" ssid = "42">.cj, and 3.</S>
			<S sid ="466" ssid = "43">For any i&apos;, 1 :::; i&apos; &lt; i, there is c;, ...</S>
			<S sid ="467" ssid = "44">Cj D..</S>
			<S sid ="468" ssid = "45">The backward maximum tokenization operation is a mapping B0: I:* -+ 2°.</S>
			<S sid ="469" ssid = "46">defined as: for any S E I:*, Bv(S) ={WI W is a BT tokenization of S over I: and D}.</S>
			<S sid ="470" ssid = "47">This definition is in fact a descriptive interpretation of the widely recommended con­ ventional constructive backward maximum tokenization procedure (Liu 1986a, 1986b; Liang 1986, 1987; Chen and Liu 1992; Webster and Kit 1992).</S>
			<S sid ="471" ssid = "48">Example 3 (cont.)</S>
			<S sid ="472" ssid = "49">For the character string S = abed, the word string ajbcd is the only BT tokeniza­ tion in Tv(S) = {ajbjcjd, ajbjcd, ajbcjd, ajbcd, abjcjd, abjcd, abcjd}.</S>
			<S sid ="473" ssid = "50">That is, Bv(S) = {ajbcd}.</S>
			<S sid ="474" ssid = "51">Example 2 (cont.)</S>
			<S sid ="475" ssid = "52">For the character string S = fundsand, there is B 0 (fundsand) = {&quot;fund sand&quot;}.</S>
			<S sid ="476" ssid = "53">That is, the word string &quot;fund sand&quot; is the only BT tokenization.</S>
			<S sid ="477" ssid = "54">Example 4 (cont.)</S>
			<S sid ="478" ssid = "55">For the character stringS = theblueprint, there is B0 (S) = {&quot;the blueprint&quot;}.</S>
			<S sid ="479" ssid = "56">That is, the word string &quot;the blueprint&quot; is the only BT tokenization.</S>
			<S sid ="480" ssid = "57">Lemma 5 For all S E I:*, there are IBv(S)I:::; 1 and Bv(S) s;; Cv(S).</S>
			<S sid ="481" ssid = "58">That is, any character string has at most one BT tokenization.</S>
			<S sid ="482" ssid = "59">Moreover, if the BT tokenization exists, it is a CT tokenization.</S>
			<S sid ="483" ssid = "60">Proof Parallel to the proof for Lemma 4.</S>
			<S sid ="484" ssid = "61">0 6.3 Shortest Tokenization.</S>
			<S sid ="485" ssid = "62">Definition 16 The shortest tokenization operation So is a mapping S 0: 1:* ---+ 2°* defined as: for any Sin 1:*, So(S) = {W IIWI = minw&apos;ETo(SJIW&apos;I}.</S>
			<S sid ="486" ssid = "63">Every tokenization Win So(S) is a shortest tokenization, or ST tokenization for short, of the character string S. In other words, a tokenization W of a character string S is a shortest tokenization if and only if the word string has the minimum word string length among all possible tokenizations.</S>
			<S sid ="487" ssid = "64">This definition is in fact a descriptive interpretation of the constructive shortest path finding tokenization procedure proposed by Wang (1989) and Wang, Wang, and Bai (1991).</S>
			<S sid ="488" ssid = "65">Example 3 (cont.)</S>
			<S sid ="489" ssid = "66">Given the character stringS= abed.</S>
			<S sid ="490" ssid = "67">For the dictionary D = {a,b,c,d,ab,bc,cd,abc,bcd}, both abcjd and ajbcd are ST tokenizations in T 0 (S) = {ajbjcjd, ajbjcd, ajbcjd, ajbcd, abjcjd, abjcd, abcjd}.</S>
			<S sid ="491" ssid = "68">That is, S 0 (S) = {abcjd, ajbcd}.</S>
			<S sid ="492" ssid = "69">ForD&apos;= {a,b,c,d,ab,bc,cd}, however, there is So,(S) = {abjcd}.</S>
			<S sid ="493" ssid = "70">Note, in this case, the CT tokenization ajbcjd is not in So,(S).</S>
			<S sid ="494" ssid = "71">Example 2 (cont.)</S>
			<S sid ="495" ssid = "72">For the character string S = fundsand, there is So(fundsand) = {&apos;funds and&quot;, &quot;fund sand&quot;}.</S>
			<S sid ="496" ssid = "73">That is, both &quot;funds and&quot; and &quot;fund sand&quot; are ST tokenizations.</S>
			<S sid ="497" ssid = "74">Example 4 (cont.)</S>
			<S sid ="498" ssid = "75">For the character stringS= theblueprint, there is S 0 (S) ={&quot;the blueprint&quot;}.</S>
			<S sid ="499" ssid = "76">That is, the word string &quot;the blueprint&quot; is the only ST tokenization.</S>
			<S sid ="500" ssid = "77">Lemma 6 So(S) Co(S) for all S E 1:*.</S>
			<S sid ="501" ssid = "78">That is, every ST tokenization is a CT tokenization.</S>
			<S sid ="502" ssid = "79">Proof Let X be an ST tokenization, X E S 0 (S).</S>
			<S sid ="503" ssid = "80">Assume X is not aCT tokenization, XC 0 (S).</S>
			<S sid ="504" ssid = "81">Then, by Theorem 3, there exists aCT tokenization YC 0 (S), Y -1- X, such that Y:::; X. By the definition of the cover relation, there is IYI :::; lXI.</S>
			<S sid ="505" ssid = "82">In fact, as X -1- Y, there must be IYI &lt; lXI.</S>
			<S sid ="506" ssid = "83">This is in conflict with the fact that X is an ST tokenization.</S>
			<S sid ="507" ssid = "84">Hence, the lemma is proven by contradiction.</S>
			<S sid ="508" ssid = "85">0 6.4 Theorem.</S>
			<S sid ="509" ssid = "86">Theorem 5 Fo(S) UBo(S) Co(S) and So(S) Co(S) for all S E 1:*.</S>
			<S sid ="510" ssid = "87">Moreover, there exists S E 1:*, such that Fo(S) U Bo(S) -1C0 (S) or So(S) -1C0 (S).</S>
			<S sid ="511" ssid = "88">That is, the forward maximum tokenization, the backward maximum tokenization, and the shortest tokenization are all true subclasses of critical tokenization.</S>
			<S sid ="512" ssid = "89">Proof The first part is the combination of Lemma 4, 5, and 6.</S>
			<S sid ="513" ssid = "90">The second part is exemplified by Example 3 above.</S>
			<S sid ="514" ssid = "91">D 6.5 Principle of Maximum Tokenization.</S>
			<S sid ="515" ssid = "92">The three tokenization definitions in this section are essentially descriptive restatements of the corresponding constructive tokenization procedures, which in turn are realiza­ tions of the widely followed principle of maximum tokenization (e.g., Liu 1986; Liang 1986a, 1986b; Wang 1989; Jie 1989; Wang, Su, and Mo 1990; Jie, Liu, and Liang 1991a, b; Yeh and Lee 1991; Webster and Kit 1992; Chen and Liu 1992; Guo 1993; Wu and Su 1993; Nie, Jin, and Hannan 1994; Sproat et al. 1996; Wu et al. 1994; Li et al. 1995; Sun and T&apos;sou 1995; Wong et al. 1995; Bai 1995; Sun and Huang 1996).</S>
			<S sid ="516" ssid = "93">The first work closest to this principle, according to Liu (1986, 1988), was the 54-32-1 tokenization algorithm proposed by a Russian MT practitioner in 1956.</S>
			<S sid ="517" ssid = "94">This algorithm is a special version of the greedy-type implementation of the forward max­ imum tokenization and is still in active use.</S>
			<S sid ="518" ssid = "95">For instance, Yun, Lee, and Rim (1995) recently applied it to Korean compound tokenization.</S>
			<S sid ="519" ssid = "96">It is understood that forward maximum tokenization, backward maximum to­ kenization and shortest tokenization are the three most representative and widely quoted works following the general principle of maximum tokenization.</S>
			<S sid ="520" ssid = "97">However, the principle itself is not crystal-clear in the literature.</S>
			<S sid ="521" ssid = "98">Rather, it only serves as a gen­ eral guideline, as different researchers make different interpretations.</S>
			<S sid ="522" ssid = "99">As Chen and Liu (1992, 104) noted, &quot;there are a few variations of the sense of maximal matching.&quot;</S>
			<S sid ="523" ssid = "100">Hence, many variations have been derived after decades of fine-tuning and modifi­ cation.</S>
			<S sid ="524" ssid = "101">As Webster and Kit (1992, 1108) acknowledged, different realizations of the principle &quot;were invented one after another and seemed inexhaustible.&quot;</S>
			<S sid ="525" ssid = "102">While researchers generally agree that a dictionary word should be tokenized as itself, they usually have different opinions on how a non-dictionary word (critical) frag­ ment should be tokenized.</S>
			<S sid ="526" ssid = "103">While they all agree that a certain form of extremes must be attained, they nevertheless have their own understanding of what the form should be.</S>
			<S sid ="527" ssid = "104">Consequently, it should come as no surprise to see various kinds of theoretical generalization or summarization work in the literature.</S>
			<S sid ="528" ssid = "105">A good representative work is by Kit and his colleagues (Jie 1989; Jie, Liu, and Liang 1991a, b; Webster and Kit 1992), who proposed a three-dimensional structural tokenization model.</S>
			<S sid ="529" ssid = "106">This model, called ASM for Automatic Segmentation Model, is capable of characterizing up to eight classes of different maximum or minimum tokenization procedures.</S>
			<S sid ="530" ssid = "107">Among the eight procedures, based on both analytical inferences and experimental studies, both forward maximum tokenization and backward maximum tokenization are recommended as good solutions.</S>
			<S sid ="531" ssid = "108">Unfortunately, in Webster and Kit (1992, 1108), they unnecessarily made the following overly strong claim: It is believed that all elemental methods are included in this model.</S>
			<S sid ="532" ssid = "109">Furthermore, it can be viewed as the ultimate model for methods of string matching of any elements, including methods for finding English idioms.</S>
			<S sid ="533" ssid = "110">The shortest tokenization proposed by Wang (1989) provides an obvious coun­ terexample.</S>
			<S sid ="534" ssid = "111">As Wang (1989) exemplified6, for the alphabet :E = {a,b,c,d,e} and the 6 The original example is &quot; i&apos;J )t -&quot;f &quot;, a widely quoted Chinese phrase difficult to tokenize.</S>
			<S sid ="535" ssid = "112">Its.</S>
			<S sid ="536" ssid = "113">dictionary D = {a,b,c,d,e,ab,bc,cd,de}, the character string 5 = abcde has FT set Fo(5) = {abjcdje}, BT set B0 (5) = {ajbcjde} and 5T set 5o(5) = {abjcdje, ajbcjde, abjcjde}.</S>
			<S sid ="537" ssid = "114">Clearly, the 5T tokenization abjcjde, which fulfills the principle of maximum tokenization and is the desired tokenization in some cases, is neither FT nor BT tok­ enization.</S>
			<S sid ="538" ssid = "115">Moreover, careful checking showed that the missed 5T tokenization is not in any of the eight tokenization solutions covered by the ASM model.</S>
			<S sid ="539" ssid = "116">In short, the ASM model is not a complete interpretation of the principle of maximum tokenization.</S>
			<S sid ="540" ssid = "117">Furthermore, the shortest tokenization still does not capture all the essences of the principle.</S>
			<S sid ="541" ssid = "118">&apos;For instance, given the alphabet= {a,b,c,d} and the dictionary D = {a,b,c,d,ab,bc,cd}, the character string 5 =abed has the same tokenization set F0 (5) = B0 (5) = 50 (5) = {abjcd} for FT, BT and 5T, but a different CT tokenization set Co(5) = {abjcd, ajbcjd}.</S>
			<S sid ="542" ssid = "119">In other words, the CT tokenization ajbcjd is left out in all the other three sets.</S>
			<S sid ="543" ssid = "120">As the tokenization ajbcjd is not a subtokenization of any other possible tokenizations, it fulfills the principle of maximum tokenization.</S>
			<S sid ="544" ssid = "121">It is now clear that, while the principle of maximum tokenization is very useful in sentence tokenization, it lacks precise understanding in the literature.</S>
			<S sid ="545" ssid = "122">Consequently, no solution proposed in the literature is complete with regards to realizing the principle.</S>
			<S sid ="546" ssid = "123">Recall that, in the previous sections, the character string tokenization operation was modeled as the inverse of the generation operation.</S>
			<S sid ="547" ssid = "124">Under the tokenization oper­ ation, every character string can be tokenized into a set of different tokenizations.</S>
			<S sid ="548" ssid = "125">The cover relationship between tokenizations was recognized and the set of tokenizations was proven to be a poset (partially ordered set) on the cover relationship.</S>
			<S sid ="549" ssid = "126">The set of critical tokenizations was defined as the set of minimum elements in the poset.</S>
			<S sid ="550" ssid = "127">In addition, it was proven that every tokenization has at least one critical tokenization as its supertokenization and only critical tokenization has no true supertokenization.</S>
			<S sid ="551" ssid = "128">Consequently, a noncritical tokenization would conflict with the principle of max­ imum tokenization, since it is a true subtokenization of others.</S>
			<S sid ="552" ssid = "129">As compared with its true supertokenization, it requires the extra effort of subtokenization.</S>
			<S sid ="553" ssid = "130">On the other hand, a critical tokenization would fully realize the principle of maximum tokeniza­ tion, since it has already attained an extreme form and cannot be simplified or com­ pressed further.</S>
			<S sid ="554" ssid = "131">As compared with all other tokenizations, no effort can be saved.</S>
			<S sid ="555" ssid = "132">Based on this understanding, it is now apparent why forward maximum tok­ enization, backward maximum tokenization, and shortest tokenization are all special cases of critical tokenization, but not vice versa.</S>
			<S sid ="556" ssid = "133">In addition, it has been proven, in Guo (1997), that critical tokenization also covers other types of maximum tokenization implementations such as profile tokenization and shortest tokenization.</S>
			<S sid ="557" ssid = "134">We believe that critical tokenization is the only type of tokenization completely fulfilling the principle of maximum tokenization.</S>
			<S sid ="558" ssid = "135">In other words, critical tokenization is the precise mathematical description of the commonly adopted principle of maximum tokenization.</S>
	</SECTION>
	<SECTION title="Further Discussion. " number = "7">
			<S sid ="559" ssid = "1">This section explores some helpful implications of critical tokenization in effective tokenization disambiguation and in efficient tokenization implementation.</S>
			<S sid ="560" ssid = "2">desired tokenization, in many contexts, is&quot; {:;- I!}).</S>
			<S sid ="561" ssid = "3">I fJt -f- &quot;.</S>
			<S sid ="562" ssid = "4">7.1 String Generation and Tokenization versus Language Derivation and Parsing.</S>
			<S sid ="563" ssid = "5">The relationship between the operations of sentence derivation and sentence parsing in the theory of parsing, translation, and compiling (Aho and Ullman 1972) is an obvious analogue with the relationship between the operations of character string generation and character string tokenization that are defined in this paper.</S>
			<S sid ="564" ssid = "6">As the former pair of operations is well established, and has great influence in the literature of sentence tokenization, many researchers have, either consciously or unconsciously, been trying to transplant it to the latter.</S>
			<S sid ="565" ssid = "7">We believe this worthy of reexamination.</S>
			<S sid ="566" ssid = "8">Normally, sentence derivation and parsing are governed by complex grammars.</S>
			<S sid ="567" ssid = "9">Consequently, the bulk of the work has been in developing, representing, and process­ ing grammar.</S>
			<S sid ="568" ssid = "10">Although it is a well known fact that some sentences may have several derivations or parses, the focus has always been either on (1) grammar enhancement, such as introducing semantic categories and consistency checking rules (selectional restrictions), not to mention those great works on grammar formalisms, or on (2) am­ biguity resolution, such as introducing various heuristics and tricks including leftmost parsing and operator preferences (Aho and Ullman 1972; Aho, Sethi, and Ullman 1986; Allen 1995; Grosz, Jones, and Webber 1986).</S>
			<S sid ="569" ssid = "11">Following this line, we observed two tendencies in tokenization research.</S>
			<S sid ="570" ssid = "12">One is the tendency to bring every possible knowledge source into the character string gener­ ation operation.</S>
			<S sid ="571" ssid = "13">For example, Gan (1995) titled his Ph.D. dissertation Integrating Word Boundary Disambiguation with Sentence Understanding.</S>
			<S sid ="572" ssid = "14">Here, in addition to traditional devices such as syntax and semantics, he even employed principles of psychology and chemistry, such as crystallization.</S>
			<S sid ="573" ssid = "15">Another is the tendency of enumerating al­ most blindly every heuristic and trick possible in ambiguity resolution.</S>
			<S sid ="574" ssid = "16">As Webster and Kit (1992, 1108) noted, &quot;segmentation methods were invented one after another and seemed inexhaustible.&quot;</S>
			<S sid ="575" ssid = "17">For example, Chen and Liu (1992) acknowledged that the heuristic of maximum matching alone has &quot;many variations&quot; and tested six different implementations.</S>
			<S sid ="576" ssid = "18">We are not convinced of the effectiveness and necessity of both of the schools of tokenization research.</S>
			<S sid ="577" ssid = "19">The principle argument is, while research is by nature trial-and­ error and different knowledge sources contribute to different facets of the solution, it is nonetheless more crucial and productive to understand where the core of the problem really lies.</S>
			<S sid ="578" ssid = "20">As depicted in this paper, unlike general sentence derivation for complex natural languages, the character string generation process can be very simple and straight­ forward.</S>
			<S sid ="579" ssid = "21">Many seemingly important factors such as natural language syntax and se­ mantics do not assume fundamental roles in the process.</S>
			<S sid ="580" ssid = "22">They are definitely helpful, but only at a later stage.</S>
			<S sid ="581" ssid = "23">Moreover, as emphasized in this paper, the tokenization set has some very good mathematical properties.</S>
			<S sid ="582" ssid = "24">By taking advantage of these prop­ erties, the tokenization problem can be greatly simplified.</S>
			<S sid ="583" ssid = "25">For example, among the huge number of possible tokenizations, we can first concentrate on the much smaller· critical tokenization set, since the former can be completely reproduced from the lat­ ter.</S>
			<S sid ="584" ssid = "26">Furthermore, by contrasting critical tokenizations, we can easily identify a few critically ambiguous positions, which allows us to avoid wasting energy at useless positions.</S>
			<S sid ="585" ssid = "27">7.2 Critical Tokenization and the Syntactic Graph.</S>
			<S sid ="586" ssid = "28">It is worth noting that similar ideas do exist in natural language derivation and parsing.</S>
			<S sid ="587" ssid = "29">For example, Seo and Simmons (1989) introduced the concept of the syntactic graph, which is, in essence, a union of all possible parse trees.</S>
			<S sid ="588" ssid = "30">With this graph representation, &quot;it is fairly easy to focus on the syntactically ambiguous points&quot; (p. 19, italics added).</S>
			<S sid ="589" ssid = "31">These syntactically ambiguous points are critical in at least two senses.</S>
			<S sid ="590" ssid = "32">First, they are the only problems requiring knowledge and heuristics beyond the existing syntax.</S>
			<S sid ="591" ssid = "33">In other words, any syntactic or semantics development should be guided by ambi­ guity resolution at these points.</S>
			<S sid ="592" ssid = "34">If a semantic enhancement does not interact with any of these points, the enhancement is considered ineffective.</S>
			<S sid ="593" ssid = "35">If a grammar revision in turn leads to additional syntactically ambiguous points, such a revision would be in the wrong direction.</S>
			<S sid ="594" ssid = "36">Second, these syntactically ambiguous points are critical in efficiently resolving ambiguity.</S>
			<S sid ="595" ssid = "37">After all, these points are the only places where disambiguation decisions must be made.</S>
			<S sid ="596" ssid = "38">Ideally, we should invest no energy in investigating anything that is irrelevant to these points.</S>
			<S sid ="597" ssid = "39">However, unless all parse trees are merged together to form the syntactic graph, the only thing feasible is to check every possible position in every parse tree by applying all available knowledge and every possible heuristic, since we are unaware of the effectiveness of any checking that occurs beforehand.</S>
			<S sid ="598" ssid = "40">The critical tokenization introduced in this paper has a similar role in string tok­ enization to that of the syntactic graph in sentence parsing.</S>
			<S sid ="599" ssid = "41">By Theorem 3, critical tok­ enization is, in essence, the union of the whole tokenization set and thus the compact representation of it.</S>
			<S sid ="600" ssid = "42">As long as the principle of maximum tokenization is accepted, the resolution of critical ambiguity in tokenization is the only problem requiring knowl­ edge and heuristics beyond the existing dictionary.</S>
			<S sid ="601" ssid = "43">In other words, any introduction of &quot;high-level&quot; knowledge must at least be effective in resolving some critical ambiguities in tokenization.</S>
			<S sid ="602" ssid = "44">This should be a fundamental guideline in tokenization research.</S>
			<S sid ="603" ssid = "45">Even if the principle of maximum tokenization is not accepted, critical ambiguity in tokenization must nevertheless be resolved.</S>
			<S sid ="604" ssid = "46">Therefore, any investment, as mentioned above, will not be a waste in any sense.</S>
			<S sid ="605" ssid = "47">What needs to be undertaken now is to substitute something more precise for the principle of maximum tokenization.</S>
			<S sid ="606" ssid = "48">It is only at this stage that we touch on the problem of identifying and resolving hidden ambiguity in tokenization.</S>
			<S sid ="607" ssid = "49">That is one of the reasons why this type of ambiguity is called hidden.</S>
			<S sid ="608" ssid = "50">7.3 Critical Tokenization and Best-Path Finding.</S>
			<S sid ="609" ssid = "51">The theme in this paper is to study the problem of sentence tokenization in the frame­ work of formal languages, a direction that has recently attracted some attention.</S>
			<S sid ="610" ssid = "52">For instance, in Ma (1996), words in a tokenization dictionary are represented as pro­ duction rules and character strings are modeled as derivatives of these rules under a string concatenation operation.</S>
			<S sid ="611" ssid = "53">Although not stated explicitly in his thesis, this is obviously a finite-state model, as evidenced from his employment of (finite-) state diagrams for representing both the tokenization dictionary and character strings.</S>
			<S sid ="612" ssid = "54">The weighted finite-state transducer model developed by Sproat et al.</S>
			<S sid ="613" ssid = "55">(1996) is another excellent representative example.</S>
			<S sid ="614" ssid = "56">They both stop at merely representing possible tokenizations as a single large finite-state diagram (word graph).</S>
			<S sid ="615" ssid = "57">The focus is then shifted to the problem of defining scores for evaluating each possible tokenization and to the associated problem of searching for the best-path in the word graph.</S>
			<S sid ="616" ssid = "58">To emphasize this point, Ma (1996) explicitly called his approach &quot;evaluation-based.&quot;</S>
			<S sid ="617" ssid = "59">In comparison, we have continued within the framework and established the criti­ cal tokenization together with its interesting properties.</S>
			<S sid ="618" ssid = "60">We believe the additional step is worthwhile.</S>
			<S sid ="619" ssid = "61">While tokenization evaluation is important, it would be more effective if employed at a later stage.</S>
			<S sid ="620" ssid = "62">On the one hand, critical tokenization can help greatly in developing tokenization knowledge and heuristics, especially those tokenization specific understandings, such as the observation of&quot;one tokenization per source&quot; and the trick of highlighting hidden ambiguities by contrasting competing critical tokenizations (Guo 1997).</S>
			<S sid ="621" ssid = "63">While it may not be totally impossible to fully incorporate such knowledge and heuristics into the general framework of path evaluation and searching, they are ap­ parently employed neither in Sproat et al.</S>
			<S sid ="622" ssid = "64">(1996) nor in Ma (1996).</S>
			<S sid ="623" ssid = "65">Further, what has been implemented in the two systems is basically a token unigram function, which has been shown to be practically irrelevant to hidden ambiguity resolution and not to be much better than some simple maximum tokenization approaches such as shortest tokenization (Guo 1997).</S>
			<S sid ="624" ssid = "66">On the other hand, critical tokenization can help significantly in boosting tokeniza­ tion efficiency.</S>
			<S sid ="625" ssid = "67">As has been observed, the tokenization of about 98% of the text can be completed in the first parse of critical point identification, which can be done in linear time.</S>
			<S sid ="626" ssid = "68">Moreover, as practically all acceptable tokenizations are critical tokeniza­ tions and ambiguous critical fragments are generally very short, the remaining 2% of the text with tokenization ambiguities can also be settled efficiently through critical tokenization generation and disambiguation (Guo 1997).</S>
			<S sid ="627" ssid = "69">In comparison, if the best path is to be searched on the token graph of a complete sentence, while a simple evaluation function such as token unigram cannot be very effective in ambiguity resolution, a sophisticated evaluation function incorporating multiple knowledge sources, such as language experiences, statistics, syntax, seman­ tics, and discourse as suggested in Ma (1996), can only be computationally prohibitive, as Ma himself acknowledged.</S>
			<S sid ="628" ssid = "70">In summary, the critical tokenization is crucial both in knowledge development for effective tokenization disambiguation and in system implementation for complete and efficient tokenization.</S>
			<S sid ="629" ssid = "71">Further discussions and examples can be found in Guo (1997).</S>
	</SECTION>
	<SECTION title="Summary. " number = "8">
			<S sid ="630" ssid = "1">The objective in this paper has been to lay down a mathematical foundation for sen­ tence tokenization.</S>
			<S sid ="631" ssid = "2">As the basis of the overall mathematical model, we have introduced both sentence generation and sentence tokenization operations.</S>
			<S sid ="632" ssid = "3">What is unique here is our attempt to model sentence tokenization as the inverse problem of sentence generation.</S>
			<S sid ="633" ssid = "4">Upon that basis, both critical point and critical fragment constitute our first group of findings.</S>
			<S sid ="634" ssid = "5">We have proven that, under a complete dictionary assumption, critical points in sentences are all and only unambiguous token boundaries.</S>
			<S sid ="635" ssid = "6">Critical tokenization is the most important concept among the second group of findings.</S>
			<S sid ="636" ssid = "7">We have proven that every tokenization has a critical tokenization as its supertokenization.</S>
			<S sid ="637" ssid = "8">That is, any tokenization can be reproduced from a critical tok­ enization.</S>
			<S sid ="638" ssid = "9">Critical ambiguity and hidden ambiguity in tokenization constitute our third group of findings.</S>
			<S sid ="639" ssid = "10">We have proven that tokenization ambiguity can be categorized as either critical type or hidden type.</S>
			<S sid ="640" ssid = "11">Moreover, it has been shown that critical tokenization provides a sound basis for precisely describing various types of tokenization ambigu­ ities.</S>
			<S sid ="641" ssid = "12">In short, we have presented a complete and precise understanding of ambiguity in sentence tokenizations.</S>
			<S sid ="642" ssid = "13">While the existence of tokenization ambiguities is jointly described by critical points and critical fragments, the characteristics of tokenization ambiguities will be jointly specified by critical ambiguities and hidden ambiguities.</S>
			<S sid ="643" ssid = "14">Moreover, we have proven that the three widely employed tokenization algorithms, namely forward maximum matching, backward maximum matching, and shortest length matching, are all subclasses of critical tokenization and that critical tokenization is the precise mathematical description of the principle of maximum tokenization.</S>
			<S sid ="644" ssid = "15">In this paper, we have also discussed some important implications of the notion of critical tokenization in the area of character string tokenization research and de­ velopment.</S>
			<S sid ="645" ssid = "16">In this area, our primary claim is that critical tokenization is an excellent intermediate representation that offers much assistance both in the development of effective tokenization knowledge and heuristics and in the improvement and imple­ mentation of efficient tokenization algorithms.</S>
			<S sid ="646" ssid = "17">Besides providing a framework to better understand previous work, as has been attempted here, a good formalization should also lead to new questions and insights.</S>
			<S sid ="647" ssid = "18">While some of the findings and observations achieved so far (Guo 1997) have been mentioned here, much more work remains to be done.</S>
	</SECTION>
	<SECTION title="Acknowledgments">
			<S sid ="648" ssid = "19">The author would like to thank Ho-Chung Lui for his supervision, and Kok-Wee Gan, Zhibiao Wu, Zhendong Dong, Paul Horng Jyh Wu, KimTeng Lua, Chunyu Kit, and TeowHin Ngair for many helpful discussions.</S>
			<S sid ="649" ssid = "20">The author is also very grateful to four anonymous reviewers for their insightful comments on earlier versions of the paper.</S>
			<S sid ="650" ssid = "21">Alexandra Vaz Hugh and Ng Chay Hwee helped in correcting grammar.</S>
	</SECTION>
</PAPER>
