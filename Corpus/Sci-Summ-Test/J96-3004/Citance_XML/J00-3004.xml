<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">Chinese is written without using spaces or other word delimiters.</S>
		<S sid ="2" ssid = "2">Although a text may be thought of as a corresponding sequence of words, there is considerable ambiguity in the placement of boundaries.</S>
		<S sid ="3" ssid = "3">Interpreting a text as a sequence of words is beneficial for some information retrieval and storage tasks: for example, full-text search,word-based compression,and keyphrase extraction.</S>
		<S sid ="4" ssid = "4">We describe a scheme that infers appropriate positions for word boundaries using an adaptive language model that is standard in text compression.</S>
		<S sid ="5" ssid = "5">It is trained on a corpus ofpresegmented text, and when applied to new text, interpolates word boundaries so as to maximize the compression obtained.</S>
		<S sid ="6" ssid = "6">This simple and general method performs well with respect to specialized schemes for Chinese language segmentation.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="7" ssid = "7">Languages such as Chinese and Japanese are written without using any spaces or other word delimiters (except for punctuation marks)-indeed, the Western notion of a word boundary is literally alien (Wu 1998).</S>
			<S sid ="8" ssid = "8">Nevertheless, words are present in these languages, and Chinese words often comprise several characters, typically two, three, or four-five-character words also exist, but they are rare.</S>
			<S sid ="9" ssid = "9">Many characters can stand alone as words in themselves, while on other occasions the same character is the first or second character of a two-character word, and on still others it participates as a component of a three- or four-character word.</S>
			<S sid ="10" ssid = "10">This phenomenon causes obvious ambiguities in word segmentation.</S>
			<S sid ="11" ssid = "11">Readers unfamiliar with Chinese can gain an appreciation of the problem of mul­ tiple interpretations from Figure 1, which shows two alternative interpretations of the same Chinese character sequence.</S>
			<S sid ="12" ssid = "12">The text is a joke that relies on the ambiguity of phrasing.</S>
			<S sid ="13" ssid = "13">Once upon a time, the story goes, a man set out on a long journey.</S>
			<S sid ="14" ssid = "14">Before he could return home the rainy season began, and he had to take shelter at a friend&apos;s house.</S>
			<S sid ="15" ssid = "15">But he overstayed his welcome, and one day his friend wrote him a note: the first line in Figure 1.</S>
			<S sid ="16" ssid = "16">The intended interpretation is shown in the second line, which means &quot;It is raining, the god would like the guest to stay.</S>
			<S sid ="17" ssid = "17">Although the god wants you to stay, I do not!&quot;</S>
			<S sid ="18" ssid = "18">On seeing the note, the visitor took the hint and prepared to leave.</S>
			<S sid ="19" ssid = "19">As a joke he amended the note with the punctuation shown in the third line, which leaves three sentences whose meaning is totally different-&quot;The rainy day, the staying day.</S>
			<S sid ="20" ssid = "20">Would you like me to stay?</S>
			<S sid ="21" ssid = "21">Sure!&quot;</S>
			<S sid ="22" ssid = "22">* School of Computing and Mathematical Sciences, The Robert Gordon University, Aberdeen, Scotland t Computer Science, University of Waikato, Hamilton, New Zealand © 2000 Association for Computational Linguistics A sentence in Chinese Interpretation l Interpretation 2 Figure 1 A Chinese sentence with ambiguity of phrasing.</S>
			<S sid ="23" ssid = "23">A sentence in Chinese Interpretation l Interpretation 2 Figure 2 An example that can be segmented in two different ways.</S>
			<S sid ="24" ssid = "24">physics theory school physics evidence I products I / barber study / / / 1&gt;JJ 1I - science =&apos; credit 1&gt;JJ1I:¥ reason subject / image understand student ph&quot;y&quot;s&apos;icist Figure 3 Example of treating each character in a query as a word.</S>
			<S sid ="25" ssid = "25">This example relies on ambiguity of phrasing, but the same kind of problem can arise with word segmentation.</S>
			<S sid ="26" ssid = "26">Figure 2 shows a more prosaic example.</S>
			<S sid ="27" ssid = "27">For the or­ dinary sentence of the first line, there are two different interpretations depending on the context of the sentence: &quot;I like New Zealand flowers&quot; and &quot;I like fresh broccoli&quot; respectively.</S>
			<S sid ="28" ssid = "28">The fact that machine-readable Chinese text is invariably stored in unsegmented form causes difficulty in applications that use the word as the basic unit.</S>
			<S sid ="29" ssid = "29">For example, search engines index documents by storing a list of the words they contain, and allow the user to retrieve all documents that contain a specified combination of query terms.</S>
			<S sid ="30" ssid = "30">This presupposes that the documents are segmented into words.</S>
			<S sid ="31" ssid = "31">Failure to do so, and treating every character as a word in itself, greatly decreases the precision of retrieval since large numbers of extraneous documents are returned that contain characters, but not words, from the query.</S>
			<S sid ="32" ssid = "32">Figure 3 illustrates what happens when each character in a query is treated as a single-character word.</S>
			<S sid ="33" ssid = "33">The intended query is &quot;physics&quot; or &quot;physicist.&quot;</S>
			<S sid ="34" ssid = "34">The first charac­ ter returns documents about such things as &quot;evidence,&quot; &quot;products,&quot; &quot;body,&quot; &quot;image,&quot; &quot;prices&quot;; while the second returns documents about &quot;theory,&quot; &quot;barber,&quot; and so on.</S>
			<S sid ="35" ssid = "35">Thus many documents that are completely irrelevant to the query will be returned, causing the precision of information retrieval to decrease greatly.</S>
			<S sid ="36" ssid = "36">Similar problems occur in word-based compression, speech recognition, and so on.</S>
			<S sid ="37" ssid = "37">It is true that most search engines allow the user to search for multiword phrases by enclosing them in quotation marks, and this facility could be used to search for multicharacter words in Chinese.</S>
			<S sid ="38" ssid = "38">This, however, runs the risk of retrieving irrelevant documents in which the same characters occur in sequence but with a different in­ tended segmentation.</S>
			<S sid ="39" ssid = "39">More importantly, it imposes on the user an artificial requirement to perform manual segmentation on each full-text query.</S>
			<S sid ="40" ssid = "40">Word segmentation is an important prerequisite for such applications.</S>
			<S sid ="41" ssid = "41">However, it is a difficult and ill-defined task.</S>
			<S sid ="42" ssid = "42">According to Sproat et al. {1996) and Wu and Fung {1994), experiments show that only about 75% agreement between native speakers is to be expected on the &quot;correct&quot; segmentation, and the figure reduces as more people become involved.</S>
			<S sid ="43" ssid = "43">This paper describes a general scheme for segmenting text by inferring the position of word boundaries, thus supplying a necessary preprocessing step for applications like those mentioned above.</S>
			<S sid ="44" ssid = "44">Unlike other approaches, which involve a dictionary of legal words and are therefore language-specific, it works by using a corpus of already­ segmented text for training and thus can easily be retargeted for any language for which a suitable corpus of segmented material is available.</S>
			<S sid ="45" ssid = "45">To infer word boundaries, a general adaptive text compression technique is used that predicts upcoming characters on the basis of their preceding context.</S>
			<S sid ="46" ssid = "46">Spaces are inserted into positions where their presence enables the text to be compressed more effectively.</S>
			<S sid ="47" ssid = "47">This approach means that we can capitalize on existing research in text compression to create good models for word segmentation.</S>
			<S sid ="48" ssid = "48">To build a segmenter for a new language, the only resource required is a corpus of segmented text to train the compression model.</S>
			<S sid ="49" ssid = "49">The structure of this paper is as follows: The next section reviews previous work on the Chinese segmentation problem.</S>
			<S sid ="50" ssid = "50">Then we explain the operation of the adaptive text compression technique that will be used to predict word boundaries.</S>
			<S sid ="51" ssid = "51">Next we show how space insertion can be viewed as a problem of hidden Markov modeling, and how higher-order models, such as the ones used in text compression, can be employed in this way.</S>
			<S sid ="52" ssid = "52">The following section describes several experiments designed to evaluate the success of the new word segmenter.</S>
			<S sid ="53" ssid = "53">Finally we discuss the application of language segmentation in digital libraries.</S>
			<S sid ="54" ssid = "54">Our system for segmenting Chinese text is available on the World Wide Web at http://www.nzdl.org/cgi-bin/congb.</S>
			<S sid ="55" ssid = "55">It takes GB-encoded input text, which can be cut from a Chinese document and pasted into the input window.1 Once the segmenter has been invoked, the result is rewritten into the same window.</S>
	</SECTION>
	<SECTION title="Previous  Methods for Segmenting Chinese. " number = "2">
			<S sid ="56" ssid = "1">The problem of segmenting Chinese text has been studied by researchers for many years; see Wu and Tseng {1993) for a detailed survey.</S>
			<S sid ="57" ssid = "2">Several different algorithms have been proposed, which, generally speaking, can be classified into dictionary-based and statistical-based methods, although other techniques that involve more linguistic information, such as syntactic and semantic knowledge, have been reported in the· natural language processing literature.</S>
			<S sid ="58" ssid = "3">Cheng, Young, and Wong (1999) describe a dictionary-based method.</S>
			<S sid ="59" ssid = "4">Given a dictionary of frequently used Chinese words, an input string is compared with words in the dictionary to find the one that matches the greatest number of characters of the 1 To enable proper viewing, and input, of GB-encoded characters, an appropriate version of Netscape.</S>
			<S sid ="60" ssid = "5">Communicator or Internet Explorer must be used.</S>
			<S sid ="61" ssid = "6">input.</S>
			<S sid ="62" ssid = "7">This is called the maximum forward match heuristic.</S>
			<S sid ="63" ssid = "8">An alternative is to work backwards through the text, resulting in the maximum backward match heuristic.</S>
			<S sid ="64" ssid = "9">It is easy to find situations where these fail.</S>
			<S sid ="65" ssid = "10">To use an English example, forward matching fails on the input &quot;the red ...</S>
			<S sid ="66" ssid = "11">&quot; (it is misinterpreted as &quot;there d ...</S>
			<S sid ="67" ssid = "12">&quot;),while backward matching fails on text ending &quot;... his car&quot; (it is misinterpreted as &quot;... hi scar&quot;).</S>
			<S sid ="68" ssid = "13">Analogous failures occur with Chinese text.</S>
			<S sid ="69" ssid = "14">Dai, Khoo, and Loh (1999) use statistical methods to perform text segmentation.</S>
			<S sid ="70" ssid = "15">They concentrate on two-character words, because two characters is the most com­ mon word length in Chinese.</S>
			<S sid ="71" ssid = "16">Several different notions of frequency of characters and bigrams are explored: relative frequency, document frequency, weighted document frequency, and local frequency.</S>
			<S sid ="72" ssid = "17">They also look at both contextual and positional in­ formation.</S>
			<S sid ="73" ssid = "18">Contextual information is found to be the single most important factor that governs the probability that a bigram forms a word; incorporating the weighted document frequency can improve the model significantly.</S>
			<S sid ="74" ssid = "19">In contrast, the positional frequency is not found to be helpful in determining words.</S>
			<S sid ="75" ssid = "20">Ponte and Croft (1996) introduce two models for word segmentation: word-based and bigram models.</S>
			<S sid ="76" ssid = "21">Both utilize probabilistic automata.</S>
			<S sid ="77" ssid = "22">In the word-based method, a suffix tree of words in the lexicon is used to initialize the model.</S>
			<S sid ="78" ssid = "23">Each node is associated with a probability, which is estimated by segmenting training text using the longest match strategy.</S>
			<S sid ="79" ssid = "24">This makes the segmenter easy to transplant to new languages.</S>
			<S sid ="80" ssid = "25">The bigram model uses the lexicon to initialize probability estimates for each bigram, and the probability with which each bigram occurs, and uses the Baum-Welch algorithm (Rabiner 1989) to update the probabilities as the training text is processed.</S>
			<S sid ="81" ssid = "26">Hockenmaier and Brew (1998) present an algorithm, based on Palmer&apos;s (1997) ex­ periments, that applies a symbolic machine learning technique-transformation-based error-driven learning (Brill1995)-to the problem of Chinese word segmentation.</S>
			<S sid ="82" ssid = "27">Us­ ing a set of rule templates and four distinct initial-state annotators, Palmer concludes that the learning technique works well.</S>
			<S sid ="83" ssid = "28">Hockenmaier and Brew investigate how per­ formance is influenced by different rule templates and corpus size.</S>
			<S sid ="84" ssid = "29">They use three rule templates: simple bigram rules, trigram rules, and more elaborate rules.</S>
			<S sid ="85" ssid = "30">Their experiments indicate that training data size has the most significant influence on per­ formance.</S>
			<S sid ="86" ssid = "31">Good performance can be acquired using simple rules only if the training corpus is large enough.</S>
			<S sid ="87" ssid = "32">Lee, Ng, and Lu (1999) have recently introduced a new segmentation method for a Chinese spell-checking application.</S>
			<S sid ="88" ssid = "33">Using a dictionary with single-character word occurrence frequencies, this scheme first divides text into sentences, then into phrases, and finally into words using a small number of word combinations that are conditioned on a heuristic to avoid delay during spell-checking.</S>
			<S sid ="89" ssid = "34">When compared with forward maximum matching, the new method resolves more than 10% more ambiguities, but enjoys no obvious speed advantage.</S>
			<S sid ="90" ssid = "35">The way in which Chinese characters are used in names differs greatly from the way they are used in ordinary text, and some researchers, notably Sproat et al.</S>
			<S sid ="91" ssid = "36">(1996), have established special-purpose recognizers for Chinese names (and translated for­ eign names), designed to improve the accuracy of automatic segmenters by treating names specially.2 Chinese names always take the form family name followed by given name.</S>
			<S sid ="92" ssid = "37">Whereas family names are limited to a small group of characters, given names can consist of any characters.</S>
			<S sid ="93" ssid = "38">They normally comprise one or two characters, but 2 In English there are significant differences between the frequency distribution of letters in names and.</S>
			<S sid ="94" ssid = "39">in words-for example, compare the size of the T section of a telephone directory with the size of the T section of a dictionary-but such differences are far more pronounced in Chinese.</S>
			<S sid ="95" ssid = "40">three-character names have arisen in recent years to ensure uniqueness when the fam­ ily name is popular-such as Smith or Jones in English.</S>
			<S sid ="96" ssid = "41">Sproat et al.</S>
			<S sid ="97" ssid = "42">(1996) implement special recognizers not only for Chinese names and transliterated foreign names, but for components of morphologically obtained words as well.</S>
			<S sid ="98" ssid = "43">The approach we present is not specially tailored for name recognition, but because it is fully adaptive it is likely that it would yield good performance on names if lists of names were provided as supplementary training text.</S>
			<S sid ="99" ssid = "44">This has not yet been tested.</S>
	</SECTION>
	<SECTION title="Language Modeling using PPM. " number = "3">
			<S sid ="100" ssid = "1">Statistical language models are well developed in the field of text compression.</S>
			<S sid ="101" ssid = "2">Com­ pression methods are usually divided into symbolwise and dictionary schemes (Bell, Cleary, and Witten, 1990).</S>
			<S sid ="102" ssid = "3">Symbolwise methods, which generally make use of adap­ tively generated statistics, give excellent compression-in fact, they include the best known methods.</S>
			<S sid ="103" ssid = "4">Although dictionary methods such as the ZivLempel schemes per­ form less well, they are used in practical compression utilities like Unix compress and gzip because they are fast.</S>
			<S sid ="104" ssid = "5">In our work we use the prediction by partial matching (PPM) symbolwise com­ pression scheme (Cleary and Witten 1984), which has become a benchmark in the compression community.</S>
			<S sid ="105" ssid = "6">It generates &quot;predictions&quot; for each input symbol in turn.</S>
			<S sid ="106" ssid = "7">Each prediction takes the form of a probability distribution that is provided to an encoder.</S>
			<S sid ="107" ssid = "8">The encoder is usually an arithmetic coder; the details of coding are of no relevance to this paper.</S>
			<S sid ="108" ssid = "9">PPM is an n-gram approach that uses finite-context models of characters, where the previous few (say three) characters predict the upcoming one.</S>
			<S sid ="109" ssid = "10">The conditional probability distribution of characters, conditioned on the preceding few characters, is maintained and updated as each character of input is processed.</S>
			<S sid ="110" ssid = "11">This distribution, along with the actual value of the preceding few characters, is used to predict each up­ coming symbol.</S>
			<S sid ="111" ssid = "12">Exactly the same distributions are maintained by the decoder, which updates the appropriate distribution as each character is received.</S>
			<S sid ="112" ssid = "13">This is what we call adaptive modeling: both encoder and decoder maintain the same models-not by communicating the models directly, but by updating them in precisely the same way.</S>
			<S sid ="113" ssid = "14">Rather than using a fixed context length (three was suggested above), the PPM method chooses a maximum context length and maintains statistics for this and all shorter contexts.</S>
			<S sid ="114" ssid = "15">The maximum is five in most of the experiments below, and statistics are maintained for models of order 5, 4, 3, 2, 1, and 0.</S>
			<S sid ="115" ssid = "16">These are not stored separately; they are all kept in a single trie structure.</S>
			<S sid ="116" ssid = "17">PPM incorporates a simple and highly effective method to combine the predictions of the models of different order-often called the problem of &quot;backoff.&quot;</S>
			<S sid ="117" ssid = "18">To encode the next symbol, it starts with the maximum-order model (order 5).</S>
			<S sid ="118" ssid = "19">If that model contains a prediction for the upcoming character, the character is transmitted according to the order 5 distribution.</S>
			<S sid ="119" ssid = "20">Otherwise, both encoder and decoder escape down to order 4.</S>
			<S sid ="120" ssid = "21">There are two possible situations.</S>
			<S sid ="121" ssid = "22">If the order 5 context-that is, the preceding five-character sequence-has not been encountered before, then escape to order 4 is inevitable, and both encoder and decoder can deduce that fact without requiring any communication.</S>
			<S sid ="122" ssid = "23">If not, that is, if the preceding five characters have been encountered in sequence before but not followed by the upcoming character, then only the encoder knows that an escape is necessary.</S>
			<S sid ="123" ssid = "24">In this case, therefore, it must signal this fact to the decoder by transmitting an escape event-and space must be reserved for this event in every probability distribution that the encoder and decoder maintain.</S>
			<S sid ="124" ssid = "25">Table 1 PPM model after processing the string tobeornottobe; c = count, p = prediction probability.</S>
			<S sid ="125" ssid = "26">Order 2 Order 1 Order 0 Prediction c p Prediction c p Prediction c p be -&gt; 0 1 1/2 b -&gt; e 2 3/4 -&gt; b 2 3/26 -&gt; esc 1 1/2 -&gt; esc 1 1/4 -&gt; e 2 3/26 eo -&gt; r 1 1/2 e -&gt; 0 1 1/2 -&gt; n 1 1/26 -&gt; esc 1 1/2 -&gt; esc 1 1/2 -&gt; 0 4 7/26 no -&gt; t 1 1/2 n -&gt; 0 1 1/2 -&gt; r 1 1/26 -&gt; esc 1 1/2 -&gt; esc 1 1/2 -&gt; t 3 5/26 ob -&gt; e 2 3/4 0 -&gt; b 2 3/8 -&gt; esc 6 3/13 -&gt; esc 1 1/4 -&gt; r 1 1/8 or -&gt; n 1 1/2 -&gt; 1 1/8 Order -1 -&gt; esc 1 1/2 -&gt; esc 3 3/8 Prediction c p ot -&gt; t 1 1/2 r -&gt; n 1 1/2 A 1 1/IAI -&gt; esc 1 1/2 -&gt; esc1 1/2 &gt; rn -&gt; 0 -&gt; esc to -&gt; b -&gt; esc -&gt; esc -&gt; 0 2 1/2 -&gt; t 1 1/6 -&gt; esc 2 1/3 Once any necessary escape event has been transmitted and received, both encoder and decoder agree that the upcoming character will be coded by the order 4 model.</S>
			<S sid ="126" ssid = "27">Of course, this may not be possible either, and further escapes may take place.</S>
			<S sid ="127" ssid = "28">Ultimately, the order 0 model may be reached; in this case the character can be transmitted if it is one that has occurred before.</S>
			<S sid ="128" ssid = "29">Otherwise, there is one further escape (to an order -1 model), and the standard ASCII representation of the character is sent.</S>
			<S sid ="129" ssid = "30">The only remaining question is how to calculate the probabilities from the counts­ a simple matter once we have resolved how much space to allocate for the escape probability.</S>
			<S sid ="130" ssid = "31">There has been much discussion of this question, and several different methods have been proposed.</S>
			<S sid ="131" ssid = "32">Our experiments calculate the escape probability in a particular context as !a 1 n where n is the number of times that context has appeared and d is the number of different symbols that have directly followed it (Howard 1993).</S>
			<S sid ="132" ssid = "33">The probability of a character that has occurred c times in that context is c-!</S>
			<S sid ="133" ssid = "34">n Since there are d such characters, and their counts sum to n, it is easy to confirm that the probabilities in the distribution (including the escape probability) sum to 1.</S>
			<S sid ="134" ssid = "35">To illustrate the PPM modeling technique, Table 1 shows the model after the string tobeornottobe has been processed.</S>
			<S sid ="135" ssid = "36">In this illustration the maximum model order is 2 (not 5 as stated above), and each prediction has a count c and a prediction probability p. The probability is determined from the counts associated with the prediction using the formula that we discuss above.</S>
			<S sid ="136" ssid = "37">IAI is the size of the alphabet, and it is this that determines the probability for each unseen character.</S>
			<S sid ="137" ssid = "38">The model in Table 1 is used as follows: Suppose the character following tobe­ ornottobe is o. Since the order 2 context is be, and the upcoming symbol has already been seen once in this context, the order 2 model is used for encoding in this case, and the encoding probability is 1/2.</S>
			<S sid ="138" ssid = "39">Thus the symbol o would be encoded in 1 bit.</S>
			<S sid ="139" ssid = "40">If the next character, instead of o, were t, this has not been seen in the current order 2 context (which is still be).</S>
			<S sid ="140" ssid = "41">Consequently an order 2 escape event is coded (probability 1/2, again in the be context), and the context is truncated to e. Checking the order 1 model, the upcoming character t has not been seen in this context, so an order 1 escape event is coded (probability 1/2 in the e context) and the context is truncated to the null context, corresponding to the order 0 model.</S>
			<S sid ="141" ssid = "42">The character t is finally encoded in this model, with probability 5/26.</S>
			<S sid ="142" ssid = "43">Thus three encodings occur for this one character, with probabilities 1/2, 1/2, and 5/26 respectively, which together amount to just over 5 bits of information.</S>
			<S sid ="143" ssid = "44">If the upcoming character had been x instead of t, a final level of escape, this time to order 0, would have occurred (probability 3/13), and the x would be encoded with a probability of 1/256 (assuming that the alphabet has 256 characters) for a total of just over 10 bits.</S>
			<S sid ="144" ssid = "45">It is clear from Table 1 that, in the context tobeornottobe, if the next character is o it will be encoded by the order 2 model.</S>
			<S sid ="145" ssid = "46">Hence if an escape occurs down to order 1, the next character cannot be o. This makes it unnecessary to reserve probability space for the occurrence of o in the order 1 (or order 0 or order -1) models.</S>
			<S sid ="146" ssid = "47">This idea, which is called exclusion, can be exploited to improve compression.</S>
			<S sid ="147" ssid = "48">A character that occurs at one level is excluded from all lower-order predictions, allowing a greater share of the probability space to be allocated to the other characters in these lower-order models (Bell, Cleary, and Witten 1990).</S>
			<S sid ="148" ssid = "49">For example, if the character b were to follow tobeornottobe it would be encoded with probabilities (1/2,1/2,3/26), without exclusion, leading to a coding requirement of 5.1 bits.</S>
			<S sid ="149" ssid = "50">However, if exclusion was exploited, both encoder and decoder will recognize that escape from order 1 to order 0 is inevitable because the order 1 model adds no characters that were not already predicted by the order 2 model.</S>
			<S sid ="150" ssid = "51">Thus the coding probabilities will be (1/2,1, 3/18) with exclusion, reducing the total code space forb to 3.6 bits.</S>
			<S sid ="151" ssid = "52">An important special case of the exclusion policy occurs at the lowest-level model: for example, the x at the end of the previous paragraph would finally be encoded with a probability of 1/250 rather than 1/256 because characters that have already occurred can never be predicted in the order -1 context.</S>
			<S sid ="152" ssid = "53">One slight further improvement to PPM is incorporated in the experiments: de­ terministic scaling (Teahan 1998).</S>
			<S sid ="153" ssid = "54">Although it probably has negligible effect on our overall results, we record it here for completeness.</S>
			<S sid ="154" ssid = "55">Experiments show that in deter­ ministic contexts, for which d = 1, the probability that the single character that has occurred before reappears is greater than the 11/(2n) implied by the above esti­ mator.</S>
			<S sid ="155" ssid = "56">Consequently, in this case the probability is increased in an ad hoc manner to 11/(6n).</S>
	</SECTION>
	<SECTION title="Using a Hidden  Markov  Model  to Insert  Spaces. " number = "4">
			<S sid ="156" ssid = "1">Inserting spaces into text can be viewed as a hidden Markov modeling problem.</S>
			<S sid ="157" ssid = "2">Being entirely adaptive, the method works regardless of what language it is used with.</S>
			<S sid ="158" ssid = "3">For pedagogical purposes, we will explain it with English text.</S>
			<S sid ="159" ssid = "4">Between every pair of characters lies a potential space.</S>
			<S sid ="160" ssid = "5">Figure 4(a) illustrates the model for the fragment tobeornottobe.</S>
			<S sid ="161" ssid = "6">It contains one node for each letter in the text and one for each possible intercharacter space (represented as dots • in the figure).</S>
			<S sid ="162" ssid = "7">Any given assignment of word boundaries to this text fragment will correspond to (a) (b) Figure 4 Hidden Markov Model for Space Insertion.</S>
			<S sid ="163" ssid = "8">(a) (b) Figure 5 Hidden Markov model for space insertion using an order 1 model.</S>
			<S sid ="164" ssid = "9">a path through the model from beginning (at the left) to end (at the right).</S>
			<S sid ="165" ssid = "10">Of all possible paths, we seek the one that gives the best compression according to the PPM text compression method, suitably primed with English text.</S>
			<S sid ="166" ssid = "11">This path is the correct path, corresponding to the text to be or not to be, shown in bold in Figure 4(b).</S>
			<S sid ="167" ssid = "12">4.1 Markov Modeling with Context.</S>
			<S sid ="168" ssid = "13">Figure 4 can easily be converted into a Markov model for a given order of PPM.</S>
			<S sid ="169" ssid = "14">Suppose we use order 1: then we rewrite Figure 4(a) so that the states are bigrams, as shown in Figure S(a).</S>
			<S sid ="170" ssid = "15">The interpretation of each state is that it corresponds to the last character of the string that labels the state.</S>
			<S sid ="171" ssid = "16">The very first state, labeled t, has no prior context-in PPM terms, that character will be transmitted by escaping down to order 0 (or -1).</S>
			<S sid ="172" ssid = "17">Again, the bold arrows in Figure S(b) shows the path corresponding to the string with spaces inserted correctly.</S>
			<S sid ="173" ssid = "18">t. / &apos;&quot;&apos;...</S>
			<S sid ="174" ssid = "19">(a) (b) (c) Figure 6 Growing a tree for order 1 modeling of tobeornottobe.</S>
			<S sid ="175" ssid = "20">Similar models could be written for higher-order versions of PPM.</S>
			<S sid ="176" ssid = "21">For example, with an order 3 model, states would be labeled by strings of length four (except for the first few states, where the context would be truncated because they occur at the beginning of the string).</S>
			<S sid ="177" ssid = "22">And each state would have variants corresponding to all different ways of inserting space into the four-character string.</S>
			<S sid ="178" ssid = "23">For example, the states corresponding to the sixth character of tobeornottobe would include bear and eeor, as well as •ear, eo•r and •o•r. It is not hard to see that the number of states corresponding to a particular character of the input string increases with model order according to the Fibonnacci series.</S>
			<S sid ="179" ssid = "24">Figure 5(a) shows two states per symbol for order 1, there are three states per symbol for order 2, five for order 3, eight for order 4, thirteen for order 5, and so on.</S>
			<S sid ="180" ssid = "25">4.2 The Space Insertion Algorithm.</S>
			<S sid ="181" ssid = "26">Given a hidden Markov model like the one in Figure 5(a), where probabilities are supplied for each edge according to an order 1 compression model, the space insertion problem is tantamount to finding the sequence of states through the model, from beginning to end, that maximizes the total probability-or, equivalently, that minimizes the number of bits required to represent the text according to that model.</S>
			<S sid ="182" ssid = "27">The following Viterbi-style algorithm can be used to solve this problem.</S>
			<S sid ="183" ssid = "28">Beginning at the initial state, the procedure traces through the model, recording at each state the highest probability of reaching that state from the beginning.</S>
			<S sid ="184" ssid = "29">Thus the two descendants of the start node, nodes to and t•, are assigned the probability of o and •, conditioned in each case on t being the prior character, respectively.</S>
			<S sid ="185" ssid = "30">As more arcs are traversed, the associated probabilities are multiplied: thus the node eo receives the product of the probability of • conditioned on t and of o conditioned on •· When the node ob is reached, it is assigned the greater of the probabilities associated with the two incoming transitions, and so on throughout the model.</S>
			<S sid ="186" ssid = "31">This is the standard dynamic programming technique of storing with each state the result of the best way of reaching that state, and using this result to extend the calculation to the next state.</S>
			<S sid ="187" ssid = "32">To find the optimal state sequence is simply a matter of recording with each state which incoming transition is associated with the greatest probability, and traversing that path in the reverse direction once the final node is reached.</S>
			<S sid ="188" ssid = "33">These models can be generated dynamically by proceeding to predict each char­ acter in turn.</S>
			<S sid ="189" ssid = "34">Figure 6(a) shows the beginning of the tree that results.</S>
			<S sid ="190" ssid = "35">First, the initial node t is expanded into its two children, t• and to.</S>
			<S sid ="191" ssid = "36">Then, these are expanded in turn.</S>
			<S sid ="192" ssid = "37">The first has one child, eo, because a space cannot be followed by another space.</S>
			<S sid ="193" ssid = "38">The second has two, o• and ob.</S>
			<S sid ="194" ssid = "39">Figure 6(b) shows the further expansion of the •o node.</S>
			<S sid ="195" ssid = "40">However, the two children that are created already exist in the tree, and so the existing versions of these nodes are used instead, as in Figure 6(c).</S>
			<S sid ="196" ssid = "41">If this procedure is con Figure 7 _..</S>
			<S sid ="197" ssid = "42">n .--.</S>
			<S sid ="198" ssid = "43">o o-- • t t ·-• t t •-- • o o• b b ........... e no- ot tt ..to_..ob.---..be &quot;...&quot;......</S>
			<S sid ="199" ssid = "44">The space insertion procedure as implemented.</S>
			<S sid ="200" ssid = "45">tinued, the graph structure of Figure S(a) will be created.</S>
			<S sid ="201" ssid = "46">During creation, probability values can be assigned to the nodes, and back pointers inserted to record the best path to each node.</S>
			<S sid ="202" ssid = "47">The illustration in Figure 6 is for an order 1 model, but exactly the same procedure applies for higher-order PPM models.</S>
			<S sid ="203" ssid = "48">4.3 Implementation of the Space Insertion Algorithm.</S>
			<S sid ="204" ssid = "49">Our implementation uses a slight variant of the above procedure for finding the opti­ mal place to insert spaces.</S>
			<S sid ="205" ssid = "50">At each stage, we consider the possibility of adding either the next character, or the next character followed by a space.</S>
			<S sid ="206" ssid = "51">This generates the struc­ ture shown in Figure 7.</S>
			<S sid ="207" ssid = "52">Starting with the null string, both t and t• are generated as successor states.</S>
			<S sid ="208" ssid = "53">From each of these states, either o or o• can be added, and these yield the next states shown.</S>
			<S sid ="209" ssid = "54">The procedure continues, growing the trellis structure using an incremental strategy similar to that illustrated in Figure 6, but modified to take into account the new growth strategy of adding either the next character or the next character followed by a space.</S>
			<S sid ="210" ssid = "55">The search strategy we use is a variant of the stack algorithm for sequential de­ coding (Anderson and Mohan 1984).</S>
			<S sid ="211" ssid = "56">As new nodes are generated, an ordered list is maintained of the best paths generated so far.</S>
			<S sid ="212" ssid = "57">Only the best path is extended.</S>
			<S sid ="213" ssid = "58">The metric used to evaluate a path is the number of bits required for the segmentation sequence it represents, when compressed by the PPM model.</S>
			<S sid ="214" ssid = "59">It is necessary to delete paths from the list in order to make room for newly generated ones.</S>
			<S sid ="215" ssid = "60">We remove all paths that were more than m nodes shorter than the best path so far, where m is the order of the PPM model (5 in our experiments).</S>
			<S sid ="216" ssid = "61">We reasoned that it is extremely unlikely-at least for natural language sequences-that such a path would ever grow to outperform the current best path, because it already lags behind in code length despite the fact that m further letters must be encoded.</S>
	</SECTION>
	<SECTION title="Experimental Evaluation. " number = "5">
			<S sid ="217" ssid = "1">Before describing experiments to assess the success of the new word segmentation method, we first discuss measures that are used to evaluate the accuracy of automatic segmentation.</S>
			<S sid ="218" ssid = "2">We then examine the application of the new segmentation method to English text, and show how it achieves results that significantly outperform the state of the art.</S>
			<S sid ="219" ssid = "3">Next we describe application to a manually segmented corpus of Chinese text; again, excellent results are achieved.</S>
			<S sid ="220" ssid = "4">In a further experiment where we apply a model generated from the corpus to a new, independent, test file, performance deteriorates considerably-as one might expect.</S>
			<S sid ="221" ssid = "5">We then apply the method to a different corpus, and investigate how well the model transfers from one corpus to another.</S>
			<S sid ="222" ssid = "6">We end with a discussion of how the results vary with the order of the compression model used to drive the segmenter.</S>
			<S sid ="223" ssid = "7">5.1 Measuring the Quality of Segmentation.</S>
			<S sid ="224" ssid = "8">We use three measures to evaluate the accuracy of automatic segmentation: recall, precision, and error rate.</S>
			<S sid ="225" ssid = "9">All evaluations use hand-segmentation as the gold stan­ dard, which the automatic method strives to attain.</S>
			<S sid ="226" ssid = "10">To define them, we use the terms N Number of words occurring in the hand-segmentation e c n = c+e Nu mbe r of wor ds inco rrec tly iden tifie d by the auto mati c met hod Nu mbe r of wor ds corr ectly iden tifie d by the auto mati c met hod Nu mbe r of wor ds iden tifie d by the auto mati c met hod Recall and precision are standard information retrieval measures used to assess the quality of a retrieval system in terms of how many of the relevant documents are retrieved (recall) and how many of the retrieved documents are relevant (precision): c recall N&apos; c precision n The overall error rate can be defined as e error rate = N. This in principle can give misleading results-an extreme condition is where the auto­ matic method only identifies a single word, leading to a very small error rate of 1/N despite the fact that all words but one are misidentified.</S>
			<S sid ="227" ssid = "11">However, in all our exper­ iments extreme conditions do not occur because n is always close to N and we find that the error rate is a useful overall indicator of the quality of segmentation.</S>
			<S sid ="228" ssid = "12">We also used the F-measure to compare our results with others: 2 x Precision x Recall F-measure= . . .</S>
			<S sid ="229" ssid = "13">PreCisiOn Recall If the automatic method produces the same number of words as the hand-segmentation, recall and precision both become equal to one minus the error rate.</S>
			<S sid ="230" ssid = "14">A perfect segmenter will have an error rate of zero and recall and precision of 100%.</S>
			<S sid ="231" ssid = "15">All these measures can be calculated automatically from a machine-segmented text, along with the hand-segmented gold standard.</S>
			<S sid ="232" ssid = "16">Both texts are identical except for the points where spaces are inserted: thus we record just the start and end positions of each word in both versions.</S>
			<S sid ="233" ssid = "17">For example, &quot;A BC AED F&quot; in the machine-segmented version is mapped to (1,1} (2,3} (4,6) (7,7), and &quot;A BC A ED F&quot; in the hand-segmented version becomes (1,1) (2,3} (4,4) (5,6) (7,7).</S>
			<S sid ="234" ssid = "18">The number of correctly and incorrectly segmented words is counted by comparing these two sets of positions, indicated by matched and mismatched pairs, respectively-three correct and two incorrect, in this example.</S>
			<S sid ="235" ssid = "19">5.2 Application to English Text.</S>
			<S sid ="236" ssid = "20">It may be helpful for non-Chinese readers to briefly illustrate the success of the space insertion method by showing its application to English text.</S>
			<S sid ="237" ssid = "21">The first part of Table 2 Table 2 Segmenting words in English text.</S>
			<S sid ="238" ssid = "22">Original text the unit of New York-based Loews Corp that makes Kent cigarettes stopped using crocidolite in its Micronite cigarette filters in 1956.</S>
			<S sid ="239" ssid = "23">Without spaces TheunitofNewYorkbasedLoewsCorpthatmakesKentcigarettesstoppedusing­ crocidoliteinitsMicronitecigarettefiltersin1956.</S>
			<S sid ="240" ssid = "24">PPM method the unit of New York-based LoewsCorp that makes Kent cigarettes stopped using croc idolite in its Micronite cigarette filters in 1956.</S>
			<S sid ="241" ssid = "25">USeg method the unit of New York-based Loews Corp that makes Kent cigarettes stopped using c roc id o lite inits Micron it e cigarette filters in 1956.</S>
			<S sid ="242" ssid = "26">shows the original text, with spaces in the proper places.</S>
			<S sid ="243" ssid = "27">The second shows the text with spaces removed, used as input to the segmentation procedure.</S>
			<S sid ="244" ssid = "28">The third shows the output of the PPM-based method described above, while the fourth shows, for comparison, the output of a word-based method for predicting the position of spaces, USeg (Ponte and Croft 1996).</S>
			<S sid ="245" ssid = "29">For this experiment (first reported by Teahan et al. [1998]), PPM was trained on the million-word Brown corpus (Kucera and Francis 1967).</S>
			<S sid ="246" ssid = "30">USeg was trained on a far larger corpus containing 1 Gb of data from the Tipster collection (Broglio, Callan, and Croft 1994).</S>
			<S sid ="247" ssid = "31">Both were tested on the same 500 Kb extract from the Wall Street Journal.</S>
			<S sid ="248" ssid = "32">The recall and precision for PPM were both 99.52%, while the corresponding figures for Useg were 93.56% and 90.03%, respectively.</S>
			<S sid ="249" ssid = "33">This result is particularly noteworthy because PPM had been trained on only a small fraction of the amount of text needed for the word-based scheme.</S>
			<S sid ="250" ssid = "34">The same example was used by Ponte and Croft (1996), and the improved perfor­ mance of the character-based method is evident even in this small example.</S>
			<S sid ="251" ssid = "35">Although the word Micronite does not occur in the Brown Corpus, it was correctly segmented using PPM.</S>
			<S sid ="252" ssid = "36">Likewise, inits was correctly split into in and its.</S>
			<S sid ="253" ssid = "37">PPM makes just two mistakes.</S>
			<S sid ="254" ssid = "38">First, a space was not inserted into LoewsCorp because the single &quot;word&quot; requires only 54.3 bits to encode, whereas Loews Corp requires 55.0 bits.</S>
			<S sid ="255" ssid = "39">Second, an extra space was added to crocidolite because that reduced the number of bits required from 58.7 to 55.3.</S>
			<S sid ="256" ssid = "40">5.3 Application to a Corpus of Chinese Text.</S>
			<S sid ="257" ssid = "41">Our first series of experiments used part of Guo Jin&apos;s Mandarin Chinese PH corpus, containing one million words of newspaper stories from the Xinhua news agency of PR China written between January 1990 and March 1991.</S>
			<S sid ="258" ssid = "42">It is represented in the standard GB coding scheme.</S>
			<S sid ="259" ssid = "43">Table 3 shows the distribution of word lengths in the corpus.</S>
			<S sid ="260" ssid = "44">Single-character words are the most frequent; these and bigrams together constitute almost 94% of words.</S>
			<S sid ="261" ssid = "45">Nearly half the characters appear as constituents of two-character words.</S>
			<S sid ="262" ssid = "46">Some published figures for Chinese language statistics indicate that this corpus may overrepresent single-character words and underrepresent bigrams-for example, Liu (1987) gives figures for modern Chinese of 5%, 75%, 14%, and 6% for one-character, two-character, three-character, and longer words, respectively.</S>
			<S sid ="263" ssid = "47">However, it has been ar­ gued that considering the inherent uncertainty in Chinese word segmentation, general­ purpose segmentation algorithms should segment aggressively rather than conserva­ tively (Wu 1998); consequently this corpus seems appropriate for our use.</S>
			<S sid ="264" ssid = "48">Table 3 Distribution of word length in the corpus.</S>
			<S sid ="265" ssid = "49">Len gth Wo rds Ch ara cte rs 1 55.</S>
			<S sid ="266" ssid = "50">6% 3 6 . 2 % 2 38.</S>
			<S sid ="267" ssid = "51">2% 4 9 . 9 % 3 4.</S>
			<S sid ="268" ssid = "52">2 % 8 . 2 % 4 1.</S>
			<S sid ="269" ssid = "53">6 % 4 . 0 % 5 0.</S>
			<S sid ="270" ssid = "54">2 % 0 . 8 % Ove r 5 0.</S>
			<S sid ="271" ssid = "55">2 % 0 . 9 % Table 4 Results for five 500-word segments from the Chinese corpus (manually checked figures in parentheses).</S>
			<S sid ="272" ssid = "56">File Er ro r ra te R e c a l l P r e c i s i o n F m e a s u r e 1 1.2 % (1.</S>
			<S sid ="273" ssid = "57">0% ) 98.</S>
			<S sid ="274" ssid = "58">4% (98 .6 %) 98.</S>
			<S sid ="275" ssid = "59">8% (99 .0 %) 98.</S>
			<S sid ="276" ssid = "60">6% (98 .8 %) 2 3.6 % (3.</S>
			<S sid ="277" ssid = "61">0% ) 96.</S>
			<S sid ="278" ssid = "62">4% (96 .8 %) 96.</S>
			<S sid ="279" ssid = "63">4% (97 .0 %) 96.</S>
			<S sid ="280" ssid = "64">4% (96 .9 %) 3 4.2 % (4.</S>
			<S sid ="281" ssid = "65">0% ) 95.</S>
			<S sid ="282" ssid = "66">0% (95 .8 %) 95.</S>
			<S sid ="283" ssid = "67">8% (96 .0 %) 95.</S>
			<S sid ="284" ssid = "68">4% (95 .9 %) 4 6.4 % (5.</S>
			<S sid ="285" ssid = "69">2% ) 91.</S>
			<S sid ="286" ssid = "70">0% (92 .2 %) 93.</S>
			<S sid ="287" ssid = "71">4% (94 .7 %) 92.</S>
			<S sid ="288" ssid = "72">2% (93 .4 %) 5 6.6 % (5.</S>
			<S sid ="289" ssid = "73">0% ) 86.</S>
			<S sid ="290" ssid = "74">2% (90 .4 %) 92.</S>
			<S sid ="291" ssid = "75">9% (94 .8 %) 89.</S>
			<S sid ="292" ssid = "76">4% (92 .5 %) Table 4 shows the results for five 500-word test files from the corpus.</S>
			<S sid ="293" ssid = "77">We took part of the corpus that was not used for training, divided it into 500-word segments, removed all spaces, and randomly chose five segments as test files.</S>
			<S sid ="294" ssid = "78">The results show an error rate varying from 1.2% to 6.6%.</S>
			<S sid ="295" ssid = "79">The resulting F-measures indicate that the new algorithm performs better than the one described in Hockenmaier and Brew (1998), who report an F-measure of 87.9 using trigram rules.</S>
			<S sid ="296" ssid = "80">This is particularly significant because the two algorithms use training and test data from the same source.</S>
			<S sid ="297" ssid = "81">The results were also verified by checking them manually.</S>
			<S sid ="298" ssid = "82">This produces slightly different results, for two reasons.</S>
			<S sid ="299" ssid = "83">Firstly, human judgment sometimes accepts a seg­ mentation as correct even though it does not correspond exactly with the corpus version.</S>
			<S sid ="300" ssid = "84">For example, the last word in 1ft $8 !fa-If: is counted as correct even though in the corpus it is written 1t£&apos; fiG -If:.</S>
			<S sid ="301" ssid = "85">Secondly, improper segmentations such as 1jr rPand m 1&apos;1&apos;1rff occur in the corpus.</S>
			<S sid ="302" ssid = "86">When the program makes the same mistakes, it counts as correct in automatic checking, but incorrect in manual checking.</S>
			<S sid ="303" ssid = "87">These two kinds of error virtually canceled each other: when checked manually, file 3, for example, has five fewer errors for the first reason and six more for the second rea­ son, giving error counts of 21 and 20 for automatic and manual checking, respectively.</S>
			<S sid ="304" ssid = "88">5.4 Application to Independent Chinese Text Files.</S>
			<S sid ="305" ssid = "89">In a second test, models from this corpus were evaluated on completely separate data provided by the Institute of Computational Linguistics of Peking University.</S>
			<S sid ="306" ssid = "90">This contained 39 sentences (752 characters), some of which are compound sentences.</S>
			<S sid ="307" ssid = "91">Since no presegmented version was available, all checking was manual.</S>
			<S sid ="308" ssid = "92">This test is interesting because it includes several sentences that are easily mis­ understood, three of which are shown in Figure 8.</S>
			<S sid ="309" ssid = "93">In the first, which reads &quot;I have learned a lot from it,&quot; the second and third characters combine into &apos;from it&apos; and the Computational Linguistics Volume 26, Number 3 1ZJA ::¢fiJ71 *[§ %J I!::¢*400 xt %JI!:¥: -!&apos;l#:¥:&apos;------ Figure 8 Three examples of easily misunderstood sentences.</S>
			<S sid ="310" ssid = "94">Table 5 Error rate (mean and sd) for 1,000-word files from PH and Rocling corpora.</S>
			<S sid ="311" ssid = "95">Testing PH files Rocling files T r a i n i n g PH corpus Rocling corpus 4 2 ± 1 0 . 2 3 1 6 9 . 2 ± 1 9 . 7 0 1 3 3 . 4 ± 1 9 . 5 8 4 4 . 8 ± 1 0 . 8 3 fourth and fifth characters combine into &apos;have learned.&apos;</S>
			<S sid ="312" ssid = "96">However, the third and fourth characters taken together mean &apos;middle school,&apos; which does not occur in the meaning of the sentence.</S>
			<S sid ="313" ssid = "97">In the second and third sentences, the first three characters are the same.</S>
			<S sid ="314" ssid = "98">In the second, &quot;physics is very hard to learn,&quot; the second and third characters should be separated by a space, so that the third character can combine with the fol­ lowing two characters to mean &apos;to learn.&apos;</S>
			<S sid ="315" ssid = "99">However, in the third, &quot;physics is one kind of science,&quot; the first three characters make a single word meaning &apos;physics.&apos;</S>
			<S sid ="316" ssid = "100">The error rate, recall and precision for this test material are 10.8%, 93.4%, and 89.6%, respectively.</S>
			<S sid ="317" ssid = "101">Performance is significantly worse than that of Table 4, because of the nature of the test file.</S>
			<S sid ="318" ssid = "102">Precision is distinctly lower than recall-recall fares better because many relevant words are still retrieved, whereas precision suffers because the automatic segmenter placed too many word boundaries compared with the manual judgment.</S>
			<S sid ="319" ssid = "103">Two aspects of the training data have a profound influence on the model&apos;s accu­ racy.</S>
			<S sid ="320" ssid = "104">First, some errors are obviously caused by deficiencies in the training data, such as improperly segmented common words and names.</S>
			<S sid ="321" ssid = "105">Second, some errors stem from the topics covered by the corpus.</S>
			<S sid ="322" ssid = "106">It is not surprising that the error rate increases when the training and testing text represent different topic areas-such as training on news text and testing on medical text.</S>
			<S sid ="323" ssid = "107">5.5 Application to the Rocling Corpus.</S>
			<S sid ="324" ssid = "108">The Rocling Standard Segmentation Corpus contains about two million presegmented words, represented in the BigS coding scheme.</S>
			<S sid ="325" ssid = "109">We converted it to GB, used one million words for training, and compared the resulting model to that generated from the PH data, also trained on one million words.</S>
			<S sid ="326" ssid = "110">Both models were tested on 10 randomly chosen 1,000-word segments from each corpus (none of this material was used in training).</S>
			<S sid ="327" ssid = "111">The results are shown in Table 5, in terms of the mean and standard deviation (sd) of the errors.</S>
			<S sid ="328" ssid = "112">When the training and testing files come from the same corpus, results are good, with around 42 (for PH) and 45 (for Rocling) errors per thousand words.</S>
			<S sid ="329" ssid = "113">Not surprisingly, performance deteriorates significantly when the PH model is used to segment the Rocling test files or vice versa.</S>
			<S sid ="330" ssid = "114">Several differences between the corpora influence performance.</S>
			<S sid ="331" ssid = "115">Many English words are included in Rocling, whereas in PH only a few letters are used to rep 100 80 60 40 20 0 Figure 9 0.5M 1M 1.5 M 2M Effect of the amount of training data on the performance for each test file.</S>
			<S sid ="332" ssid = "116">Table 6 Error rate (mean and sd) for different amounts of training data.</S>
			<S sid ="333" ssid = "117">O.SM words 1M words l.SM words 2M words Error 63.3 ± 13.69 44.8 ± 10.83 38.8 ± 8.60 35.1 ± 6.74 resent certain items.</S>
			<S sid ="334" ssid = "118">Percentages are represented as 90% or Jt+%in Rocling, instead of SJJ\ZJt+in the PH corpus.</S>
			<S sid ="335" ssid = "119">Quotation marks also differ: ll in Rocling but &quot; &quot; in PH.</S>
			<S sid ="336" ssid = "120">In addition, as is only to be expected in any large collection of natural language, typographical errors occur in both corpora.</S>
			<S sid ="337" ssid = "121">The overall result indicates that our algorithm is robust.</S>
			<S sid ="338" ssid = "122">It performs well so long as the training and testing data come from the same source.</S>
			<S sid ="339" ssid = "123">5.6 Effect of the Amount of Training Data.</S>
			<S sid ="340" ssid = "124">For the Rocling corpus, we experimented with different amounts of training data.</S>
			<S sid ="341" ssid = "125">Four models were trained with successively larger amounts of data, 0.5M, 1M, 1.5M, and 2M words, each training file being an extension of the text in the preceding training file.</S>
			<S sid ="342" ssid = "126">The four models were tested on the 10 randomly-chosen 1,000-word Rocling segments used before.</S>
			<S sid ="343" ssid = "127">The results for the individual test files, in terms of error rate per thousand words, are shown in Figure 9 and summarized in Table 6.</S>
			<S sid ="344" ssid = "128">Larger training sets generally give smaller error, which is only to be expected-although the results for some individual test files flatten out and show no further improvement with larger training files, and in some cases more training data actually increases the number of errors.</S>
			<S sid ="345" ssid = "129">Overall, the error rate is reduced by about 25% for each doubling of the training data.</S>
			<S sid ="346" ssid = "130">5.7 Models of Different Order.</S>
			<S sid ="347" ssid = "131">We have experimented with compression models of different orders on the PH corpus.</S>
			<S sid ="348" ssid = "132">Generally speaking, compression of text improves as model order increases, up to a point determined by the logarithm of the size of the training text.</S>
			<S sid ="349" ssid = "133">Typically, little compression is gained by going beyond order 5 models.</S>
			<S sid ="350" ssid = "134">For segmentation, we observe many errors when a model of order 1 is used.</S>
			<S sid ="351" ssid = "135">For order 3 models, most words are segmented with the same error rate as for order 5 models, though some words are missed when order 2 models are used.</S>
			<S sid ="352" ssid = "136">Figure 10 shows some cases where the order 3 and order 5 models produce dif­ ferent results.</S>
			<S sid ="353" ssid = "137">Some order 5 errors are corrected by the order 3 model, though others Order 3 model result Order 5 model result Figure 10 Results obtained when using order 3 and order 5 models.</S>
			<S sid ="354" ssid = "138">appear even with the lower-order model.</S>
			<S sid ="355" ssid = "139">For example, both results in the first row are incorrect: no space should be inserted in this case, and the four characters should stand together.</S>
			<S sid ="356" ssid = "140">However, the order 3 result is to be preferred to the order 5 result because both two-character words do at least make sense individually, whereas the initial three characters in the order 5 version do not represent a word at all.</S>
			<S sid ="357" ssid = "141">In the second row, the order 5 result is incorrect because the second component does not represent a word.</S>
			<S sid ="358" ssid = "142">In the order 3 result, the first word, containing two characters, is a person&apos;s name.</S>
			<S sid ="359" ssid = "143">The second word could also be correct as it stands, though it would be equally correct if a space had been inserted between the two bigrams.</S>
			<S sid ="360" ssid = "144">On the whole, we find that the order 3 model gives the best results overall, although there is little difference between orders 3, 4, and 5.</S>
	</SECTION>
	<SECTION title="Applications in  a Digital Library. " number = "6">
			<S sid ="361" ssid = "1">Word segmentation forms a valuable component of any Chinese digital library sys­ tem.</S>
			<S sid ="362" ssid = "2">It improves full-text retrieval in two ways: higher-precision searching (that is, fewer false matches), and the ability to incorporate relevance ranking.</S>
			<S sid ="363" ssid = "3">This increases the effectiveness of full-text search and helps to provide users with better feedback.</S>
			<S sid ="364" ssid = "4">For example, one study concludes that the performance of an unsegmented character­ based query is about 10% worse than that of the corresponding segmented query (Broglio, Callan, and Croft 1996).</S>
			<S sid ="365" ssid = "5">Many emerging digital library technologies also pre­ suppose word segmentation-for example, text summarization, document clustering, and keyphrase extraction all rely on word frequencies.</S>
			<S sid ="366" ssid = "6">These would not work well on unsegmented text because character frequencies do not generally reflect word fre­ quencies.</S>
			<S sid ="367" ssid = "7">Once the source text in a digital library exceeds a few megabytes, full-text in­ dexes are needed to process queries in a reasonable time (Witten, Moffat, and Bell 1999).</S>
			<S sid ="368" ssid = "8">Full-text indexing was developed using languages where word boundaries are notated (principally English), and the techniques that were developed rely on word­ based processing.</S>
			<S sid ="369" ssid = "9">Although some techniques-for example stemming (Frakes 1992) and casefolding-are not applicable to Chinese information retrieval, many are.</S>
			<S sid ="370" ssid = "10">Ex­ amples include heuristics for relevance ranking, and query expansion using a language thesaurus.</S>
			<S sid ="371" ssid = "11">Of course, full-text indexes can be built from individual characters rather than words.</S>
			<S sid ="372" ssid = "12">However, these will suffer from the problem of low precision-searches will return many irrelevant documents, where the same characters are used in contexts different from that of the query.</S>
			<S sid ="373" ssid = "13">To reduce false matches to a reasonable level, auxiliary indexes (for example, sentence indexes) will have to be created.</S>
			<S sid ="374" ssid = "14">These will be much larger than regular word-based indexes of paragraphs or documents, and will still not be as accurate.</S>
			<S sid ="375" ssid = "15">Information retrieval systems often rank the results of each search, giving pref­ erence to documents that are more relevant to the query by placing them nearer the beginning of the list.</S>
			<S sid ="376" ssid = "16">Relevance metrics are based on the observation that infrequent words are more important than common ones and should therefore rate more highly.</S>
			<S sid ="377" ssid = "17">Word segmentation is essential for this purpose, because the relationship between the frequency of a word and the frequency of the characters that appear within it is often very weak.</S>
			<S sid ="378" ssid = "18">Without word segmentation, the precision of the result set will be reduced because relevant documents are less likely to be close to the top of the list.</S>
			<S sid ="379" ssid = "19">For example, the word tfj 00 (&quot;to go abroad&quot;) is an infrequent word that appears only twenty times in the PH corpus.</S>
			<S sid ="380" ssid = "20">But its two characters occur frequently: tfj (&quot;to go out&quot;) 13,531 times; and 00 (&quot;country&quot;) 45,010 times.</S>
			<S sid ="381" ssid = "21">In fact 00 is the second most frequent character in the corpus, appearing in 443 separate words.</S>
			<S sid ="382" ssid = "22">Character-based ranking would place little weight on these two characters, even though they are extremely important if the query is tfj 00.</S>
			<S sid ="383" ssid = "23">The word i:E.</S>
			<S sid ="384" ssid = "24">(&quot;also&quot;) is another frequent character, appearing 4,553 times in the PH corpus.</S>
			<S sid ="385" ssid = "25">However, in 4,481 of those cases it appears by itself and contributes little to the meaning of the text.</S>
			<S sid ="386" ssid = "26">If a query contained both of these words, far more weight would be given to i:E, than to the individual characters in tfj 00.</S>
			<S sid ="387" ssid = "27">Word counts also give feedback on the effectiveness of a query.</S>
			<S sid ="388" ssid = "28">They help users judge whether their query was too wide or too narrow, and provide information on which of the terms are most appropriate.</S>
			<S sid ="389" ssid = "29">Word-based processing is essential to a number of emergent new technologies in the digital library field.</S>
			<S sid ="390" ssid = "30">Statistical approaches are enjoying a resurgence in natural language analysis (Klavans and Resnik 1997): examples include text summarization, document clustering, and keyphrase extraction.</S>
			<S sid ="391" ssid = "31">All of these statistical approaches are based on words and word frequencies.</S>
			<S sid ="392" ssid = "32">For instance, keywords and keyphrases for a document can be determined automatically based on features such as the frequency of the phrase in the document relative to its frequency in an independent corpus of like material, and its position of occurrence in the document (Frank et al. 1999).</S>
			<S sid ="393" ssid = "33">A decomposition of text into its constituent words is an essential prerequisite for the application of such techniques.</S>
	</SECTION>
	<SECTION title="Conclusions. " number = "7">
			<S sid ="394" ssid = "1">The problem of word segmentation of Chinese text is important in a variety of con­ texts, particularly with the burgeoning interest in digital libraries and other systems that store and process text on a massive scale.</S>
			<S sid ="395" ssid = "2">Existing techniques are either linguisti­ cally based, using a dictionary of words, or rely on handcrafted segmentation rules, or use adaptive models that have been specifically created for the purpose of Chinese word segmentation.</S>
			<S sid ="396" ssid = "3">We have developed an alternative based on a general-purpose character-level model of text-the kind of models used in the very best text compres­ sion schemes.</S>
			<S sid ="397" ssid = "4">These models are formed adaptively from training text.</S>
			<S sid ="398" ssid = "5">The advantage of using character-level models is that they do not rely on a dic­ tionary and therefore do not necessarily fail on unusual words.</S>
			<S sid ="399" ssid = "6">In effect, they can fall back on general properties of language statistics to process novel text.</S>
			<S sid ="400" ssid = "7">The advantage of basing models on a corpus of training text is that particular characteristics of the text are automatically taken into account in language statistics-as exemplified by the significant differences between the models formed for the PH and Rocling corpora.</S>
			<S sid ="401" ssid = "8">Encouraging results have been obtained using the new scheme.</S>
			<S sid ="402" ssid = "9">Our results com­ pare very favorably with the results of Hockenmaier and Brew (1998) on the PH corpus; unfortunately no other researchers have published quantitative results on a standard corpus.</S>
			<S sid ="403" ssid = "10">Further work is needed to analyze the results of the Rocling corpus in more detail.</S>
			<S sid ="404" ssid = "11">The next step is to use automatically segmented text to investigate the digital li­ brary applications we have described: information retrieval, text summarization, doc­ ument clustering, and keyphrase extraction.</S>
	</SECTION>
	<SECTION title="Acknowledgments">
			<S sid ="405" ssid = "12">We are grateful to Stuart Inglis, Hong Chen, and John Cleary, who provided advice and assistance.</S>
			<S sid ="406" ssid = "13">The corrected version of Guo Jin&apos;s PH corpus and the Rocling corpus were provided by Julia Hockenmaier and Chris Brew at the University of Edinburgh and the Chinese Knowledge Information Processing Group of Academia Sinica, respectively.</S>
			<S sid ="407" ssid = "14">The Institute of Computational Linguistics of Peking University also provided some test material.</S>
			<S sid ="408" ssid = "15">Bill Teahan acknowledges the generous support of the Department of Information Technology, Lund University, Sweden.</S>
			<S sid ="409" ssid = "16">Thanks also to the anonymous referees who have helped us to improve the paper significantly.</S>
	</SECTION>
</PAPER>
