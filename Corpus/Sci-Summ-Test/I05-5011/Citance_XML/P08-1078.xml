<PAPER>
	<ABSTRACT>
		<S sid ="1" ssid = "1">The validity of semantic inferences depends on the contexts in which they are applied.</S>
		<S sid ="2" ssid = "2">We propose a generic framework for handling contextual considerations within applied inference, termed Contextual Preferences.</S>
		<S sid ="3" ssid = "3">This framework defines the various context-aware components needed for inference and their relationships.</S>
		<S sid ="4" ssid = "4">Contextual preferences extend and generalize previous notions, such as selectional preferences, while experiments show that the extended framework allows improving inference quality on real application data.</S>
	</ABSTRACT>
	<SECTION title="Introduction" number = "1">
			<S sid ="5" ssid = "5">Applied semantic inference is typically concerned with inferring a target meaning from a given text.</S>
			<S sid ="6" ssid = "6">For example, to answer “Who wrote Idomeneo?”, Question Answering (QA) systems need to infer the target meaning ‘Mozart wrote Idomeneo’ from a given text “Mozart composed Idomeneo”.</S>
			<S sid ="7" ssid = "7">Following common Textual Entailment terminology (Giampiccolo et al., 2007), we denote the target meaning by h (for hypothesis) and the given text by t. A typical applied inference operation is matching.</S>
			<S sid ="8" ssid = "8">Sometimes, h can be directly matched in t (in the example above, if the given sentence would be literally “Mozart wrote Idomeneo”).</S>
			<S sid ="9" ssid = "9">Generally, the target meaning can be expressed in t in many different ways.</S>
			<S sid ="10" ssid = "10">Indirect matching is then needed, using inference knowledge that may be captured through rules, termed here entailment rules.</S>
			<S sid ="11" ssid = "11">In our example, ‘Mozart wrote Idomeneo’ can be inferred using the rule ‘X compose Y → X write Y ’.</S>
			<S sid ="12" ssid = "12">Recently, several algorithms were proposed for automatically learning entailment rules and paraphrases (viewed as bidirectional entailment rules) (Lin and Pantel, 2001; Ravichandran and Hovy, 2002; Shinyama et al., 2002; Szpektor et al., 2004; Sekine, 2005).</S>
			<S sid ="13" ssid = "13">A common practice is to try matching the structure of h, or of the left-hand-side of a rule r, within t. However, context should be considered to allow valid matching.</S>
			<S sid ="14" ssid = "14">For example, suppose that to find acquisitions of companies we specify the target template hypothesis (a hypothesis with variables) ‘X acquire Y ’.</S>
			<S sid ="15" ssid = "15">This h should not be matched in “children acquire language quickly”, because in this context Y is not a company.</S>
			<S sid ="16" ssid = "16">Similarly, the rule ‘X charge Y → X accuse Y ’ should not be applied to “This store charged my account”, since the assumed sense of ‘charge’ in the rule is different than its sense in the text.</S>
			<S sid ="17" ssid = "17">Thus, the intended contexts for h and r and the context within the given t should be properly matched to verify valid inference.</S>
			<S sid ="18" ssid = "18">Context matching at inference time was often approached in an application-specific manner (Harabagiu et al., 2003; Patwardhan and Riloff, 2007).</S>
			<S sid ="19" ssid = "19">Recently, some generic methods were proposed to handle context-sensitive inference (Dagan et al., 2006; Pantel et al., 2007; Downey et al., 2007; Connor and Roth, 2007), but these usually treat only a single aspect of context matching (see Section 6).</S>
			<S sid ="20" ssid = "20">We propose a comprehensive framework for handling various contextual considerations, termed Contextual Preferences.</S>
			<S sid ="21" ssid = "21">It extends and generalizes previous work, defining the needed contextual components and their relationships.</S>
			<S sid ="22" ssid = "22">We also present and implement concrete representation models and un 683 Proceedings of ACL08: HLT, pages 683–691, Columbus, Ohio, USA, June 2008.</S>
			<S sid ="23" ssid = "23">Qc 2008 Association for Computational Linguistics supervised matching methods for these components.</S>
			<S sid ="24" ssid = "24">While our presentation focuses on semantic inference using lexical-syntactic structures, the proposed framework and models seem suitable for other common types of representations as well.</S>
			<S sid ="25" ssid = "25">We applied our models to a test set derived from the ACE 2005 event detection task, a standard Information Extraction (IE) benchmark.</S>
			<S sid ="26" ssid = "26">We show the benefits of our extended framework for textual inference and present component-wise analysis of the results.</S>
			<S sid ="27" ssid = "27">To the best of our knowledge, these are also the first unsupervised results for event argument extraction in the ACE 2005 dataset.</S>
	</SECTION>
	<SECTION title="Contextual Preferences. " number = "2">
			<S sid ="28" ssid = "1">2.1 Notation.</S>
			<S sid ="29" ssid = "2">As mentioned above, we follow the generic Textual Entailment (TE) setting, testing whether a target meaning hypothesis h can be inferred from a given text t. We allow h to be either a text or a template, a text fragment with variables.</S>
			<S sid ="30" ssid = "3">For example, “The stock rose 8%” entails an instantiation of the template hypothesis ‘X gain Y ’.</S>
			<S sid ="31" ssid = "4">Typically, h represents an information need requested in some application, such as a target predicate in IE.</S>
			<S sid ="32" ssid = "5">In this paper, we focus on parse-based lexical- syntactic representation of texts and hypotheses, and on the basic inference operation of matching.</S>
			<S sid ="33" ssid = "6">Following common practice (de Salvo Braz et al., 2005; Romano et al., 2006; Bar-Haim et al., 2007), h is syntactically matched in t if it can be embedded in t’s parse tree.</S>
			<S sid ="34" ssid = "7">For template hypotheses, the matching induces a mapping between h’s variables and their instantiation in t. Matching h in t can be performed either directly or indirectly using entailment rules.</S>
			<S sid ="35" ssid = "8">An entailment rule r: ‘LH S → RH S’ is a directional entailment relation between two templates.</S>
			<S sid ="36" ssid = "9">h is matched in t using r if LH S is matched in t and h matches RH S. In the example above, r: ‘X rise Y → X gain Y ’ allows us to entail ‘X gain Y ’, with “stock” and “8%” instantiating h’s variables.</S>
			<S sid ="37" ssid = "10">We denote vars(z) the set of variables of z, where z is a template or a rule.</S>
			<S sid ="38" ssid = "11">2.2 Motivation.</S>
			<S sid ="39" ssid = "12">When matching considers only the structure of hypotheses, texts and rules it may result in incorrect inference due to contextual mismatches.</S>
			<S sid ="40" ssid = "13">For example, an IE system may identify mentions of public demonstrations using the hypothesis h: ‘X demonstrate’.</S>
			<S sid ="41" ssid = "14">However, h should not be matched in “Engineers demonstrated the new system”, due to a mismatch between the intended sense of ‘demonstrate’ in h and its sense in t. Similarly, when looking for physical attack mentions using the hypothesis ‘X attack Y ’, we should not utilize the rule r: ‘X accuse Y → X attack Y ’, due to a mismatch between a verbal attack in r and an intended physical attack in h. Finally, r: ‘X produce Y → X lay Y ’ (applicable when X refers to poultry and Y to eggs) should not be matched in t: “Bugatti produce the fastest cars”, due to a mismatch between the meanings of ‘produce’ in r and t. Overall, such incorrect inferences may be avoided by considering contextual information for t, h and r during their matching process.</S>
			<S sid ="42" ssid = "15">2.3 The Contextual Preferences Framework.</S>
			<S sid ="43" ssid = "16">We propose the Contextual Preferences (CP) framework for addressing context at inference time.</S>
			<S sid ="44" ssid = "17">In this framework, the representation of an object z, where z may be a text, a template or an entailment rule, is enriched with contextual information denoted cp(z).</S>
			<S sid ="45" ssid = "18">This information helps constraining or disambiguating the meaning of z, and is used to validate proper matching between pairs of objects.</S>
			<S sid ="46" ssid = "19">We consider two components within cp(z): (a) a representation for the global (“topical”) context in which z typically occurs, denoted cpg (z); (b) a representation for the preferences and constraints (“hard” preferences) on the possible terms that can instantiate variables within z, denoted cpv (z).</S>
			<S sid ="47" ssid = "20">For example, cpv (‘X produce Y → X lay Y ’) may specify that X ’s instantiations should be similar to “chicken” or “duck”.</S>
			<S sid ="48" ssid = "21">Contextual Preferences are used when entailment is assessed between a text t and a hypothesis h, either directly or by utilizing an entailment-rule r. On top of structural matching, we now require that the Contextual Preferences of the participants in the inference will also match.</S>
			<S sid ="49" ssid = "22">When h is directly matched in t, we require that each component in cp(h) will be matched with its counterpart in cp(t).</S>
			<S sid ="50" ssid = "23">When r is utilized, we additionally require that cp(r) will be matched with both cp(t) and cp(h).</S>
			<S sid ="51" ssid = "24">Figure 1 summarizes the matching relationships between the CP Figure 1: The directional matching relationships between a hypothesis (h), an entailment rule (r) and a text (t) in the Contextual Preferences framework.</S>
			<S sid ="52" ssid = "25">components of h, t and r. Like Textual Entailment inference, Contextual Preferences matching is directional.</S>
			<S sid ="53" ssid = "26">When matching h with t we require that the global context preferences specified by cpg (h) would subsume those induced by cpg (t), and that the instantiations of h’s variables in t would adhere to the preferences in cpv (h) (since t should entail h, but not necessarily vice versa).</S>
			<S sid ="54" ssid = "27">For example, if the preferred global context of a hypothesis is sports, it would match a text that discusses the more specific topic of basketball.</S>
			<S sid ="55" ssid = "28">To implement the CP framework, concrete models are needed for each component, specifying its representation, how it is constructed, and an appropriate matching procedure.</S>
			<S sid ="56" ssid = "29">Section 3 describes the specific CP models that were implemented in this paper.</S>
			<S sid ="57" ssid = "30">The CP framework provides a generic view of contextual modeling in applied semantic inference.</S>
			<S sid ="58" ssid = "31">Mapping from a specific application to the generic framework follows the mappings assumed in the Textual Entailment paradigm.</S>
			<S sid ="59" ssid = "32">For example, in QA the hypothesis to be proved corresponds to the affirmative template derived from the question (e.g. h: ‘X invented the PC’ for “Who invented the PC?”).</S>
			<S sid ="60" ssid = "33">Thus, cpg (h) can be constructed with respect to the question’s focus while cpv (h) may be generated from the expected answer type (Moldovan et al., 2000; Harabagiu et al., 2003).</S>
			<S sid ="61" ssid = "34">Construction of hypotheses’ CP for IE is demonstrated in Section 4.</S>
	</SECTION>
	<SECTION title="Contextual Preferences Models. " number = "3">
			<S sid ="62" ssid = "1">This section presents the current models that we implemented for the various components of the CP framework.</S>
			<S sid ="63" ssid = "2">For each component type we describe its representation, how it is constructed, and a cor responding unsupervised match score.</S>
			<S sid ="64" ssid = "3">Finally, the different component scores are combined to yield an overall match score, which is used in our experiments to rank inference instances by the likelihood of their validity.</S>
			<S sid ="65" ssid = "4">Our goal in this paper is to cover the entire scope of the CP framework by including specific models that were proposed in previous work, where available, and elsewhere propose initial models to complete the CP scope.</S>
			<S sid ="66" ssid = "5">3.1 Contextual Preferences for Global Context.</S>
			<S sid ="67" ssid = "6">To represent the global context of an object z we utilize Latent Semantic Analysis (LSA) (Deerwester et al., 1990), a well-known method for representing the contextual-usage of words based on corpus statistics.</S>
			<S sid ="68" ssid = "7">We use LSA analysis of the BNC corpus1, in which every term is represented by a normalized vector of the top 100 SVD dimensions, as described in (Gliozzo, 2005).</S>
			<S sid ="69" ssid = "8">To construct cpg (z) we first collect a set of terms that are representative for the preferred general context of z. Then, the (single) vector which is the sum of the LSA vectors of the representative terms becomes the representation of cpg (z).</S>
			<S sid ="70" ssid = "9">This LSA vector captures the “average” typical contexts in which the representative terms occur.</S>
			<S sid ="71" ssid = "10">The set of representative terms for a text t consists of all the nouns and verbs in it, represented by their lemma and part of speech.</S>
			<S sid ="72" ssid = "11">For a rule r: ‘LH S → RH S’, the representative terms are the words appearing in LH S and in RH S. For example, the representative terms for ‘X divorce Y → X marry Y ’ are {divorce:v, marry:v}.</S>
			<S sid ="73" ssid = "12">As mentioned earlier, construction of hypotheses and their contextual preferences depends on the application at hand.</S>
			<S sid ="74" ssid = "13">In our experiments these are defined manually, as described in Section 4, derived from the manual definitions of target meanings in the IE data.</S>
			<S sid ="75" ssid = "14">The score of matching the cpg components of two objects, denoted by mg (·, ·), is the Cosine similarity of their LSA vectors.</S>
			<S sid ="76" ssid = "15">Negative values are set to 0.</S>
			<S sid ="77" ssid = "16">3.2 Contextual Preferences for Variables.</S>
			<S sid ="78" ssid = "17">3.2.1 Representation For comparison with prior work, we follow (Pan- tel et al., 2007) and represent preferences for vari 1 http://www.natcorp.ox.ac.uk/ able instantiations using a distributional approach, and in addition incorporate a standard specification of named-entity types.</S>
			<S sid ="79" ssid = "18">Thus, cpv is represented by two lists.</S>
			<S sid ="80" ssid = "19">The first list, denoted cpv:e, contains examples for valid instantiations of that variable.</S>
			<S sid ="81" ssid = "20">For example, cpv:e(X kill Y → Y die of X ) may be [X : {snakebite, disease}, Y : {man, patient}].</S>
			<S sid ="82" ssid = "21">The second list, denoted cpv:n, contains the variable’s preferred named-entity types (if any).</S>
			<S sid ="83" ssid = "22">For example, cpv:n(X born in Y ) may be [X : {Person}, Y : {Location}].</S>
			<S sid ="84" ssid = "23">We denote cpv:e(z)[j] and cpv:n(z)[j] as the lists for a specific variable j of the object z. For a text t, in which a template p is matched, the preference cpv:e(t) for each template variable is simply its instantiation in t. For example, when ‘X eat Y ’ is matched in t: “Many Americans eat fish regularly”, we construct cpv:e(t) = [X : {Many Americans}, Y : {fish}].</S>
			<S sid ="85" ssid = "24">Similarly, cpv:n(t) for each variable is the named-entity type of its instantiation in t (if it is a named entity).</S>
			<S sid ="86" ssid = "25">We identify entity types using the default Lingpipe2 Named-Entity Recognizer (NER), which recognizes the types Location, Person and Organization.</S>
			<S sid ="87" ssid = "26">In the above example, cpv:n(t)[X ] would be {Person}.</S>
			<S sid ="88" ssid = "27">For a rule r: LH S → RH S, we automatically add to cpv:e(r) all the variable instantiations that were found common for both LH S and RH S in a corpus (see Section 4), as in (Pantel et al., 2007; Pen- nacchiotti et al., 2007).</S>
			<S sid ="89" ssid = "28">To construct cpv:n(r), we currently use a simple approach where each individual term in cpv:e(r) is analyzed by the NER system, and its type (if any) is added to cpv:n(r).</S>
			<S sid ="90" ssid = "29">For a template hypothesis, we currently represent cpv (h) only by its list of preferred named-entity types, cpv:n. Similarly to cpg (h), the preferred types for each template variable were adapted from those defined in our IE data (see Section 4).</S>
			<S sid ="91" ssid = "30">To allow compatible comparisons with previous work (see Sections 5 and 6), we utilize in this paper only cpv:e when matching between cpv (r) and cpv (t), as only this representation was examined in prior work on context-sensitive rule applications.</S>
			<S sid ="92" ssid = "31">cpv:n is utilized for context matches involving cpv (h).</S>
			<S sid ="93" ssid = "32">We denote the score of matching two cpv components by mv (·, ·).</S>
			<S sid ="94" ssid = "33">2 http://www.alias-i.com/lingpipe/ 3.2.2 Matching cpv:e Our primary matching method is based on replicating the best-performing method reported in (Pan- tel et al., 2007), which utilizes the CBC distributional word clustering algorithm (Pantel, 2003).</S>
			<S sid ="95" ssid = "34">In short, this method extends each cpv:e list with CBC clusters that contain at least one term in the list, scoring them according to their “relevancy”.</S>
			<S sid ="96" ssid = "35">The score of matching two cpv:e lists, denoted here SC BC (·, ·), is the score of the highest scoring member that appears in both lists.</S>
			<S sid ="97" ssid = "36">We applied the final binary match score presented in (Pantel et al., 2007), denoted here binaryC BC : mv:e(r, t) is 1 if SC BC (r, t) is above a threshold and 0 otherwise.</S>
			<S sid ="98" ssid = "37">As a more natural ranking method, we also utilize SC BC directly, denoted rankedC BC , having mv:e(r, t) = SC BC (r, t).</S>
			<S sid ="99" ssid = "38">In addition, we tried a simpler method that directly compares the terms in two cpv:e lists, utilizing the commonly-used term similarity metric of (Lin, 1998a).</S>
			<S sid ="100" ssid = "39">This method, denoted LI N , uses the same raw distributional data as CBC but computes only pairwise similarities, without any clustering phase.</S>
			<S sid ="101" ssid = "40">We calculated the scores of the 1000 most similar terms for every term in the Reuters RVC1 corpus3.</S>
			<S sid ="102" ssid = "41">Then, a directional similarity of term a to term b, s(a, b), is set to be their similarity score if a is in b’s 1000 most similar terms and 0 otherwise.</S>
			<S sid ="103" ssid = "42">The final score of matching r with t is determined by a nearest-neighbor approach, as the score of the most similar pair of terms in the corresponding two lists of the same variable: mv:e(r, t) = maxj∈vars(r)[maxa∈cpv:e (t)[j],b∈cpv:e (r)[j][s(a, b)]].</S>
			<S sid ="104" ssid = "43">3.2.3 Matching cpv:n We use a simple scoring mechanism for comparing between two named-entity types a and b, s(a, b): 1 for identical types and 0.8 otherwise.</S>
			<S sid ="105" ssid = "44">A variable j has a single preferred entity type in cpv:n(t)[j], the type of its instantiation in t. However, it can have several preferred types for h. When matching h with t, j’s match score is that of its highest scoring type, and the final score is the product of all variable scores: mv:n(h, t) = j∈vars(h)(maxa∈cpv:n (h)[j][s(a, cpv:n(t)[j])]).</S>
			<S sid ="106" ssid = "45">Variable j may also have several types in r, the 3 http://about.reuters.com/researchandstandards/corpus/ types of the common arguments in cpv:e(r).</S>
			<S sid ="107" ssid = "46">When matching h with r, s(a, cpv:n(t)[j]) is replaced with the average score for a and each type in cpv:n(r)[j].</S>
			<S sid ="108" ssid = "47">3.3 Overall Score for a Match.</S>
			<S sid ="109" ssid = "48">A final score for a given match, denoted allCP, is obtained by the product of all six matching scores of the various CP components (multiplying by 1 if a component score is missing).</S>
			<S sid ="110" ssid = "49">The six scores are the results of matching any of the two components of h, t and r: mg (h, t), mv (h, t), mg (h, r), mv (h, r), mg (r, t) and mv (r, t) (as specified above, mv (r, t) is based on matching cpv:e while mv (h, r) and mv (h, t) are based on matching cpv:n).</S>
			<S sid ="111" ssid = "50">We use rankedC BC for calculating mv (r, t).</S>
			<S sid ="112" ssid = "51">Unlike previous work (e.g.</S>
			<S sid ="113" ssid = "52">(Pantel et al., 2007)), we also utilize the prior score of a rule r, which is provided by the rule-learning algorithm (see next section).</S>
			<S sid ="114" ssid = "53">We denote by allCP+pr the final match score obtained by the product of the allCP score with the prior score of the matched rule.</S>
	</SECTION>
	<SECTION title="Experimental Settings. " number = "4">
			<S sid ="115" ssid = "1">Evaluating the contribution of Contextual Preferences models requires: (a) a sample of test hypotheses, and (b) a corresponding corpus that contains sentences which entail these hypotheses, where all hypothesis matches (either direct or via rules) are annotated.</S>
			<S sid ="116" ssid = "2">We found that the available event mention annotations in the ACE 2005 training set4 provide a useful test set that meets these generic criteria, with the added value of a standard real-world dataset.</S>
			<S sid ="117" ssid = "3">The ACE annotation includes 33 types of events, for which all event mentions are annotated in the corpus.</S>
			<S sid ="118" ssid = "4">The annotation of each mention includes the instantiated arguments for the predicates, which represent the participants in the event, as well as general attributes such as time and place.</S>
			<S sid ="119" ssid = "5">ACE guidelines specify for each event type its possible arguments, where all arguments are optional.</S>
			<S sid ="120" ssid = "6">Each argument is associated with a semantic role and a list of possible named-entity types.</S>
			<S sid ="121" ssid = "7">For instance, an Injure event may have the arguments {Agent, Victim, Instrument, Time, Place}, where Victim should be a person.</S>
			<S sid ="122" ssid = "8">For each event type we manually created a small set of template hypotheses that correspond to the 4 http://projects.ldc.upenn.edu/ace/ given event predicate, and specified the appropriate semantic roles for each variable.</S>
			<S sid ="123" ssid = "9">We considered only binary hypotheses, due to the type of available entailment rules (see below).</S>
			<S sid ="124" ssid = "10">For Injure, the set of hypotheses included ‘A injure V’ and ‘injure V in T’ where role(A)={Agent, Instrument}, role(V)={Victim}, and role(T)={Time, Place}.</S>
			<S sid ="125" ssid = "11">Thus, correct match of an argument corresponds to correct role identification.</S>
			<S sid ="126" ssid = "12">The templates were represented as Minipar (Lin, 1998b) dependency parse-trees.</S>
			<S sid ="127" ssid = "13">The Contextual Preferences for h were constructed manually: the named-entity types for cpv:n(h) were set by adapting the entity types given in the guidelines to the types supported by the Ling- pipe NER (described in Section 3.2).</S>
			<S sid ="128" ssid = "14">cpg (h) was generated from a short list of nouns and verbs that were extracted from the verbal event definition in the ACE guidelines.</S>
			<S sid ="129" ssid = "15">For Injure, this list included {injure:v, injury:n, wound:v}.</S>
			<S sid ="130" ssid = "16">This assumes that when writing down an event definition the user would also specify such representative keywords.</S>
			<S sid ="131" ssid = "17">Entailment-rules for a given h (rules in which RHS is equal to h) were learned automatically by the DIRT algorithm (Lin and Pantel, 2001), which also produces a quality score for each rule.</S>
			<S sid ="132" ssid = "18">We implemented a canonized version of DIRT (Szpektor and Dagan, 2007) on the Reuters corpus parsed by Minipar.</S>
			<S sid ="133" ssid = "19">Each rule’s arguments for cpv (r) were also collected from this corpus.</S>
			<S sid ="134" ssid = "20">We assessed the CP framework by its ability to correctly rank, for each predicate (event), all the candidate entailing mentions that are found for it in the test corpus.</S>
			<S sid ="135" ssid = "21">Such ranking evaluation is suitable for unsupervised settings, with a perfect ranking placing all correct mentions before any incorrect ones.</S>
			<S sid ="136" ssid = "22">The candidate mentions are found in the parsed test corpus by matching the specified event hypotheses, either directly or via the given set of entailment rules, using a syntactic matcher similar to the one in (Szpektor and Dagan, 2007).</S>
			<S sid ="137" ssid = "23">Finally, the mentions are ranked by their match scores, as described in Section 3.3.</S>
			<S sid ="138" ssid = "24">As detailed in the next section, those candidate mentions which are also annotated as mentions of the same event in ACE are considered correct.</S>
			<S sid ="139" ssid = "25">The evaluation aims to assess the correctness of inferring a target semantic meaning, which is de noted by a specific predicate.</S>
			<S sid ="140" ssid = "26">Therefore, we eliminated four ACE event types that correspond to multiple distinct predicates.</S>
			<S sid ="141" ssid = "27">For instance, the Transfer- Money event refers to both donating and lending money, which are not distinguished by the ACE annotation.</S>
			<S sid ="142" ssid = "28">We also omitted three events with less than 10 mentions and two events for which the given set of learned rules could not match any mention.</S>
			<S sid ="143" ssid = "29">We were left with 24 event types for evaluation, which amount to 4085 event mentions in the dataset.</S>
			<S sid ="144" ssid = "30">Out of these, our binary templates can correctly match only mentions with at least two arguments, which appear 2076 times in the dataset.</S>
			<S sid ="145" ssid = "31">Comparing with previous evaluation methodologies, in (Szpektor et al., 2007; Pantel et al., 2007) proper context matching was evaluated by post-hoc judgment of a sample of rule applications for a sample of rules.</S>
			<S sid ="146" ssid = "32">Such annotation needs to be repeated each time the set of rules is changed.</S>
			<S sid ="147" ssid = "33">In addition, since the corpus annotation is not exhaustive, recall could not be computed.</S>
			<S sid ="148" ssid = "34">By contrast, we use a standard real-world dataset, in which all mentions are annotated.</S>
			<S sid ="149" ssid = "35">This allows immediate comparison of different rule sets and matching methods, without requiring any additional (post-hoc) annotation.</S>
	</SECTION>
	<SECTION title="Results and Analysis. " number = "5">
			<S sid ="150" ssid = "1">We experimented with three rule setups over the ACE dataset, in order to measure the contribution of the CP framework.</S>
			<S sid ="151" ssid = "2">In the first setup no rules are used, applying only direct matches of template hypotheses to identify event mentions.</S>
			<S sid ="152" ssid = "3">In the other two setups we also utilized DIRT ’s top 50 or 100 rules for each hypothesis.</S>
			<S sid ="153" ssid = "4">A match is considered correct when all matched arguments are extracted correctly according to their annotated event roles.</S>
			<S sid ="154" ssid = "5">This main measurement is denoted All.</S>
			<S sid ="155" ssid = "6">As an additional measurement, denoted Any, we consider a match as correct if at least one argument is extracted correctly.</S>
			<S sid ="156" ssid = "7">Once event matches are extracted, we first measure for each event its Recall, the number of correct mentions identified out of all annotated event men- tions5 and Precision, the number of correct matches out of all extracted candidate matches.</S>
			<S sid ="157" ssid = "8">These figures 5 For Recall, we ignored mentions with less than two arguments, as they cannot be correctly matched by binary templates.</S>
			<S sid ="158" ssid = "9">quantify the baseline performance of the DIRT rule set used.</S>
			<S sid ="159" ssid = "10">To assess our ranking quality, we measure for each event the commonly used Average Precision (AP) measure (Voorhees and Harmann, 1998), which is the area under the non-interpolated recall- precision curve, while considering for each setup all correct extracted matches as 100% Recall.</S>
			<S sid ="160" ssid = "11">Overall, we report Mean Average Precision (MAP), macro average Precision and macro average Recall over the ACE events.</S>
			<S sid ="161" ssid = "12">Tables 1 and 2 summarize the main results of our experiments.</S>
			<S sid ="162" ssid = "13">As far as we know, these are the first published unsupervised results for identifying event arguments in the ACE 2005 dataset.</S>
			<S sid ="163" ssid = "14">Examining Recall, we see that it increases substantially when rules are applied: by more than 100% for the top 50 rules, and by about 150% for the top 100, showing the benefit of entailment-rules to covering language variability.</S>
			<S sid ="164" ssid = "15">The difference between All and Any results shows that about 65% of the rules that correctly match one argument also match correctly both arguments.</S>
			<S sid ="165" ssid = "16">We use two baselines for measuring the CP ranking contribution: Precision, which corresponds to the expected MAP of random ranking, and MAP of ranking using the prior rule score provided by DIRT.</S>
			<S sid ="166" ssid = "17">Without rules, the baseline All Precision is 34.1%, showing that even the manually constructed hypotheses, which correspond directly to the event predicate, extract event mentions with limited accuracy when context is ignored.</S>
			<S sid ="167" ssid = "18">When rules are applied, Precision is very low.</S>
			<S sid ="168" ssid = "19">But ranking is considerably improved using only the prior score (from 1.4% to 22.7% for 50 rules), showing that the prior is an informative indicator for valid matches.</S>
			<S sid ="169" ssid = "20">Our main result is that the allCP and allCP+pr methods rank matches statistically significantly better than the baselines in all setups (according to the Wilcoxon double-sided signed-ranks test at the level of 0.01 (Wilcoxon, 1945)).</S>
			<S sid ="170" ssid = "21">In the All setup, ranking is improved by 70% for direct matching (Table 1).</S>
			<S sid ="171" ssid = "22">When entailment-rules are also utilized, prior-only ranking is improved by about 35% and 50% when using allCP and allCP+pr, respectively (Table 2).</S>
			<S sid ="172" ssid = "23">Figure 2 presents the average Recall-Precision curve of the ‘50 Rules, All’ setup for applying allCP or allCP+pr, compared to prior-only ranking baseline (other setups behave similarly).</S>
			<S sid ="173" ssid = "24">The improvement in ranking is evident: the drop in precision is signif 100 50 Rules - All.</S>
			<S sid ="174" ssid = "25">90 80 Table 1: Recall (R), Precision (P) and Mean Average Precision (MAP) when only matching template hypotheses directly.</S>
			<S sid ="175" ssid = "26"># Rule s R ( % ) P ( % ) M A P ( % ) pri or all CP all CP +p r All 50 29 .6 1.</S>
			<S sid ="176" ssid = "27">4 22 .7 3 0 . 6 3 4 . 1 10 0 34 .9 0.</S>
			<S sid ="177" ssid = "28">7 20 .5 2 6 . 3 3 0 . 2 An y 50 46 .5 3.</S>
			<S sid ="178" ssid = "29">5 41 .2 4 3 . 7 4 8 . 6 10 0 52 .9 1.</S>
			<S sid ="179" ssid = "30">8 35 .5 3 5 . 1 4 0 . 8 Table 2: Recall (R), Precision (P) and Mean Average Precision (MAP) when also using rules for matching.</S>
			<S sid ="180" ssid = "31">icantly slower when CP is used.</S>
			<S sid ="181" ssid = "32">The behavior of CP with and without the prior is largely the same up to 50% Recall, but later on our implemented CP models are noisier and should be combined with the prior rule score.</S>
			<S sid ="182" ssid = "33">Templates are incorrectly matched for several reasons.</S>
			<S sid ="183" ssid = "34">First, there are context mismatches which are not scored sufficiently low by our models.</S>
			<S sid ="184" ssid = "35">Another main cause is incorrect learned rules in which LH S and RH S are topically related, e.g. ‘X convict Y → X arrest Y ’, or rules that are used in the wrong entailment direction, e.g. ‘X marry Y → X divorce Y ’ (DIRT does not learn rule direction).</S>
			<S sid ="185" ssid = "36">As such rules do correspond to plausible contexts of the hypothesis, their matches obtain relatively high CP scores.</S>
			<S sid ="186" ssid = "37">In addition, some incorrect matches are caused by our syntactic matcher, which currently does not handle certain phenomena such as co-reference, modal- ity or negation, and due to Minipar parse errors.</S>
			<S sid ="187" ssid = "38">5.1 Component Analysis.</S>
			<S sid ="188" ssid = "39">Table 3 displays the contribution of different CP components to ranking, when adding only that component’s match score to the baselines, and under ablation tests, when using all CP component scores except the tested component, with or without the prior.</S>
			<S sid ="189" ssid = "40">As it turns out, matching h with t (i.e. cp(h, t), which combines cpg (h, t) and cpv (h, t)) is most useful.</S>
			<S sid ="190" ssid = "41">With our current models, using only cp(h, t) along with the prior, while ignoring cp(r), achieves 70 60 50 40 30 20 10 0 0 10 20 30 40 50 60 70 80 90 100 Relative Recall baseline CP CP + prior Figure 2: Recall-Precision curves for ranking using: (a) only the prior (baseline); (b) allCP; (c) allCP+pr.</S>
			<S sid ="191" ssid = "42">the highest score in the table.</S>
			<S sid ="192" ssid = "43">The strong impact of matching h and t’s preferences is also evident in Table 1, where ranking based on either cpg or cpv substantially improves precision, while their combination provides the best ranking.</S>
			<S sid ="193" ssid = "44">These results indicate that the two CP components capture complementary information and both are needed to assess the correctness of a match.</S>
			<S sid ="194" ssid = "45">When ignoring the prior rule score, cp(r, t) is the major contributor over the baseline Precision.</S>
			<S sid ="195" ssid = "46">For cpv (r, t), this is in synch with the result in (Pantel et al., 2007), which is based on this single model without utilizing prior rule scores.</S>
			<S sid ="196" ssid = "47">On the other hand, cpv (r, t) does not improve the ranking when the prior is used, suggesting that this contextual model for the rule’s variables is not stronger than the context-insensitive prior rule score.</S>
			<S sid ="197" ssid = "48">Furthermore, relative to this cpv (r, t) model from (Pantel et al., 2007), our combined allCP model, with or without the prior (first row of Table 2), obtains statistically significantly better ranking (at the level of 0.01).</S>
			<S sid ="198" ssid = "49">Comparing between the algorithms for matching cpv:e (Section 3.2.2) we found that while rankedC BC is statistically significantly better than binaryC BC , rankedC BC and LI N generally achieve the same results.</S>
			<S sid ="199" ssid = "50">When considering the tradeoffs between the two, LI N is based on a much simpler learning algorithm while C BC ’s output is more compact and allows faster CP matches.</S>
			<S sid ="200" ssid = "51">Addit ion To Abla tion From P pr io r all C P all CP +p r Ba sel ine 1 . 4 2 2 . 7 3 0 . 6 3 4 . 1 cp g (h, t) ∗ 1 0.</S>
			<S sid ="201" ssid = "52">4 ∗ 3 5.</S>
			<S sid ="202" ssid = "53">4 3 2 . 4 3 3 . 7 cp v (h, t) ∗ 1 1.</S>
			<S sid ="203" ssid = "54">0 2 9 . 9 2 7 . 6 3 2 . 9 cp (h, t) ∗ 8 . 9 ∗ 37 .5 2 8 . 6 3 0 . 0 cp g (r, t) ∗ 4 . 2 ∗ 3 0.</S>
			<S sid ="204" ssid = "55">6 3 2.</S>
			<S sid ="205" ssid = "56">5 3 5 . 4 cp v (r, t) ∗ 2 1.</S>
			<S sid ="206" ssid = "57">7 2 1 . 9 ∗ 1 2.</S>
			<S sid ="207" ssid = "58">9 3 3 . 6 cp (r, t) ∗ 2 6.</S>
			<S sid ="208" ssid = "59">0 ∗ 2 9.</S>
			<S sid ="209" ssid = "60">6 ∗ 1 7.</S>
			<S sid ="210" ssid = "61">9 3 6 . 8 cp g (h, r) ∗ 8 . 1 2 2 . 4 3 1 . 9 3 4 . 3 cp v (h, r) ∗ 1 0.</S>
			<S sid ="211" ssid = "62">7 2 2 . 7 ∗ 2 7.</S>
			<S sid ="212" ssid = "63">9 3 4 . 4 cp (h, r) ∗ 1 6.</S>
			<S sid ="213" ssid = "64">5 2 2 . 4 ∗ 2 9.</S>
			<S sid ="214" ssid = "65">2 3 4 . 4 cp g (h, r, t) ∗ 7 . 7 ∗ 3 0.</S>
			<S sid ="215" ssid = "66">2 ∗ 2 7.</S>
			<S sid ="216" ssid = "67">5 ∗ 2 9 . 2 cp v (h, r, t) ∗ 27 .5 2 9 . 2 ∗ 7 . 7 3 0 . 2 ∗ Indicates statistically significant changes compared to the baseline, according to the Wilcoxon test at the level of 0.01.</S>
			<S sid ="217" ssid = "68">Table 3: MAP(%), under the ‘50 rules, All’ setup, when adding component match scores to Precision (P) or prior- only MAP baselines, and when ranking with allCP or allCP+pr methods but ignoring that component scores.</S>
			<S sid ="218" ssid = "69">Currently, some models do not improve the results when the prior is used.</S>
			<S sid ="219" ssid = "70">Yet, we would like to further weaken the dependency on the prior score, since it is biased towards frequent contexts.</S>
			<S sid ="220" ssid = "71">We aim to properly identify also infrequent contexts (or meanings) at inference time, which may be achieved by better CP models.</S>
			<S sid ="221" ssid = "72">More generally, when used on top of all other components, some of the models slightly degrade performance, as can be seen by those figures in the ablation tests which are higher than the corresponding baseline.</S>
			<S sid ="222" ssid = "73">However, due to their different roles, each of the matching components might capture some unique preferences.</S>
			<S sid ="223" ssid = "74">For example, cp(h, r) should be useful to filter out rules that don’t match the intended meaning of the given h. Overall, this suggests that future research for better models should aim to obtain a marginal improvement by each component.</S>
	</SECTION>
	<SECTION title="Related Work. " number = "6">
			<S sid ="224" ssid = "1">Context sensitive inference was mainly investigated in an application-dependent manner.</S>
			<S sid ="225" ssid = "2">For example, (Harabagiu et al., 2003) describe techniques for identifying the question focus and the answer type in QA.</S>
			<S sid ="226" ssid = "3">(Patwardhan and Riloff, 2007) propose a supervised approach for IE, in which relevant text regions for a target relation are identified prior to applying extraction rules.</S>
			<S sid ="227" ssid = "4">Recently, the need for context-aware inference was raised (Szpektor et al., 2007).</S>
			<S sid ="228" ssid = "5">(Pantel et al., 2007) propose to learn the preferred instantiations of rule variables, termed Inferential Selectional Preferences (ISP).</S>
			<S sid ="229" ssid = "6">Their clustering-based model is the one we implemented for mv (r, t).</S>
			<S sid ="230" ssid = "7">A similar approach is taken in (Pennacchiotti et al., 2007), where LSA similarity is used to compare between the preferred variable instantiations for a rule and their instantiations in the matched text.</S>
			<S sid ="231" ssid = "8">(Downey et al., 2007) use HMM-based similarity for the same purpose.</S>
			<S sid ="232" ssid = "9">All these methods are analogous to matching cpv (r) with cpv (t) in the CP framework.(Dagan et al., 2006; Connor and Roth, 2007) pro posed generic approaches for identifying valid applications of lexical rules by classifying the surrounding global context of a word as valid or not for that rule.</S>
			<S sid ="233" ssid = "10">These approaches are analogous to matching cpg (r) with cpg (t) in our framework.</S>
	</SECTION>
	<SECTION title="Conclusions. " number = "7">
			<S sid ="234" ssid = "1">We presented the Contextual Preferences (CP) framework for assessing the validity of inferences in context.</S>
			<S sid ="235" ssid = "2">CP enriches the representation of textual objects with typical contextual information that constrains or disambiguates their meaning, and provides matching functions that compare the preferences of objects involved in the inference.</S>
			<S sid ="236" ssid = "3">Experiments with our implemented CP models, over real- world IE data, show significant improvements relative to baselines and some previous work.</S>
			<S sid ="237" ssid = "4">In future research we plan to investigate improved models for representing and matching CP, and to extend the experiments to additional applied datasets.</S>
			<S sid ="238" ssid = "5">We also plan to apply the framework to lexical inference rules, for which it seems directly applicable.</S>
	</SECTION>
	<SECTION title="Acknowledgements">
			<S sid ="239" ssid = "6">The authors would like to thank Alfio Massimiliano Gliozzo for valuable discussions.</S>
			<S sid ="240" ssid = "7">This work was partially supported by ISF grant 1095/05, the IST Programme of the European Community under the PASCAL Network of Excellence IST2002-506778, the NEGEV project (www.negev-initiative.org) and the FBKirst/Bar-Ilan University collaboration.</S>
	</SECTION>
</PAPER>
