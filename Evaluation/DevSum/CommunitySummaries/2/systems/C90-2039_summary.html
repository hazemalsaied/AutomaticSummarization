<html>
<head><title>C90-2039_summary</title> </head>
<body bgcolor="white">
<a name="0">[0]</a> <a href="#0" id=0>A unification example is shown in Fig . </a>
<a name="1">[1]</a> <a href="#1" id=1>Japanese analysis system based on llPSG [ Kogure 891 uses 90 % - 98 % of the elapsed time in FS unification . </a>
<a name="2">[2]</a> <a href="#2" id=2>Other versions based on more efficient graph unification methods such as Wroblewski 's and Kogure 's method [ 23 , 16 ] have also been developed . </a>
<a name="3">[3]</a> <a href="#3" id=3>Strategic Lazy Incremental Copy Graph Unification</a>
<a name="4">[4]</a> <a href="#4" id=4>This order is related to the unification failure tendency . </a>
<a name="5">[5]</a> <a href="#5" id=5>Various kinds of grammatical formalisms without t , transformation were proposed from the late 1970s I ; rough the 1980s l ( ] aider al 85 , l ( plan and Bresnan 82 , Kay 1~5 , Pollm 'd and Sag 871 . </a>
<a name="6">[6]</a> <a href="#6" id=6>These formalisms were applied in the field of natural language processing and , based on these formalisms , ~ : systems such as machine translation systems were developed [ l < ol ; u , e et a l 8gJ . </a>
<a name="7">[7]</a> <a href="#7" id=7>Kowalewski claims that copying is wrong when an algorithm copies too much ( over copying ) or copies too soon ( early copying ) . </a>
<a name="8">[8]</a> <a href="#8" id=8>That is , unless some new scheme for reducing excessive copying is introduced such as scucture-sharing of an unchanged shared-forest ( [ Kogure , 1990 ] ) . </a>
<a name="9">[9]</a> <a href="#9" id=9>The strategic lazy incremental copy graph ( SLING ) unification method combines two incremental copy graph unification methods : the lazy incremental copy graph ( LING ) unification method and the strategic incremental copy graph ( SING ) unification method . </a>
<a name="10">[10]</a> <a href="#10" id=10>This causes O ( log d ) graph node access time overhead in assembling the whole DG from the skeleton and environments where d is the number of nodes in the DG . </a>
<a name="11">[11]</a> <a href="#11" id=11>These unification failure tendencies depend on systems such as analysis systems or generation systems . </a>
<a name="12">[12]</a> <a href="#12" id=12>Previous research identified DG copying as a significant overhead . </a>
<a name="13">[13]</a> <a href="#13" id=13>however the problem with his method is that a unification result graph consists only of newly created structures . </a>
<a name="14">[14]</a> <a href="#14" id=14>One , called the lazy incremental copy graph unification method , achieves structure sharing with constant order data access time which reduces the required memory . </a>
<a name="15">[15]</a> <a href="#15" id=15>Copying sharable parts is called redundant copying . </a>
<a name="16">[16]</a> <a href="#16" id=16>It substitutes arcs with newly copied nodes for existing arcs . </a>
<a name="17">[17]</a> <a href="#17" id=17>ELSE AddArc ( out node shareholder arc node . </a>
<a name="18">[18]</a> <a href="#18" id=18>node 2 Dereferencelnode2 ) . </a>
<a name="19">[19]</a> <a href="#19" id=19>AddArc ( out node complementary new node . </a>
<a name="20">[20]</a> <a href="#20" id=20>For example , the node Y ( G3/ < o c g > ) will be modified to be the Unification result of G 1/ < a c g > ( or G1/ < b d > ) and G2/ < b d > when the feature paths < b d > will be treated . </a></body>
</html>
