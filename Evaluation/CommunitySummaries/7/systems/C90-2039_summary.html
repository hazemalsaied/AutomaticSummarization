<html>
<head><title>C90-2039_summary</title> </head>
<body bgcolor="white">
<a name="0">[0]</a> <a href="#0" id=0>Ile proposed an incremental copy graph unification method to avoid over copying and early copying . </a>
<a name="1">[1]</a> <a href="#1" id=1>Previous research identified DG copying as a significant overhead . </a>
<a name="2">[2]</a> <a href="#2" id=2>A unification example is shown in Fig . </a>
<a name="3">[3]</a> <a href="#3" id=3>In tile directed graph notation , TFS unification corresponds to graph merging . </a>
<a name="4">[4]</a> <a href="#4" id=4>Other versions based on more efficient graph unification methods such as Wroblewski 's and Kogure 's method [ 23 , 16 ] have also been developed . </a>
<a name="5">[5]</a> <a href="#5" id=5>For example , in Kasper 's disjunctive feature description unification , a definite part [ `` S is larger than a disjunct definite part t '' S . </a>
<a name="6">[6]</a> <a href="#6" id=6>For example , the node Y ( G3/ < o c g > ) will be modified to be the unification result of G 1/ < a c g > ( or G1/ < b d > ) and G2/ < b d > when the feature path < b d > will be treated . </a>
<a name="7">[7]</a> <a href="#7" id=7>This order is related to the unification failure tendency . </a>
<a name="8">[8]</a> <a href="#8" id=8>In such cases , application of the EFF strategy , that is , treating features tending to fall in unification first , reduces unnecessary computation when the unification finally fails . </a>
<a name="9">[9]</a> <a href="#9" id=9>Strategic Lazy Incremental Copy Graph Unification</a>
<a name="10">[10]</a> <a href="#10" id=10>in the learning process , when FS unification is applied , feature treatment orders are randomized for the sake of random extraction . </a>
<a name="11">[11]</a> <a href="#11" id=11>That is , the SING unification method applied in an analysis system uses the failure tendency information acquired by a learning analysis process . </a>
<a name="12">[12]</a> <a href="#12" id=12>By using learned failure tendency information , feature value unification is applied in an order that first treats features with the greatest tendency to fail . </a>
<a name="13">[13]</a> <a href="#13" id=13>Kowalewski claims that copying is wrong when an algorithm copies too much ( over copying ) or copies too soon ( early copying ) . </a>
<a name="14">[14]</a> <a href="#14" id=14>Copying sharable parts is called redundant copying . </a>
<a name="15">[15]</a> <a href="#15" id=15>This method achieves structure sharing by introducing lazy copying to Wroblewski 's incremental copy graph unification method . </a>
<a name="16">[16]</a> <a href="#16" id=16>The other, called ti~e strategic incremental copy graph unification method, uses an early failure finding strategy which first tries to unify ;ubstructures tending to fail in unification; this method is; based on stochastic data on tim likelihood of failure and ,'educes unnecessary computation.</a>
<a name="17">[17]</a> <a href="#17" id=17>That is , unless some new scheme for reducing excessive copying is introduced such as scucture-sharing of an unchanged shared-forest ( [ Kogure , 1990 ] ) . </a>
<a name="18">[18]</a> <a href="#18" id=18>When a NODE node 1 has a NODE node 2 as its FORWARD value , the other contents of tile node 1 are ignored and tim contents of node 2 are used . </a>
<a name="19">[19]</a> <a href="#19" id=19>Avoiding this problem in his method requires a special operation of merging a skeleton-environment structure into a skeleton structure , but this prevents structure sharing . </a>
<a name="20">[20]</a> <a href="#20" id=20>however the problem with his method is that a unification result graph consists only of newly created structures . </a>
<a name="21">[21]</a> <a href="#21" id=21>A better method would minimize the copying of sharable arts . </a>
<a name="22">[22]</a> <a href="#22" id=22>Memory is wasted by such redundant copying and this causes frequent garbage collection and page swapping which decrease the total system efficiency . </a>
<a name="23">[23]</a> <a href="#23" id=23>Therefore , Pereira 's method needs relatively few new structures when two input FSs are difference in size and which input is larger are known before unification . </a>
<a name="24">[24]</a> <a href="#24" id=24>This is unnecessary because there are often input subgraphs that can be used as part of the result graph without any modification , or as sharable parts between one of the input graphs and the result graph . </a>
<a name="25">[25]</a> <a href="#25" id=25>Usually , the number of features in two input structures is relatively small and the sizes of the two input structures are often very different . </a>
<a name="26">[26]</a> <a href="#26" id=26>Section 2 explains typed feature structures ( TFSs ) and unification on them . </a>
<a name="27">[27]</a> <a href="#27" id=27>The strategic lazy incremental copy graph ( SLING ) unification method combines two incremental copy graph unification methods : the lazy incremental copy graph ( LING ) unification method and the strategic incremental copy graph ( SING ) unification method . </a>
<a name="28">[28]</a> <a href="#28" id=28>The strategic lazy incremental copy graph unification method is a combination of two methods for unifying mature structures . </a>
<a name="29">[29]</a> <a href="#29" id=29>Output graph G3 Figure 5 : Incremental copy graph unification In this figure , type symbols are omitted . </a>
<a name="30">[30]</a> <a href="#30" id=30>These formalisms were developed relatively independentIy but actually had common properties ; theft is , they used data structures called frictional structures or feature structures and they were based on underneath operation on these data structures . </a>
<a name="31">[31]</a> <a href="#31" id=31>The method is called the lazy i2 ! incremental copy IFaph unification reel , hod ( the LING unification method for short ) . </a>
<a name="32">[32]</a> <a href="#32" id=32>With such a method , it is possible to delay copying a node until either its own contents need to change ( e.g. , node G3/Ka c ! 7 > ) or until it is found to have an arc ( sequence ) to a node t , hat needs to be copied ( e.g. , node X G3/ < a c > in Fig . </a>
<a name="33">[33]</a> <a href="#33" id=33>FOR ALL arc IN nodes DO IF NotNIL ? ( new arc FindArc ( archangel new arcs ) THEN AddArc ( new node Newark undervalue . </a>
<a name="34">[34]</a> <a href="#34" id=34>ENDIF ENDPROCEDURE CopyArcs PROCEDURE AlcsCopied ( node ) new arcs O- FOR ALL arc IN nodes DO new node CopyNode ( overvalue arc , node ) . </a>
<a name="35">[35]</a> <a href="#35" id=35>The revised CopyNode procedure takes as its inputs the node to be copied node I and the arc arc I with node I as its value and node 2 as its immediate ancestor node ( i.e. , the arc 's initial node ) , and does the following ( set Fig . </a>
<a name="36">[36]</a> <a href="#36" id=36>It substitutes arcs with newly copied nodes for existing arcs . </a>
<a name="37">[37]</a> <a href="#37" id=37>ELSE AddArc ( out node shareholder arc node . </a>
<a name="38">[38]</a> <a href="#38" id=38>AddArc ( out node complementary new node . </a>
<a name="39">[39]</a> <a href="#39" id=39>IF Eq ? ( node node 2 THEN Return ( node 1 . </a>
<a name="40">[40]</a> <a href="#40" id=40>ELSE out node GetOutNode ( node node 2 meet ) . </a>
<a name="41">[41]</a> <a href="#41" id=41>ENDPROCEDURE Figure 7 : The revised CopyNode procedure has the disadvantage of treating copy dependency information . </a>
<a name="42">[42]</a> <a href="#42" id=42>node 2 Dereferencelnode2 ) . </a>
<a name="43">[43]</a> <a href="#43" id=43>5 due to a change of node Y G3/ < a c g > ) . </a>
<a name="44">[44]</a> <a href="#44" id=44>Several FS Unification methods were proposed in IKarttunen 86 , Ferreira 85 , Wroblewski 871 . </a></body>
</html>
