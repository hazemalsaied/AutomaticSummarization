<html>
<head><title>C90-2039_summary</title> </head>
<body bgcolor="white">
<a name="0">[0]</a> <a href="#0" id=0>The efficiency of the SING unification method depends on the following factors : ( 1 ) The overall FS unification failure rate of the process : in extreme cases , if Go unification failure occurs , the method has no advantages except the overhead of feature unification order sorting . </a>
<a name="1">[1]</a> <a href="#1" id=1>The SING unification method introduces the concept of feature unification strategy . </a>
<a name="2">[2]</a> <a href="#2" id=2>Other versions based on more efficient graph unification methods such as Wroblewski 's and Kogure 's method [ 23 , 16 ] have also been developed . </a>
<a name="3">[3]</a> <a href="#3" id=3>To achieve this , I , he LING unification method , which uses copy dependency information , was developed . </a>
<a name="4">[4]</a> <a href="#4" id=4>In Kasper 's disjunctive feature description unification [ Kasper 861 , such cases occur very frequently in unifying definite and disjunct 's definite parts . </a>
<a name="5">[5]</a> <a href="#5" id=5>Various kinds of grammatical formalisms without t , transformation were proposed from the late 1970s I ; rough the 1980s l ( ] aider al 85 , l ( plan and Bresnan 82 , Kay 1~5 , Pollm 'd and Sag 871 . </a>
<a name="6">[6]</a> <a href="#6" id=6>in the learning process , when FS unification is applied , feature treatment orders are randomized for the sake of random extraction . </a>
<a name="7">[7]</a> <a href="#7" id=7>These formalisms were developed relatively independentIy but actually had common properties ; theft is , they used data structures called frictional structures or feature structures and they were based on underneath operation on these data structures . </a>
<a name="8">[8]</a> <a href="#8" id=8>In Section 5 , a method which uses this generalized strategy is proposed . </a>
<a name="9">[9]</a> <a href="#9" id=9>The strategic lazy incremental copy graph ( SLING ) unification method combines two incremental copy graph unification methods : the lazy incremental copy graph ( LING ) unification method and the strategic incremental copy graph ( SING ) unification method . </a>
<a name="10">[10]</a> <a href="#10" id=10>When a NODE node 1 has a NODE node 2 as its FORWARD value , the other contents of tile node 1 are ignored and tim contents of node 2 are used . </a>
<a name="11">[11]</a> <a href="#11" id=11>Japanese analysis system based on llPSG [ Kogure 891 uses 90 % - 98 % of the elapsed time in FS unification . </a>
<a name="12">[12]</a> <a href="#12" id=12>That is , unless some new scheme for reducing excessive copying is introduced such as scucture-sharing of an unchanged shared-forest ( [ Kogure , 1990 ] ) . </a>
<a name="13">[13]</a> <a href="#13" id=13>One , called the lazy incremental copy graph unification method , achieves structure sharing with constant order data access time which reduces the required memory . </a>
<a name="14">[14]</a> <a href="#14" id=14>Strategic Lazy Incremental Copy Graph Unification</a>
<a name="15">[15]</a> <a href="#15" id=15>Kowalewski claims that copying is wrong when an algorithm copies too much ( over copying ) or copies too soon ( early copying ) . </a>
<a name="16">[16]</a> <a href="#16" id=16>With such a method , it is possible to delay copying a node until either its own contents need to change ( e.g. , node G3/Ka c ! 7 > ) or until it is found to have an arc ( sequence ) to a node t , hat needs to be copied ( e.g. , node X G3/ < a c > in Fig . </a>
<a name="17">[17]</a> <a href="#17" id=17>The revised CopyNode procedure takes as its inputs the node to be copied node I and the arc arc I with node I as its value and node 2 as its immediate ancestor node ( i.e. , the arc 's initial node ) , and does the following ( set Fig . </a>
<a name="18">[18]</a> <a href="#18" id=18>node 2 Dereferencelnode2 ) . </a>
<a name="19">[19]</a> <a href="#19" id=19>7 ) : ( 1 ) if node , the dereference result of node is current , then CopyNode returns node l '' to indicate that the ancestor node node 2 must be coiffed immediately ; ( 2 ) otherwise , CopyArcs is applied to node 1 and if it returns , ~ ; several arc copies , CopyNode creates a new copy node . </a>
<a name="20">[20]</a> <a href="#20" id=20>A Unification example is shown in Fig . </a></body>
</html>
