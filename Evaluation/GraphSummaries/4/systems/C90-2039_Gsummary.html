<html>
<head><title>C90-2039_Gsummary</title> </head>
<body bgcolor="white">
<a name="0">[0]</a> <a href="#0" id=0>This method achieves structure sharing by introducing lazy copying to Wroblewski 's incremental copy graph unification method . </a>
<a name="1">[1]</a> <a href="#1" id=1>Ile proposed an incremental copy graph unification method to avoid over copying and early copying . </a>
<a name="2">[2]</a> <a href="#2" id=2>Copying sharable parts is called redundant copying . </a>
<a name="3">[3]</a> <a href="#3" id=3>Strategic Lazy Incremental Copy Graph Unification</a>
<a name="4">[4]</a> <a href="#4" id=4>however the problem with his method is that a unification result graph consists only of newly created structures . </a>
<a name="5">[5]</a> <a href="#5" id=5>This method is called the strategic ij ! ~crementaI copy graph unification method ( the SING unification method ) . </a>
<a name="6">[6]</a> <a href="#6" id=6>These two methods can be combined into a single method called the strategic lazy ijAcremeatal copy graph unification method ( the SLING unification method ) . </a>
<a name="7">[7]</a> <a href="#7" id=7>The strategic lazy incremental copy graph ( SLING ) unification method combines two incremental copy graph unification methods : the lazy incremental copy graph ( LING ) unification method and the strategic incremental copy graph ( SING ) unification method . </a>
<a name="8">[8]</a> <a href="#8" id=8>The method is called the lazy i2 ! incremental copy IFaph unification reel , hod ( the LING unification method for short ) . </a>
<a name="9">[9]</a> <a href="#9" id=9>Various kinds of grammatical formalisms without t , transformation were proposed from the late 1970s I ; rough the 1980s l ( ] aider al 85 , l ( plan and Bresnan 82 , Kay 1~5 , Pollm 'd and Sag 871 . </a>
<a name="10">[10]</a> <a href="#10" id=10>These formalisms were applied in the field of natural language processing and , based on these formalisms , ~ : systems such as machine translation systems were developed [ l < ol ; u , e et a l 8gJ . </a>
<a name="11">[11]</a> <a href="#11" id=11>That is , the SING unification method applied in an analysis system uses the failure tendency information acquired by a learning analysis process . </a>
<a name="12">[12]</a> <a href="#12" id=12>Method In a system where FS unification is applied , there are features whose values fail relatively often in unification with other values and there are features whose values do not fail so often . </a>
<a name="13">[13]</a> <a href="#13" id=13>When a new copy of a node is needed later , the LING unification procedure will actually copy structures using the COPY-DEPENDENCY slot value of the node ( in GetOutNode procedure in lJ'ig . </a>
<a name="14">[14]</a> <a href="#14" id=14>The LING unification procedure uses a revised CopyNode procedure which does not copy structures immediately . </a>
<a name="15">[15]</a> <a href="#15" id=15>The NODE structure has the slots TYPESYMBOL to represent a type symbol , ARCS to represent a set of feature-value pairs , GENERATION to specify the unification process in which the structure has been created , FORWARD , and COPY . </a>
<a name="16">[16]</a> <a href="#16" id=16>The section also introduces the key idea of the EFF strategy wolfish comes from observations of his method . </a>
<a name="17">[17]</a> <a href="#17" id=17>Thus , the efficiency gain ficos this method is high when the overall FS unification failure rate of the application process is high . </a>
<a name="18">[18]</a> <a href="#18" id=18>This paper proposes an FS unification method that allows structure sharing with constant moder node access time . </a>
<a name="19">[19]</a> <a href="#19" id=19>The ComplementArcs procedure takes two lists of arcs as NODE TYPESYMBOL : < symbol > [ ARCS : < a list of ARC structures > FORWARD : `` < aNODEstructure orNIL > / COPY : < a NODEstructure or Nil , > GENERATION : < an integer > ARC LABEL : < symbol > VALUE : < : a NODEstructure > Figure 4 : Data Structures for Wroblewski 's method Input graph GI Input graph 62 Â¢ ... ... .'77 ... ... .. i : Sobg , hap's not required to be copied L ... ... ... ... ... ... ... ... ... ... ... ... ... ... . </a>
<a name="20">[20]</a> <a href="#20" id=20>In tile directed graph notation , TFS unification corresponds to graph merging . </a>
<a name="21">[21]</a> <a href="#21" id=21>In this paper , some of the efficiency of the procedure- based system is introduced into an FS unification-based system . </a>
<a name="22">[22]</a> <a href="#22" id=22>The revised procedure uses a newly introduced slot COPY-DEPENDENCY . </a>
<a name="23">[23]</a> <a href="#23" id=23>Ferreira structure sharing FS unification method can avoid this problem . </a>
<a name="24">[24]</a> <a href="#24" id=24>These methods take two DGs as their inputs and give a unification result DG . </a>
<a name="25">[25]</a> <a href="#25" id=25>As in TFS unification , failure tendency information is recorded in terms of a triplet consisting of the greatest lower bound type symbol of the input TFSs ' type symbols , a feature and successful flag . </a>
<a name="26">[26]</a> <a href="#26" id=26>The unification procedure is applied recursively to feature a values of the input nodes . </a>
<a name="27">[27]</a> <a href="#27" id=27>To achieve this , I , he LING unification method , which uses copy dependency information , was developed . </a>
<a name="28">[28]</a> <a href="#28" id=28>The LING unification method achieves structure sharing without the O ( log d ) data access overhead of Pereira 's method . </a>
<a name="29">[29]</a> <a href="#29" id=29>The efficiency of the LING unification method depends on the proportion of newly created structures in the unification result structures . </a>
<a name="30">[30]</a> <a href="#30" id=30>These formalisms were developed relatively independentIy but actually had common properties ; theft is , they used data structures called frictional structures or feature structures and they were based on underneath operation on these data structures . </a>
<a name="31">[31]</a> <a href="#31" id=31>That is , an FS unification method is proposed that introduces a strategy called the early failure tending strategy ( the EFF strategy ) to make FS unification efficient , in this method , FS unification orders are not specified explicitly by rule writers but are controlled by learned information on tendencies of FS constraint application failures . </a>
<a name="32">[32]</a> <a href="#32" id=32>With such a method , it is possible to delay copying a node until either its own contents need to change ( e.g. , node G3/Ka c ! 7 > ) or until it is found to have an arc ( sequence ) to a node t , hat needs to be copied ( e.g. , node X G3/ < a c > in Fig . </a>
<a name="33">[33]</a> <a href="#33" id=33>It substitutes arcs with newly copied nodes for existing arcs . </a>
<a name="34">[34]</a> <a href="#34" id=34>The revised CopyNode procedure takes as its inputs the node to be copied node I and the arc arc I with node I as its value and node 2 as its immediate ancestor node ( i.e. , the arc 's initial node ) , and does the following ( set Fig . </a>
<a name="35">[35]</a> <a href="#35" id=35>Avoiding this problem in his method requires a special operation of merging a skeleton-environment structure into a skeleton structure , but this prevents structure sharing . </a>
<a name="36">[36]</a> <a href="#36" id=36>The combined method Inakes each FS unification efficient and also reduces garbage collection and page swapping occurrences by avoiding memory wastage , thus increasing the total efficiency of li 'S unification-based natural language processing systems such aa analysis and generation systems based on IlI'SG . </a>
<a name="37">[37]</a> <a href="#37" id=37>It then adds the arc copies and arcs of node that are not copied to the new node , and returns the new node ; ( 3 ) otherwise , CopyNode adds the pair consisting of the ancestor node node 2 and the are arc into the COPY- DEPENDENCY slot of node 1 '' and returns Nil_ . </a>
<a name="38">[38]</a> <a href="#38" id=38>AddArc ( out node complementary new node . </a>
<a name="39">[39]</a> <a href="#39" id=39>node 2 Dereferencelnode2 ) . </a>
<a name="40">[40]</a> <a href="#40" id=40>endoscopy new node . </a>
<a name="41">[41]</a> <a href="#41" id=41>ENDIF Returo ( new node . </a>
<a name="42">[42]</a> <a href="#42" id=42>ENDIF IF Eq ? ( out node node 1 THEN complements complement 2 . </a>
<a name="43">[43]</a> <a href="#43" id=43>ENDIF FORALL complement IN complements DO new node CopyNode ( complementary . </a>
<a name="44">[44]</a> <a href="#44" id=44>A Unification example is shown in Fig . </a></body>
</html>
